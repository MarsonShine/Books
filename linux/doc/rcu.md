# 读-复制-修改（RCU）

RCU（Read-Copy-Update）是一种同步机制，主要用于多线程编程，特别是在读多写少的场景中，以提高并发性能。RCU 的核心思想是允许多个读操作并行执行，而不需要加锁，从而极大地减少了读操作的延迟和开销。

RCU 分读写两类操作。

1. 读操作：
   - 读操作在 RCU 中非常简单和快速，因为它们不需要获取锁。读取时使用的数据结构不会在读取过程中被修改，这意味着读操作总是非阻塞的，可以实时访问数据。
2. 写操作：
   - 当需要修改数据（删除，更新，新增）时，写操作者不直接修改原有数据。相反，它们复制要修改的数据部分，并在这个副本上应用更改。
   - 修改完成后，系统通过一个原子操作将指针从旧数据切换到已更新的新数据。此时，新的读操作才会看到更新后的数据。
   - 一旦确认没有任何读取操作还在访问旧数据，旧数据才会被回收。这通常通过使用称为“RCU 读端临界区”的机制来追踪和管理。

RCU 高效的关键在于以下几点：

- **无锁读取**：RCU的一个显著特点是读操作不需要锁定，这使得读取操作非常高效，特别适合高并发环境。
- **延时清理**：**更新数据时，旧数据不会立即删除，而是等到所有可能访问这些数据的读操作都完成后才进行清理。**这通常通过版本控制或者使用 RCU 特有的同步/回收机制实现（发布/订阅机制）。
- **高效写操作**：虽然写操作需要复制和更新数据，但由于切换过程是原子的，它允许系统在新旧数据之间快速切换，而不影响并发读取操作。

## RCU 的并发读写处理

上面提到 RCU 的并发场景下高效的关键在于，它允许读取操作在不阻塞的情况下继续进行，同时允许更新操作（如插入、删除、修改）在后台进行。这是通过**“快照隔离”**来实现的，即读者看到的是数据结构在某个时间点的一致性快照，而这个快照在读取过程中保持不变，即使数据结构正在被更新。

现在我们来具体分析：

1. RCU 读取阶段：
   - 读者通过调用 `rcu_read_lock()` 开始一个读取序列。这个调用是非阻塞的，也不会CPU自旋。
   - 读者可以自由的访问数据结构，它们看到的是数据结构在 `rcu_read_lock()` 调用时刻的快照。
2. RCU 更新阶段：
   - 更新者在修改数据结构之前，需要先使现有的读者完成它们的读取操作。这是通过确保读者有足够的时间来观察到数据结构的更改来实现的。
3. **缓存行无效化**：
   - 当更新者进行修改时，它们会导致包含被修改数据的缓存行在其他 CPU 上无效化。这是因为更新者需要确保读者不会看到部分更新的数据。
   - 当一个 CPU 上的读者尝试访问一个已经被无效化的缓存行时，它会遇到缓存未命中，并且必须重新从主内存中加载该数据。这个过程开销很大，因为它涉及到与主内存的交互。
4. **等待和延迟**：
   - 尽管 `rcu_read_unlock()` 的调用不会直接导致阻塞，但是读者可能会因为缓存未命中而间接“等待”。这是因为它们必须等待从主内存中加载最新的数据。
5. **读取器的延迟**：
   - 读者的这种等待并不是传统意义上的阻塞，而是由于缓存未命中导致的延迟。这种延迟是 RCU 机制的一部分，它允许更新者在不阻塞读取操作的情况下进行数据结构的修改。

现在我们来总结一下 RCU 的关键节点：

- 一致性快照
- 非阻塞读取
- 缓存行无效化：当更新者修改了数据结构中的某个项后，它需要确保所有CPU的缓存中该数据项的副本都是过时的。这通常通过使缓存行无效化来实现，迫使任何尝试访问该数据的CPU重新从主存加载数据。
- 数据重新加载并缓存
- 更新完成



