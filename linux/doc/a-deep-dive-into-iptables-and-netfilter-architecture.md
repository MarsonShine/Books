# 深入研究 Iptables 和 Netfilter 架构

## 引言

防火墙是一个重要的工具，可以通过配置来保护你的服务器和基础设施。**在 Linux 生态系统中，iptables 是一个广泛使用的防火墙工具，与内核的 netfilter 数据包过滤框架对接**。对于不了解这些系统架构的用户和管理员来说，创建可靠的防火墙策略可能是非常困难的，这不仅是由于具有挑战性的语法，而且还因为框架中存在许多相互关联的部分。

在本指南中，我们将深入研究 iptables 的架构，目的是让需要建立自己的防火墙策略的用户更容易理解它。我们将讨论 iptables 如何与 netfilter 交互，以及各种组件如何配合以提供一个全面的过滤和处理系统。

## Iptables 和 Netfilter 是什么？

Linux 中最常用的基本防火墙软件被称为 iptables。iptables 防火墙通过与 Linux 内核网络堆栈中的数据包过滤 Hook 交互来工作。这些内核 hook 被称为 netfilter 框架。

每一个进入网络系统的数据包（传入或传出）在通过堆栈时都会触发这些 hook，允许注册了这些 hook 的程序在关键点上与流量（traffic）进行交互。与 iptables 相关的内核模块在这些 hook 上注册，以确保流量符合防火墙规则所规定的条件。

## Netfilter Hooks

有五个 netfilter hook，程序可以注册。当数据包通过堆栈时，它们将触发已经注册了这些 hook 的内核模块。一个数据包将触发的 hook 取决于该数据包是传入还是传出、数据包的目的地、以及该数据包是否在前一个点被丢弃或拒绝。

以下 hook 代表了网络堆栈中各种定义明确的点：

- `NF_IP_PRE_ROUTING`：这个 hook 将在任何传入的流量进入网络堆栈后很快被触发。这个 hook 是在任何路由决定发送数据包到哪里之前处理的。
- `NF_IP_LOCAL_IN`：如果数据包的目的地是本地系统，这个 hook 会在传入数据包被路由后被触发。
- `NF_IP_FORWARD`：如果数据包要转发到另一个主机，则在传入的数据包被路由后触发这个 hook。
- `NF_IP_LOCAL_OUT`：这个 hook 在任何本地创建的出站流量到达网络堆栈时被触发。
- `NF_IP_POST_ROUTING`：在路由发生之后，在将其放到线路（wire）上之前，任何传出或转发的流量都会触发此钩子。

希望在这些 hook 上注册的内核模块必须提供一个优先级编号，以帮助确定当 hook 被触发时它们将被调用的顺序。这为多个模块（或同一模块的多个实例）提供了与每个 hook 相连的确定顺序。每个模块将被依次调用，并在处理后返回一个决定给 netfilter 框架，该决定表明应该对数据包做什么。

## IPTables 表和链

iptables 防火墙使用表来组织其规则。这些表格根据用于制定决策的类型对规则进行分类。例如，如果一条规则涉及网络地址转换，它将被放入 nat 表。如果该规则用于决定是否允许数据包继续到达目的地，它可能会被添加到过滤器表中。

在每个 iptables 表中，规则被进一步组织在单独的"链（chain）"中。虽然表是由它们持有的规则的一般目标定义的，但内置链代表触发它们的 netfilter hook。链（chain）基本上决定了规则何时会被评估。

正如你所看到的，内置链的名称反映了它们所关联的 netfilter hooks 的名称：

- `PREROUTING`：通过 `NF_IP_PRE_ROUTING` hook 触发。
- `INPUT`：由 `NF_IP_LOCAL_IN` 触发。
- `FORWARD`：由 `NF_IP_FORWARD` 触发。
- `OUTPUT`：由 `NF_IP_LOCAL_OUT` 触发。
- `POSTROUTING`：由 `NF_IP_POST_ROUTING` 触发。

链允许管理员控制在包的传递路径中对规则的位置进行评估。由于每个表都有多个链，一个表的影响可以在处理的多个点上发挥作用。因为某些类型的决策只在网络堆栈的某些点上有意义，所以每个表都不会在每个内核 hook 中注册一个链。

只有五个 netfilter 内核 hook，所以来自多个表的链被注册在每个 hook 上。例如，有三个表有 `PREROUTING` 链。当这些链在相关的 `NF_IP_PRE_ROUTING` hook 注册时，它们指定了一个优先级，决定了每个表的 `PREROUTING` 链被调用的顺序。在进入下一个 `PREROUTING` 链之前，最高优先级的 `PREROUTING` 链内的每个规则都会被依次评估。我们稍后会看一下每个链的具体顺序。

## 哪个表是可用的？

让我们回过头来看看 iptables 提供的不同表。它们表示不同的规则集，按关注的区域组织，用于评估包。

### 过滤表（Filter Table）

过滤表是 iptables 中使用最广泛的表之一。过滤表用于决定是否让一个数据包接收或拒绝到达其预定目的地。在防火墙术语中，这被称为"过滤"数据包。该表提供了人们在讨论防火墙时想到的大部分功能。

### 地址转换表（NAT Table）

nat 表用于实现网络地址转换规则。当数据包进入网络堆栈时，这个表中的规则将决定是否以及如何修改数据包的源地址或目标地址，以影响数据包和任何响应流量的路由方式。这通常用于在不可能直接访问的情况下将数据包路由到网络。

### 纠错表（Mangle Table）

纠错表被用来以各种方式改变数据包的 IP 头。例如，你可以调整数据包的 TTL（生存时间）值，延长或缩短数据包可承受的有效网络跳数（network hops）。其他的 IP 头也可以用类似的方式改变。

该表还可以在数据包上放置一个内部内核"mark"，以便在其他表和其他网络工具中进一步处理。这个标记并不接触实际的数据包，而是将标记添加到内核对数据包的表述中。

### Raw 表（Raw Table）

iptables 防火墙是有状态的，这意味着，根据数据包与前一个数据包的关系来评估数据包。建立在 netfilter 框架之上的*连接追踪功能（connection tracking）*允许iptables 将数据包视为一个正在进行的连接或会话的一部分，而不是作为一个离散的、不相关的数据包流。连接追踪逻辑通常在数据包到达网络接口后不久就会应用。

Raw 表有一个非常小的功能。它的唯一目的是提供一个标记数据包的机制，以便选择退出连接跟踪。

### 安全表（Security Table）

安全表用于在数据包上设置内部 SELinux 安全上下文标记，这将影响 SELinux 或其他可以解释 SELinux 安全上下文的系统如何处理数据包。这些标记可以在每个数据包或每个连接的基础上应用。

## 每个表中都实现了哪些链？

我们已经分别谈到了表和链。让我们来看看每个表中有哪些链可以使用。在这个讨论中隐含了一个关于注册在同一 hook 上的链的求值顺序的进一步讨论。如果三个表都有`PREROUTING` 链，它们之间的求值顺序是什么？

下表显示了从左到右阅读时每个 iptables 表内可用的链。例如，我们可以知道 raw 表有 `PREROUTING`和 `OUTPUT` 两条链。当从上到下阅读时，它还显示了当相关的 netfilter hook 被触发时每个链被调用的顺序。

有几件事需要注意。在下面的表述中，nat 表被分成了 `DNAT` 操作（那些改变数据包的目标地址的操作）和 `SNAT` 操作（那些改变源地址的操作），以便更清楚地显示它们的顺序。我们还包括代表做出路由决定和启用连接追踪的点的行，以便对发生的过程有一个更全面的了解：

| Tables↓/Chains→               | PREROUTING | INPUT | FORWARD | OUTPUT | POSTROUTING |
| ----------------------------- | :--------: | :---: | :-----: | :----: | :---------: |
| (routing decision)            |            |       |         |   ✓    |             |
| **raw**                       |     ✓      |       |         |   ✓    |             |
| (connection tracking enabled) |     ✓      |       |         |   ✓    |             |
| **mangle**                    |     ✓      |   ✓   |    ✓    |   ✓    |      ✓      |
| **nat** (DNAT)                |     ✓      |       |         |   ✓    |             |
| (routing decision)            |     ✓      |       |         |   ✓    |             |
| **filter**                    |            |   ✓   |    ✓    |   ✓    |             |
| **security**                  |            |   ✓   |    ✓    |   ✓    |             |
| **nat** (SNAT)                |            |   ✓   |         |        |      ✓      |

当一个数据包触发一个 netfilter hook 时，相关的链将按照上表中从上到下列出的顺序被处理。数据包将触发的 hook(列)取决于它是传入的还是传出的数据包、所做的路由决策以及数据包是否通过过滤条件。

某些事件将导致表链在处理过程中被跳过。例如，只有在连接中的第一个数据包将被评估为符合 NAT 规则。对第一个数据包做出的任何 NAT 决定都将应用于连接中的所有后续数据包。对 NAT 连接的响应将自动应用反向 NAT 规则来正确路由。

### 链反序

假设服务器知道如何对数据包进行路由，并且防火墙规则允许其传输，以下流程代表了将在不同情况下遍历的路径：

- **以本地系统为目的地的传入数据包**：PREROUTING -> INPUT
- **以另一宿主机为目的地的传入数据包**: PREROUTING -> FORWARD -> POSTROUTING
- **本地产生的数据包：**OUTPUT -> POSTROUTING

如果我们把上述信息与前面表格中的排序结合起来，我们可以看到，一个以本地系统为目的地的传入数据包将首先根据 raw、mangle 和 nat 表的 PREROUTING 链进行评估。然后，它将穿越 mangle、filter、security 和 nat 表的 INPUT 链，最后被传送到本地套接字。

## IPTables 规则

规则被放置在特定表的特定链中。当每个链被调用时，有问题的数据包将被依次对照链内的每个规则进行检查。每个规则都有一个匹配（matching）部分和一个行动（action）部分。

### Matching

规则的匹配部分指定了一个数据包必须满足的标准，以便执行相关的行动（或 "目标（target）"）。

匹配系统非常灵活，并且可以通过系统上的 iptables 扩展进行大幅扩展。可以通过协议类型、目标或源地址、目标或源端口、目标或源网络、输入或输出接口、头文件或连接状态等标准来构建规则。这些都可以结合起来，创建相当复杂的规则集，以区分不同的流量。

### Targets

目标是指当一个数据包符合规则的匹配条件时被触发的行动。目标通常被分为两类。

- **终止目标（Terminal targets）**：终止目标执行一个动作，终止链内的评估并将控制权返回给 netfilter hook。根据所提供的返回值，hook 可能会放弃数据包或允许数据包继续进入下一阶段的处理。
- **非终止目标（Non-terminal targets）**：非终止目标执行一个动作并在链内继续评估。尽管每个链最终必须传回一个最终的终止决定，但任何数量的非终止目标都可以事先执行。

每个目标在规则中的可用性取决于上下文。例如，表和链的类型可能决定了可用的目标。规则中激活的扩展和匹配子句（matching clauses）也会影响目标的可用性。

## 跳转到用户自定义链

我们应该提到一类特殊的非终止目标：跳跃目标（jump target）。跳转目标是导致评估转移到不同的链上进行额外处理的行为。我们已经谈了很多关于内置链的情况，这些链与调用它们的 netfilter hook 密切相关。然而，iptables 也允许管理员为组织目的创建自己的链。

规则可以放在用户定义的链中，就像它们可以放在内置链中一样。不同的是，用户定义的链只能通过从规则中"跳转"到它们（它们本身并没有注册到 netfilter hook）。

用户定义的链作为调用它们的链的简单扩展。例如，在一个用户定义的链中，如果达到了规则列表的末尾，或者 `RETURN` 目标被一个匹配的规则激活，评估将传递回调用链。评估也可以跳转到额外的用户定义的链上。

这种结构允许更多的组织，并为更强大的分支提供必要的框架。

## IPTables 和连接追踪

当我们讨论 raw 表和连接状态匹配标准时，我们介绍了在 netfilter 框架之上实现的连接追踪系统。连接追踪允许 iptables 在一个正在进行的连接的背景下对数据包进行决策。连接追踪系统为 iptables 提供了执行"有状态"操作所需的功能。

连接追踪在数据包进入网络堆栈后很快就被应用。在将数据包与连接相关联之前，原始表链和一些基本的完整检查是对数据包执行的唯一逻辑。

系统根据一组现有的连接检查每个数据包。如果需要，它将更新其存储中的连接状态，并在必要时将新的连接添加到系统中。在一个 raw 链中被标记为 `NOTRACK` 目标的数据包将绕过连接跟踪程序。

### 可用状态

连接追踪系统追踪的连接将处于以下状态之一：

- `NEW`: 当一个没有与现有连接相关联的数据包到达时，但作为第一个数据包并不是无效的，一个新的连接将被添加到系统中，并带有这个标签。这种情况既适用于 TCP 等连接感知协议，也适用于 UDP 等无连接协议。
- `ESTABLISHED`: 当一个连接收到一个相反方向的有效响应时，它将从 `NEW` 连接变为 `ESTABLISHED`。对于 TCP 连接，这意味着一个 SYN/ACK，对于 UDP 和 ICMP 流量，这意味着一个响应，其中原始数据包的来源和目的地被切换。
- `RELATED`: 不属于现有连接的数据包，但与系统中已有的连接相关的数据包被标记为`RELATED`。这可能意味着一个辅助连接，如 FTP 数据传输连接的情况，也可能是对其他协议连接尝试的 ICMP 响应。
- `INVALID`: 如果数据包不与现有的连接相关，不适合打开一个新的连接，如果它们不能被识别，或者如果它们不能被路由，以及其他原因，可以被标记为 `INVALID`。
- `UNTRACKED`: 如果数据包在原始表链中被锁定以绕过跟踪，则可以标记为 `UNTRACKED`。
- `SNAT`: 当源地址被 NAT 操作改变时设置的一种虚拟状态。这是由连接跟踪系统使用的，这样它就知道要在应答包中更改源地址。
- `DNAT`: 当目的地址被 NAT 操作改变时设置的一种虚拟状态。这是由连接跟踪系统使用的，这样它就知道在路由回复数据包时把目标地址改回来。

连接跟踪系统中跟踪的状态允许管理员制定规则，针对连接生命周期中的特定点。这提供了更彻底和安全的规则所需的功能。

## 总结

netfilter 包过滤框架和 iptables 防火墙是 Linux 服务器上大多数防火墙解决方案的基础。netfilter 内核 hook 足够接近网络堆栈，在数据包被系统处理时提供强大的控制。iptables 防火墙利用这些能力，提供了一种灵活、可扩展的方法，将策略要求传达给内核。通过了解这些部分如何结合在一起，你可以更好地利用它们来控制和保护你的服务器环境。

## 原文链接

https://www.digitalocean.com/community/tutorials/a-deep-dive-into-iptables-and-netfilter-architecture