# 内存分配

你电脑上的所有程序都有一个共同点，那就是对内存的需求。程序在运行之前需要从你的硬盘驱动器加载到内存中。在运行过程中，程序所做的大部分工作是从内存中加载数值，对其进行一些计算，然后将结果存储在内存中。

在这篇文章中，我将向你介绍内存分配的基本知识。分配器的存在是因为仅仅有可用的内存是不够的，你需要有效地使用它。我们将直观地探讨简单的分配器的工作原理。我们将看到它们试图解决的一些问题，以及用于解决这些问题的一些技术。在这篇文章的最后，你应该了解编写自己的分配器所需要的一切。



## malloc 和 free

要了解内存分配器的工作，就必须要了解程序是如何请求和返回内存的。`malloc` 和 `free` 是 1979 年在 UNIX v7 中首次以可识别的形式引入的函数。让我们看一下演示其用法的简短的 C 代码程序。

> 哇，等一下。我以前从未写过任何 C 代码。我还能跟上吗？

如果您对另一种语言有初级水平的熟悉程度，例如 Javascript、Python 或 C#，您应该不会遇到任何问题。您不需要理解每一个词，只要您明白了整体的意思。这是本文唯一的 C 代码，我保证。

```c
#include <stdlib.h>

int main() {
  void *ptr = malloc(4);
  free(ptr);
  return 0;
}
```

在上面的程序中，我们通过调用 `malloc(4)` 请求了 4 个字节的内存，我们将返回的值存储在一个名为 `ptr` 的变量中，然后我们通过调用 `free(ptr)` 表明我们已经完成了对内存的使用。

这两个函数是几乎所有程序管理它们使用的内存的方式。即使您不编写 C，执行 Java、Python、Ruby、JavaScript 等的代码也会使用 `malloc` 和 `free` 。

## 什么是内存？

分配器使用的最小内存单元成为“字节”。一个字节可以存储 0 到 255 之间的任何数字。您可以将内存视为一长串子节。我们将把这个序列表示为正方形网格，每个正方形代表一个字节的内容。

![](../asserts/memory.png)

在之前的 C 代码中， `malloc(4)` 分配了 4 个字节的内存。我们将用深色方块表示已分配的内存。

![](../asserts/memory2.png)

然后 `free(ptr)` 告诉分配器我们用完了那块内存。它返回到可用内存池。

这是 4 个 `malloc` 调用后跟 4 个 `free` 调用的样子。您会注意到现在有一个滑块。向右拖动滑块可使时间前进，向左拖动可倒退。您也可以单击网格上的任意位置，然后使用键盘上的箭头键，或者您可以使用左右按钮。滑块上的刻度代表对 `malloc` 和 `free` 的调用。

![](../asserts/memory3.png)

​					注意：原文中此处有交互，建议直接查看原文看动图

> 等一下…… `malloc` 实际返回的值是什么？为程序“提供”内存是什么意思？

`malloc` 返回的内容称为“指针”或“内存地址”。它是一个标识内存中字节的数字。我们通常以称为“十六进制”的形式写入地址。十六进制数以 `0x` 前缀书写，以区别于十进制数。移动下面的滑块以查看十进制数和十六进制数之间的比较。

（交互请查看原文）

这是我们熟悉的记忆网格。每个字节都用十六进制形式的地址进行注释。出于空间原因，我省略了 `0x` 前缀。

![](../asserts/memory4.png)

我们在本文中使用的例子是假设你的计算机只有非常小的内存，但在现实生活中，你有数十亿字节可以使用。真实的地址要比我们在这里使用的大得多，但想法是完全一样的。内存地址是指内存中的一个特定字节的数字。

## 最简单的 malloc

`malloc` 实现的“hello world”将通过跟踪前一个块结束的位置并紧随其后开始下一个块来分配内存块。下面我们用灰色方块表示下一个块应该从哪里开始。

![](../asserts/memory5.png)

你会发现没有内存被释放。如果我们只是跟踪下一个区块应该从哪里开始，而我们不知道以前的区块从哪里开始或结束，`free` 就没有足够的信息来做任何事情。所以它就不做了。这被称为"内存泄漏"，因为一旦分配了内存，就不能再使用。

信不信由你，这并不是一个完全无用的实现。对于使用已知内存量的程序，这可能是一种非常有效的策略。它非常快速且非常简单。但是，作为通用内存分配器，我们不能没有 `free` 实现。

## 最简单的通用 malloc

为了 `free` 内存，我们需要更好地跟踪内存。我们可以通过保存所有分配的地址和大小，以及空闲内存块的地址和大小来做到这一点。我们将分别称它们为“分配列表”和“空闲列表”。

![](../asserts/memory6.png)

我们将空闲列表条目表示为用一条线连接在一起的 2 个灰色方块。您可以想象此条目在代码中表示为 `address=0` 和 `size=32`。当我们的程序启动时，所有内存都被标记为空闲。当调用 `malloc` 时，我们循环遍历我们的空闲列表，直到找到一个足够大的块来容纳它。当我们找到一个时，我们将分配的地址和大小保存在我们的分配列表中，并相应地缩小空闲列表条目。

![](../asserts/memory7.png)

> 我们在哪里保存分配和空闲列表条目？我们不是在假装我们的计算机只有 32 字节的内存吗？

你抓住我了。作为一个内存分配器的好处之一是你负责内存的管理。你可以把你的分配/释放列表存储在一个专门为你保留的区域。或者您可以将其内联存储在每次分配之前的几个字节中。现在，假设我们为自己保留了一些看不见的内存，我们用它来存储我们的分配和释放列表。

那么 `free` 呢？因为我们已经在分配列表中保存了分配的地址和大小，所以我们可以搜索该列表并将分配移回空闲列表。没有尺寸信息，我们将无法做到这一点。

![](../asserts/memory8.png)

​					注意：原文中此处有交互，建议直接查看原文看动图

我们的空闲列表现在有 2 个条目。这可能看起来无害，但实际上是一个严重的问题。让我们实际看看这个问题。

![](../asserts/memory9.png)

​					注意：原文中此处有交互，建议直接查看原文看动图

我们分配了 8 个内存块，每个块大小为 4 个字节。然后我们将它们全部释放，产生 8 个空闲列表条目。我们现在遇到的问题是，如果我们尝试执行 `malloc(8)` ，我们的空闲列表中没有任何项目可以容纳 8 个字节， `malloc(8)` 将失败。

为了解决这个问题，我们需要做更多的工作。当我们 `free` 内存时，我们应该确保如果我们返回到空闲列表的块与任何其他空闲块相邻，我们将它们组合在一起。这称为“合并”。

![](../asserts/memory10.png)

​					注意：原文中此处有交互，建议直接查看原文看动图

非常好。

## 碎片化

完美合并的空闲列表并不能解决我们所有的问题。以下示例显示了更长的分配序列。看看最后的内存状态是什么样子。

![](../asserts/memory11.png)

​					注意：原文中此处有交互，建议直接查看原文看动图

我们以 32 个字节中的 6 个空闲字节结束这个序列，但它们被分成 2 个 3 字节块。如果我们必须为 `malloc(6)` 提供服务，虽然理论上我们有足够的可用内存，但我们将无法这样做。这称为“碎片化”。

> 我们不能重新排列内存以获得 6 个连续字节的块吗？某种碎片整理过程？

遗憾的是没有。还记得前面我们讲到 `malloc` 的返回值是内存中一个字节的地址吗？移动分配不会改变我们已经从 `malloc` 返回的指针。我们会改变这些指针指向的值，有效地破坏它们。这是 `malloc` / `free` API 的缺点之一。

如果我们不能在创建它们之后移动分配，我们需要更加小心我们把它们放在什么地方开始。

令人困惑的是，对抗碎片化的一种方法是过度分配。如果我们总是分配至少 4 个字节，即使请求是 1 个字节，看看会发生什么。这与上面的分配顺序完全相同。

![](../asserts/memory12.png)

​					注意：原文中此处有交互，建议直接查看原文看动图

现在我们可以服务 `malloc(6)` 。值得记住的是，这只是一个例子。程序将根据它们所做的事情以非常不同的模式调用 `malloc` 和 `free` ，这使得设计始终表现良好的分配器变得具有挑战性。

> 在第一个 `malloc` 之后，空闲列表的开始似乎与分配的内存不同步。这是可视化中的错误吗？	

不，这是过度分配的副作用。可视化显示“真实”内存使用，而空闲列表是从分配器的角度更新的。因此，当第一个 `malloc` 发生时，会分配 1 个字节的内存，但空闲列表条目会向前移动 4 个字节。**我们交换一些浪费的空间以换取更少的碎片**。

值得注意的是，这种由过度分配导致的未使用空间是另一种形式的碎片。它是在创建它的分配被释放之前不能使用的内存。因此，我们不想过度分配。例如，如果我们的程序一次只分配 1 个字节，我们将浪费所有内存的 75%。

**另一种解决碎片化的方法是将内存分成一个用于小分配的空间和一个用于大分配的空间。**在下一个可视化中，我们从两个空闲列表开始。浅灰色的用于分配 3 个字节或更小，深灰色的用于分配 4 个字节或更大。同样，这与之前的分配顺序完全相同。

![](../asserts/memory13.png)

​					注意：原文中此处有交互，建议直接查看原文看动图

好的！这也减少了碎片化。但是，如果我们严格只允许在第一段中分配 3 个字节或更少的字节，那么我们就无法为 `malloc(6)` 提供服务。这里的权衡是，为较小的分配保留一段内存可以减少用于较大分配的内存。

> 咦，深灰色空闲链表中最先分配的是 3 个字节！您说这是针对 4 个字节及以上的分配。是什么赋予了这个功能呢？

又抓到我了。我写的这个实现会在浅灰色空间满的时候把小的分配放到深灰色空间。当它这样做的时候，它会进行过度分配，否则，由于小的分配，我们最终会在深灰色空间中出现可避免的碎片化。

根据分配大小拆分内存的分配器称为“slab 分配器”。实际上，它们的尺寸等级比我们示例中的 2 个要多得多。

## 一个快速的 malloc 谜题

如果你 `malloc(0)` 会发生什么？在使用下面的滑块之前先考虑一下。

![](../asserts/memory14.png)

这是使用我们的空闲列表实现，该实现要求分配的最小大小为 4 字节。分配了所有内存，但实际上没有使用任何内存。你认为这是正确的行为吗？

事实证明，不同的实现方式在 `malloc(0)` 时发生的情况是不同的。有些实现的行为如上所述，分配了他们可能不需要的空间。另一些会返回所谓的"空指针"，这是一个特殊的指针，如果你试图读取或写入它所指向的内存，你的程序会崩溃。还有一些会在内存中选择一个特定的位置，并在所有调用 `malloc(0)` 时返回同一个位置，无论调用多少次。

故事有什么启发性？不要执行 `malloc(0)`

## 联机记账

还记得早些时候当您询问分配列表和空闲列表信息存储在哪里时，我给出了一个不令人满意的答案，关于它是如何存储在我们为自己保留的其他内存区域中的吗？

> 是的，还记得

这不是唯一的方法。许多分配器将信息存储在它们相关的内存块旁边。看看这个。

![](../asserts/memory15.png)

我们这里拥有的是没有分配的内存，而是内联存储在该内存中的空闲列表信息。每个内存块，无论是空闲的还是已使用的，都会获得 3 个额外字节的簿记(bookkeepiing)信息。如果 `address` 是分配的第一个字节的地址，则块的布局如下：

1. `address + 0` 是块的大小
2. `address + 1` 是该块是空闲的（1）还是已使用的（2）
3. `address + 2` 是可用内存开始的地方
4. `address + 2 + size` -- 块的大小

因此，在上面的示例中， `0x0` 处的字节存储值 29。这意味着它是一个包含 29 字节内存的块。 `0x1` 处的值 1 表示该块是空闲内存。

> 我们存储大小两次？那不是浪费吗？

乍一看似乎很浪费，但如果我们想进行任何形式的合并，则这是必要的。让我们看一个例子。

![](../asserts/memory16.png)

这里我们分配了 4 个字节的内存。为此，我们的 `malloc` 实现从内存的开头开始并检查是否使用了那里的块。它知道在 `address + 1` 处它会找到 1 或 2。如果它找到 1，它可以检查 `address` 处的值以确定该块有多大。如果足够大，它可以分配进去。如果它不够大，它知道它可以将它在 `address` 中找到的值添加到 `address` 以到达下一个内存块的开始。

这导致创建了一个已用块（注意存储在第二个字节中的 2），并将空闲块的开始向前推了 7 个字节。让我们再次做同样的事情并分配另外 4 个字节。

![](../asserts/memory17.png)

接下来，让我们 `free` 我们的第一个 `malloc(4)` 。`free` 的实现是内联存储信息开始大放异彩的地方。在我们以前的分配器中，我们必须搜索分配列表才能知道块的大小是 `free`。现在我们知道我们会在 `address` 找到它。比这更好的是对于这个 `free` ，我们甚至不需要知道分配有多大。我们可以将 `address + 1` 设置为1！

如果我们想释放第二个已用内存块怎么办？我们知道我们想要合并以避免碎片化，但我们该怎么做呢？这就是看似浪费的簿记发挥作用的地方。

当我们合并时，我们会检查我们正在 `free` ing 的块之前和之后的块的状态。我们知道可以通过将 `address` 处的值添加到 `address` 来到达下一个块，但是我们如何到达上一个块呢？我们取 `address - 1` 的值并从 `address` 中减去该值。如果块末尾没有这种重复的大小信息，就不可能找到前一个块，也无法正确合并。

将这样的簿记信息与分配一起存储的分配器称为“边界标记分配器”。

> 是什么阻止程序修改簿记信息？那不会完全破坏记忆吗？

令人惊讶的是，没有什么能真正阻止这一点。作为一个行业，我们严重依赖代码的正确性。您之前可能听说过“缓冲区溢出”或“释放后使用”错误。这些是当程序修改内存超过分配块的末尾时，或者在 `free` ing 之后意外使用内存块。这些确实是灾难性的。它们可能导致您的程序立即崩溃，它们可能导致您的程序在几分钟、几小时或几天后崩溃。它们甚至可能导致黑客利用该漏洞访问他们不应访问的系统。

我们看到“内存安全”语言越来越受欢迎，例如 Rust。这些语言投入了大量资金来确保从一开始就不可能犯这些类型的错误。他们是如何做到这一点的，不在本文的讨论范围之内，但如果您对此感兴趣，我强烈建议您尝试一下 Rust。

您可能还意识到，在内存块中间的指针上调用 `free` 也会产生灾难性的后果。根据内存中的值，分配器可能会被欺骗，以为它是 `free` ing 某些东西，但它真正在做的是修改不应该修改的内存。

为了解决这个问题，一些分配器将“魔法”值作为簿记信息的一部分注入。例如，他们将 `0x55` 存储在 `address + 2` 中。这会在每次分配时浪费一个额外的内存字节，但可以让他们知道何时发生了错误。为了减少这种影响，分配器通常默认禁用此行为，并允许您仅在调试时启用它。

## 原文链接

https://samwho.dev/memory-allocation/