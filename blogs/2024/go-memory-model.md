# Go 内存模型

当前的 Go 语言内存模型是在 2009 年编写的，之后略有更新。很明显，我们至少应该在当前的内存模型中添加一些细节，其中包括明确认可竞争检测器，以及明确说明同步/原子同步程序中的 API 如何同步程序。

这篇文章着重讲述了 Go 的整体理念和当前的内存模型，然后概述了我认为我们应该对 Go 内存模型做出的相对较小的调整。这篇文章假定了之前的文章[硬件内存模型](hardware-memory-models.md)和[编程语言内存模型](programming-language-memory-models.md)中介绍的背景。

我在 GitHub 上[发起了一个讨论](https://golang.org/s/mm-discuss)，以收集对本文观点的反馈。根据这些反馈，我打算在本月晚些时候准备一份正式的 Go 建议书。使用 GitHub 讨论本身也是一种尝试，目的是继续寻找一种[合理的方式来扩大重要变更的讨论范围](https://research.swtch.com/proposals-discuss)。

## Go 的设计理念

Go 的目标是成为一个用于构建实用、高效系统的编程环境。它的目标是轻量级，适用于小型项目，但也能优雅地扩展到大型项目和大型工程团队。

Go 鼓励在高层次上处理并发问题，尤其是通过通信。Go 的[第一句谚语](https://go-proverbs.github.io/)是“不要通过共享内存来通信。通过通信共享内存”。另一句流行的谚语是“清晰胜于巧妙”。换句话说，Go 鼓励通过避免微妙的代码来避免微妙的 bug。

Go 的目标不仅是让程序易于理解，还要让语言易于理解，软件包 API 易于理解。复杂或微妙的语言特性或 API 与这一目标相悖。正如 Tony Hoare 在 [1980 年图灵奖演讲](https://www.cs.fsu.edu/~engelen/courses/COP4610/hoare.pdf)中所说：

> 我的结论是，构建软件设计有两种方法：一种方法是把软件设计得非常简单，以至于没有明显的缺陷；另一种方法是把软件设计得非常复杂，以至于没有明显的缺陷。
>
> 第一种方法要困难得多。它需要与发现作为复杂自然现象基础的简单物理定律同样的技巧、奉献、洞察力甚至灵感。它还要求人们愿意接受受到物理、逻辑和技术限制的目标，并在无法实现相互冲突的目标时接受妥协。

这与 Go 的 API 理念非常吻合。在设计过程中，我们通常会花很长时间来确保 API 是正确的，并努力将其缩减到最小、最有用的本质。

Go 作为一个有用的编程环境的另一个方面是为最常见的编程错误定义了明确的语义，这有助于理解和调试。这个想法并不新鲜。再次引用 Tony Hoare 的话，这次引用的是 1972 年的[“软件质量”清单](https://onlinelibrary.wiley.com/doi/abs/10.1002/spe.4380020202)：

> 软件程序不仅要简单易用，还必须很难被误用；它必须善待编程错误，清楚地显示错误的发生，并且永远不会产生不可预知的效果。

为错误百出的程序提供定义明确的语义这一常识并不像人们想象的那样普遍。在 C/C++ 中，“未定义行为”已经演变成一种编译器编写者的全权委托，可以用更有趣的方式将稍有错误的程序变成错误百出的程序。Go 不采用这种方法：不存在 “未定义行为”。特别是像空指针取消引用、整数溢出和无意的无限循环这样的错误，在 Go 中都有确定的语义。

## 如今的 Go 内存模型

[Go 的内存模型](https://golang.org/ref/mem)从以下建议开始，这与 Go 整体理念是一致的：

> 修改同时被多个 goroutines 访问的数据的程序必须将这种访问序列化。
>
> 为使访问序列化，应使用通道操作或其他同步原语（如 `sync` 和 `sync/atomic` 包中的原语）来保护数据。
>
> 如果你必须阅读本文档的其余部分才能理解程序的行为，那你就太聪明了。
>
> 不要自作聪明。

这仍然是很好的建议。这一建议与其他语言鼓励使用 DRF-SC 的做法也是一致的：通过同步消除数据竞争，然后程序就会像顺序一致的程序一样运行，无需了解内存模型的其余部分。

在这条建议之后，Go 的内存模型定义了基于 happens-before 的传统竞争读写定义。就像在 Java 和 JavaScript 中一样，Go 中的读取可以观察发生在之前顺序中任何较早但尚未被覆盖的写入，或者任何竞争写入；只安排一个这样的写入会强制产生特定的结果。

内存模型接着定义了建立跨程序 happens-before 边的同步操作。这些操作都是常规操作，但也有一些 Go 特有的操作：

- 如果软件包 p 导入了软件包 q，那么 q 的 `init` 函数会在 p 的 `init` 函数开始之前完成。
- 函数 `main.main` 的启动发生在所有 `init` 函数完成之后。
- 启动新 goroutine 的 go 语句发生在 goroutine 开始执行之前。
- 通道上的发送发生在该通道的相应接收完成之前。
- 通道的关闭发生在因通道关闭而返回零值的 receive 之前。
- 未缓冲通道的接收发生在该通道的发送完成之前。
- 容量为 C 的通道上的第 k 次接收发生在该通道的第 k+C 次发送完成之前。
- 对于任何 `sync.Mutex` 或 `sync.RWMutex` 变量 `l` 且 n < m，`l.Unlock()` 的调用 n 发生在 `l.Lock()` 的调用 m 返回之前。
- 对 `once.Do(f)` 的单次调用发生（返回）在对 `once.Do(f)` 的任何调用返回之前。

该列表明显忽略了同步/原子以及包同步中的较新 API。

内存模型的结尾是一些不正确的同步示例。它没有包含错误编译的示例。

## Go 内存模型的变化

2009 年，当我们着手编写 Go 的内存模型时，Java 内存模型正在进行新的修订，而 C/C++11 内存模型也即将定稿。一些人极力鼓励我们采用 C/C++11 模型，以充分利用所有的工作成果。这对我们来说似乎很冒险。相反，我们决定采用一种更保守的方法来保证我们将做出的保证，而随后发表的十余篇论文也证实了这一决定，这些论文详细描述了 Java/C/C++ 内存模型系列中的一些非常微妙的问题。定义足够多的内存模型来指导程序员和编译器编写者是非常重要的，但完全正式地定义一个内存模型--正确地！--似乎仍然超出了最有才华的研究人员的能力范围。对于 Go 来说，只要能继续提供有用的最低限度的信息就足够了。

本节列出了我认为我们应该做出的调整。如前所述，我在 [GitHub 上发起了一个讨论](https://golang.org/s/mm-discuss)，以收集反馈意见。根据这些反馈，我计划在本月晚些时候准备一份正式的 Go 建议书。

### 记录 Go 的整体方法

“不要自作聪明”的建议很重要，应该保留，但在深入探讨 happens-before 的细节之前，我们还需要对 Go 的整体方法多说几句。我看到过许多对 Go 方法的错误总结，比如声称 Go 的模型是 C/C++ 的 DRF-SC 或 Catch Fire。误读是可以理解的：文档并没有说明方法是什么，而且文档太短（材料太微妙），以至于人们看到的是他们期望看到的东西，而不是有或没有的东西。

需要添加的文字大致如下：

> ### 概述
>
> Go 处理内存模型的方式与该语言的其他部分大致相同，旨在保持语义的简单、易懂和实用。
>
> 数据竞争被定义为对同一内存位置发生并发的写操作与另一个读或写操作,除非所有相关的访问都是由 `sync/atomic` 包提供的原子数据访问。如前所述,强烈鼓励程序员使用适当的同步来避免数据竞争。在没有数据竞争的情况下,Go 程序的行为就好像所有 goroutine 都被多路复用到单个处理器上一样。这种属性有时被称为 DRF-SC：无数据竞争的程序以顺序一致的方式执行。
>
> 其他编程语言通常采用两种方法之一来处理包含数据竞争的程序。第一种方法，例如 C 和 C++,是将包含数据竞争的程序视为无效：编译器可能会以令人惊讶的任意方式破坏它们。第二种方法，例如 Java 和 JavaScript,是为包含数据竞争的程序定义了语义，限制了竞争的可能影响，使程序更可靠、更易于调试。Go的方法介于这两种方法之间。包含数据竞争的程序从某种意义上说是无效的，因为实现可能会报告竞争并终止程序。但除此之外,包含数据竞争的程序具有定义的语义，只有有限的结果，使有缺陷的程序更可靠、更容易调试。

这篇文章应明确说明 Go 与其他语言的不同之处，纠正读者之前的期望。

在“Happens Before”部分的结尾，我们还应该澄清某些竞争条件仍然可能导致数据损坏。当前的结尾是这样的：

> 读取和写入大于一个机器字的值时，会以未指定的顺序进行多个机器字大小的操作。

我们应该补充：

> 请注意，这意味着多字数据结构上的竞争会导致与单次写入不对应的不一致值。当值依赖于内部（指针、长度）或（指针、类型）对的一致性时（大多数 Go 实现中的接口值、映射、片段和字符串就是这种情况），这种竞争反过来又会导致任意的内存损坏。

这将更清楚地说明保证对有数据竞争的程序的限制。

### sync 库的 happens-before 文档

自内存模型编写以来，[sync 包](https://golang.org/pkg/sync)中已经新增了一些 API。我们需要将它们添加到内存模型中（[issue＃7948](https://golang.org/issue/7948)）。幸运的是，这些新增内容看起来很简单。我认为它们如下所示。

- 对于 [sync.Cond](https://golang.org/pkg/sync/#Cond)：`Broadcast` 或 `Signal` 发生在解除阻塞的任何 `Wait` 调用的返回之前。
- 对于 [sync.Map](https://golang.org/pkg/sync/#Map)：`Load`，`LoadAndDelete` 和 `LoadOrStore` 是读操作。`Delete`，`LoadAndDelete` 和 `Store` 是写操作。当 `LoadOrStore` 返回 `loaded` 为 `false` 时，它是一个写操作。写操作发生在观察到该写操作的任何读操作之前。
- 对于 [sync.Pool](https://golang.org/pkg/sync/#Pool)：调用 `Put(x)` 发生在调用 `Get` 并返回相同值 `x` 之前。类似地，调用 `New` 并返回 `x` 发生在调用 `Get` 并返回相同值 `x`之前。
- 对于 [sync.WaitGroup](https://golang.org/pkg/sync/#WaitGroup)：调用 `Done` 发生在解除阻塞的任何 `Wait` 调用的返回之前。

这些 API 的使用者需要了解这些保证，以便有效地使用它们。因此，虽然我们应该保留内存模型中的文本以说明目的，但我们也应该将其包含在 package sync 的文档注释中。这也有助于为第三方同步原语树立一个示例，说明文档化 API 所建立的排序保证的重要性。

### sync/atomic 的 happens-before 文档

内存模型中缺少原子操作。我们需要添加它们（[issue# 5045](https://golang.org/issue/5045)）。我认为我们应该说：

> sync/atomic 软件包中的应用程序接口统称为“原子操作”，可用于同步不同程序的执行。如果原子操作 A 的效果被原子操作 B 观察到，则 A 发生在 B 之前。

这是 [Dmitri Vyukov 在 2013 年建议](https://github.com/golang/go/issues/5045#issuecomment-66076297)的，也是[我在 2016 年非正式承诺](https://github.com/golang/go/issues/5045#issuecomment-252730563)的。它的语义与 Java 的 `volatiles` 和 C++ 的默认 atomics 相同。

就 C/C++ 菜单而言，同步原子只有两种选择：顺序一致或 acquire/release。(松弛原子不会创建 happens-before 边，因此没有同步效果）。在这两种选择中，首先要考虑的是推理多个位置上原子操作的相对顺序有多重要，其次是顺序一致原子操作比 acquire/release 原子操作要昂贵得多。

首先，推理多个位置上原子操作的相对顺序非常重要。在前一篇文章中，我举例说明了[使用两个原子变量实现无锁快速路径的条件变量](https://research.swtch.com/plmm#cond)，并通过使用 acquire/release 原子操作打破了这一路径。这种模式一再出现。例如，过去的 `sync.WaitGroup` 实现使用了[一对原子 uint32 值](https://go.googlesource.com/go/+/ee6e1a3ff77a41eff5a606a5aa8c46bf8b571a13/src/pkg/sync/waitgroup.go#54)：`wg.counter` 和 `wg.waiters`。[Go 对 semaphores 的运行时实现](https://go.googlesource.com/go/+/cf148f3d468f4d0648e7fc6d2858d2afdc37f70d/src/runtime/sema.go#134)也依赖于两个独立的原子词，即 semaphore 值 `*addr` 和相应的等待者计数 `root.nwait`。还有更多。在没有顺序一致语义的情况下（也就是说，如果我们采用 acquire/release 语义），人们仍然会写出这样的代码；只是会神秘地失败，而且只在特定的上下文中失败。

根本问题在于，使用 acquire/release 原子操作使程序无数据竞争，并不会导致程序以顺序一致的方式运行，因为原子操作本身并不具备顺序一致性。也就是说，这样的程序并不提供 DRF-SC。这使得这样的程序非常难以推理，因此难以编写正确的程序。

在第二个考虑因素中，正如之前的帖子中指出的，[硬件设计师开始提供对顺序一致原子操作的直接支持](https://research.swtch.com/plmm#sc)。例如，ARMv8 添加了 `ldar` 和 `stlr` 指令，用于实现顺序一致的原子操作，并且它们也是 [acquire/release 原子操作的推荐实现方式](https://www.cl.cam.ac.uk/~pes20/cpp/cpp0xmappings.html)。如果我们为 `sync/atomic` 采用 acquire/release 语义，那么在 ARMv8 上编写的程序将自动获得顺序一致性。这无疑会导致依赖更强排序的程序在较弱的平台上意外中断。如果由于竞争窗口很小而很难观察到 acquire/release 原子操作和顺序一致原子操作之间的差异，那么这甚至可能发生在单个架构上。

这两个考虑因素强烈建议我们应该采用顺序一致的原子操作，而不是采用 acquire/release 原子操作：顺序一致的原子操作更有用，并且一些芯片已经完全消除了两者之间的差距。如果差距很显著，其他芯片也可能采取同样的做法。

同样的考虑因素，以及 Go 语言整体上具有最简化、易于理解的 API 的理念，反对提供 acquire/release 作为额外的、并行的 API 集。最好只提供最易理解、最有用、最不容易被错误使用的一组原子操作。

另一种可能性是提供原始的屏障而不是原子操作（当然，C++ 提供了两者）。屏障的缺点是使期望不太明确，并且与体系结构有些相关。Hans Boehm 的论文“[Why atomics have integrated ordering constraints](http://www.hboehm.info/c++mm/ordering_integrated.html)”提出了提供原子操作而不是屏障的论据（他使用术语 fences）。通常，原子操作比屏障要容易理解得多，而且由于我们已经提供了原子操作，难以轻易删除它们。最好只有一个机制，而不是两个。

### 可能：添加类型 API到 sync/atomic

上述定义指出，当特定的内存片段必须由多个 goroutine 并发访问而没有其他同步时，消除竞争的唯一方法是使所有访问都使用原子操作。仅仅使部分访问使用原子操作是不够的。例如，非原子写操作与原子读操作或写操作并发仍然会导致竞争，而原子写操作与非原子读/写操并发也会导致竞争。

因此，是否应该使用原子操作来访问特定值是该值的属性，而不是特定访问的属性。由于这个原因，大多数语言将这些信息放在类型系统中，例如 Java 的 `volatile int` 和 C++ 的 `atomic<int>`。Go 语言的当前 API 没有这样做，这意味着正确使用需要仔细注释哪些结构体字段或全局变量只能使用原子 API 进行访问。

为了提高程序的正确性，我开始认为 Go 语言应该定义一组有类型的原子值，类似于当前的 `atomic.Value：Bool、Int、Uint、Int32、Uint32、Int64、Uint64` 和 `Uintptr`。与 `Value` 类似，这些值将具有 `CompareAndSwap、Load、Store` 和 `Swap` 方法。例如：

```go
type Int32 struct { v int32 }

func (i *Int32) Add(delta int32) int32 {
    return AddInt32(&i.v, delta)
}

func (i *Int32) CompareAndSwap(old, new int32) (swapped bool) {
    return CompareAndSwapInt32(&i.v, old, new)
}

func (i *Int32) Load() int32 {
    return LoadInt32(&i.v)
}

func (i *Int32) Store(v int32) {
    return StoreInt32(&i.v, v)
}

func (i *Int32) Swap(new int32) (old int32) {
    return SwapInt32(&i.v, new)
}
```

我之所以将 `Bool` 列入列表，是因为在 Go 标准库中（在未导出的 API 中），我们已经多次用原子整数构造了原子布尔。这显然是有必要的。

我们还可以利用即将到来的泛型支持，为原子指针定义一个类型化的 API，并且在其 API 中不含包 `unsafe`：

```go
type Pointer[T any] struct { v *T }

func (p *Pointer[T]) CompareAndSwap(old, new *T) (swapped bool) {
    return CompareAndSwapPointer(... lots of unsafe ...)
}
```

(以此类推。）要回答一个显而易见的建议，我没有看到使用泛型来提供一个 `atomic.Atomic[T]` 的简洁方法，这样我们就可以避免将 `Bool`、`Int` 等作为单独的类型引入，至少在编译器中没有特殊情况下是这样。这也没有问题。

### 可能：添加非同步原子

所有其他现代编程语言都提供了一种进行并发内存读写的方法，既不同步程序，也不使其无效（不算作数据竞争）。C、C++、Rust 和 Swift 具有松散原子操作。Java 具有 [VarHandle 的“plain”模式](https://docs.oracle.com/javase/9/docs/api/java/lang/invoke/VarHandle.html)。JavaScript 具有对 `SharedArrayBuffer` 的非原子访问（唯一的共享内存）。而 Go 语言却没有这样的机制。也许我们应该考虑添加这样的机制，但我不确定。

如果我们想要添加非同步的原子读写，我们可以为有类型的原子操作添加 `UnsyncAdd`、`UnsyncCompareAndSwap`、`UnsyncLoad`、`UnsyncStore` 和 `UnsyncSwap` 方法。将它们命名为“unsync”可以避免一些与“relaxed”名称相关的问题。首先，有些人将“relaxed”作为相对比较的方式使用，比如“acquire/release 比顺序一致性的内存顺序更松弛”。你可以争辩这不是术语的正确用法，但这种使用方式确实存在。其次，更重要的是，关于这些操作的关键细节不是操作本身的内存顺序，而是它们对程序其余部分的同步没有影响。对于不是内存模型专家的人来说，看到 `UnsyncLoad` 应该明确表示没有同步，而 `RelaxedLoad` 可能不会。而且，`Unsync` 在一瞥之间看起来像 `Unsafe`，这也很好。

在解决了 API 的问题之后，真正的问题是是否要添加这些机制。提供非同步原子操作的通常论点是，它确实对某些数据结构中的快速路径性能非常重要。我总体的印象是，这在非 x86 架构上更为重要，尽管我没有数据来支持这一点。不提供非同步原子操作可能会对这些架构造成不利影响。

提供非同步原子操作的一个可能的反对理由是，在 x86 上，忽略潜在的编译器重排序效应，非同步原子操作与 acquire/release 原子操作是无法区分的。因此，它们可能被滥用以编写仅在 x86 上有效的代码。反驳的观点是，这样的伎俩在竞争检测器中是无法通过的，竞争检测器实现了实际的内存模型而不是 x86 的内存模型。

根据我们今天所拥有的证据，我们没有理由添加这个 API。如果有人坚决认为我们应该添加它，那么提出这个观点的方法将是收集以下两方面的证据：（1）在程序员需要编写的代码中的普遍适用性，（2）使用非同步原子操作在广泛使用的系统上带来的显著性能改进。（可以使用 Go 语言之外的其他语言的程序来展示这一点。）

### 禁止编辑器优化文档

当前的内存模型以举例说明无效程序而告终。既然内存模型是程序员和编译器编写者之间的契约，我们就应该增加无效编译器优化的例子。例如，我们可以添加：

> ### 不正确的编译
>
> Go 内存模型对编译器优化的限制与对 Go 程序的限制一样多。一些在单线程程序中有效的编译器优化在 Go 程序中无效。特别是，编译器不能在无竞争程序中引入数据竞争。编译器不得允许一次读取观测多个值。也不能允许一次写入写入多个值。
>
> 不在无竞争程序中引入数据竞争意味着不将读取或写入移出它们出现的条件语句。例如，编译器不得反转此程序中的条件语句：
>
> ```
> i := 0
> if cond {
>     i = *p
> }
> ```
>
> 也就是说，编译器不能将程序重写为这个程序：
>
> ```
> i := *p
> if !cond {
>     i = 0
> }
> ```
>
> 如果 `cond` 为 false，而另一个 goroutine 正在写 `*p`，那么原始程序是无竞争的，但重写的程序包含竞争。
>
> 不引入数据竞争还意味着不假设循环终止。例如，在本程序中，编译器不得将对 `*p` 或 `*q` 的访问移至循环之前：
>
> ```
> n := 0
> for e := list; e != nil; e = e.next {
>     n++
> }
> i := *p
> *q = 1
> ```
>
> 如果 `list` 指向循环 list，那么原始程序将永远不会访问 `*p` 或 `*q`，但重写后的程序却可以。
>
> 不引入数据竞争还意味着不假定被调用的函数总是返回或没有同步操作。例如，编译器不能将对 `*p` 或 `*q` 的访问移到该程序中函数调用的前面（至少在不直接了解 `f` 的精确行为的情况下不能这样做）：
>
> ```
> f()
> i := *p
> *q = 1
> ```
>
> 如果调用从未返回，那么原程序将永远不会访问 `*p` 或 `*q`，但改写后的程序却可以。如果调用包含同步操作，那么原程序可以在访问 `*p` 和 `*q` 之前的边界发生同步操作，但改写后的程序不会。
>
> 不允许一次读取观察多个值意味着不允许从共享内存中重新加载局部变量。例如，在这个程序中，编译器不得溢出 `i` 并从 `*p` 中第二次重新加载 `i`：
>
> ```
> i := *p
> if i < 0 || i >= len(funcs) {
>     panic("invalid function index")
> }
> ... complex code ...
> // compiler must NOT reload i = *p here
> funcs[i]()
> ```
>
> 如果复杂代码需要很多寄存器，单线程程序的编译器可以丢弃 `i` 而不保存副本，然后在 `funcs[i]()` 之前重新加载 `i = *p`。但 Go 编译器不能这样做，因为 `*p` 的值可能已经改变。(相反，编译器可以将 `i` 放入堆栈）。
>
> 不允许一次写入多个值还意味着在写入之前，不使用将写入局部变量的内存作为临时存储空间。例如，在本程序中，编译器不得将 `*p` 用作临时存储空间：
>
> ```
> *p = i + *p/2
> ```
>
> 也就是说，它不能将程序改写成这个程序：
>
> ```
> *p /= 2
> *p += i
> ```
>
> 如果 `i` 和 `*p` 开始时都等于 2，原始代码会执行 `*p = 3`，因此竞争线程只能从 `*p` 读取 2 或 3。改写后的代码先执行 `*p = 1`，然后执行 `*p = 3`，这样赛车线程也能读取 1。
>
> 请注意，所有这些优化在 C/C++ 编译器中都是允许的：与 C/C++ 编译器共享后端的 Go 编译器必须注意禁用对 Go 无效的优化。

这些类别和示例涵盖了最常见的 C/C++ 编译器优化，它们与竞争数据访问的定义语义不兼容。它们清楚地表明，Go 和 C/C++ 有不同的要求。

## 总结

Go 在内存模型方面的保守态度一直以来都为我们提供了良好的服务，我们应该继续保持这种态度。然而，有一些改变早该做出，包括定义 `sync` 和 `sync/atomic` 包中新 API 的同步行为。特别是 atomics，应在文档中提供顺序一致的行为，创建 happens-before 边界，同步其周围的非原子代码。这将与所有其他现代系统语言提供的默认 atomics 相匹配。

更新中最独特的部分可能就是明确指出，存在数据竞争的程序可以停止运行以报告竞争，但在其他方面具有定义明确的语义。这对程序员和编译器都是一种约束，它优先考虑了并发程序的可调试性和正确性，而不是编译器编写者的便利性。

## 致谢

与我有幸在谷歌共事的一长串工程师的讨论和他们的反馈让这一系列文章受益匪浅。在此向他们表示感谢。对于任何错误或不受欢迎的观点，我将承担全部责任。