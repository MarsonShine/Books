# Stackful和Stackless协程的可恢复函数



## 背景

2014年6月在 Rapperswil，Nat Goodspeed 和 Oliver Kowalke 向 SG1 提出了在 C++ 中添加协程的提议。Niklas Gustafsson 提出了在 C++ 中添加可恢复函数的建议。SG1 指示我们将这些建议放在一个单一的概念空间中，以便尽可能统一它们。Nat、Oliver、Niklas 和 Torvald Riegel 在 Rapperswil 上详细讨论了这个概念空间。Nat 和 Gor Nishanov 在 Redmond 继续讨论。本文试图回应委员会的要求。

## 概述

### 协程

N3985 提出了一个 c++ 协程库。此可调用对象接受对额外的综合库的 `asymmetric_coroutine<T>::push_type` 的非常量引用；此 push_type 对象上的方法切换上下文并传输数据。（这个主题有一些变化，但就目前而言，这个案例就足够了。）

一个普通函数可以从函数体的中间返回一个值给它的调用者。

这些协程的另一个特点是调用者可以将控制权传递回函数体的中间，即它最后暂停执行的地方。

N3985 中提出的协程是有意 stackful 的。作者断言，这种协程的大部分价值在于它们的堆栈性质。

### 可恢复能力

N3858、N3977 和 D4134 提出了支持可恢复函数的新语言。不管编译器是否需要关键字来识别这样的函数，可恢复函数都是其特征是在其正文中至少存在一个“await”关键字。 （还有关于“yield”关键字的讨论，但目前我们只考虑“await”。）

可恢复函数返回一个潜在的值，一个在某来某个时刻返回给它的调用者。与期货一样，它在调用者接收到它的那一刻可能持有也可能不持有。称之为“returned”的future。（该提案还支持其他返回类型，但为简单起见，我们将讨论future。）

函数主体中的“return”语句用一个值填充返回到future，并退出函数。

函数体中的异常用异常填充返回给future。

函数主体中一个“await”表达式引入了对其它一些明确指定的future的依赖。这称之为“awaited” future。如果 awaited future 已经持有一个值了，“await”就会推送这个 awaited future 的值并延续函数体中后续的执行。但是如果这个 awaited future 仍在处理中，那么 “await” 会在 awaited future 获取值的一瞬间就会重新获取控制权。“await” 然后将一个待处理的future返回给它的调用者。在后续某个时间点 awaited future 将会填充这个值；这会导致可恢复函数在“await”暂停的地方重新进入。它将从那个地方开始，最终执行“return”语句或其它的”await“，又或是抛出异常。

尽管 N3858 考虑了可恢复函数的堆栈和无堆栈实现，但 D4134 的作者断言，可伸缩性的设计目标需要无堆栈实现。

### 挂起（suspension）

正如 Torvald 所指出的，N3985 协程和 D4134 可恢复程序的共同特征是挂起操作：控制可以以这样一种方式传递出函数体，以便以后可以在同一点恢复。

### 语义

到目前为止，大多数关于将协程与可恢复的想法统一起来的讨论已经很快的进入了实现领域。对于本文的大部分内容，我们努力保持在所需语义的范围内。在标准中有很多情况，不同的实现仍然可以产生相同的语义行为。在这里我们必须考虑语义本身是如何发散的（diverge）

```c++
// N3985 协程
typedef asymmetric_coroutine<int> coro_t;

void coro(coro_t::pull_type& source)
{
	before_suspend();
	source();
	int value = source.get()
	after_suspend();
}
```

```c++
// D4134 可恢复函数
future<int> somefunc();

future<int> resumable()
{
	before_suspend();
	int value = await somefunc();
	after_suspend();
	return value;
}
```

很明显，在进入时，`coro()` 和 `resumable()` 都会调用 `before_suspend()`。对 `source()` 的调用无条件地挂起 `coro()`；我们假设至少在某些情况下，`somefunc()` 需要等待一些外部资源，因此会暂停 `resumable()`。最后，在恢复时，`coro()` 和 `resumable()` 都会调用 `after_suspend()`。这些都是相似之处

关键的区别在于每个函数的挂起方式。

出于讨论的目的，让我们将函数调用链可视化为向下增长。也就是说，程序的 main() 堆栈帧位于顶部。main() 调用的函数 foo() 的堆栈帧低于 main 的；由 foo() 调用的函数 bar() 位于它们的下方。

```c++
int main()
{
	int n = 0;
	foo();
	return 0;
}

int foo()
{
	bar();
	return 0;
}

int bar()
{
	return 0;
}
```

### 无栈式挂起

#### 调用者责任

一个无堆栈的可恢复函数必须通过上下传递控制来挂起。也就是说，从根本上说，函数必须以某种方式将控制权返回给它的调用者。这不是实现细节；这是“无堆栈”的本质要求的。称其为对实现的约束。

这意味着调用者有义务区分普通返回（可用值）和暂停（还没有值）。考虑一系列可恢复函数：A → B → C。B 必须在这两种情况下表现非常不同。如果 C 正在暂停，B 也必须同样暂停；当 C 返回一个值时，B 可以继续执行它自己的主体。

有几种方法可以让可恢复的将这种区别传达给它的调用者。例如：

1. 可恢复函数可以通过抛出异常来挂起。调用者可以捕获它，更新自己的恢复信息并依次向调用者重新抛出异常。可恢复函数的正常返回意味着有值可用。这具有一定的直接吸引力，尽管可能会影响性能。
2. 可恢复函数可以返回一个可能包含也可能不包含值的类型，例如 `std::future`。现有技术使用了这种策略，一旦填充了 "awaited" future，就利用 `std::future::then()`将控制权传递回暂停的可恢复函数。
3. 可恢复函数可以接受一个非常量引用参数，通过该参数将区别传达给它的调用者。这与前面的非常相似，我们将把两者合并。
4. 可恢复函数可以设置全局状态——更确切的说，该状态在每个执行代理数据区域中。

要点是：不管实现细节如何，调用无堆栈可恢复函数的代码必须知道该函数可能返回值，也可能不返回值。（但是，已经返回的函数（例如`std::future`）可以透明地转换为可恢复函数或从可恢复函数转换：调用者不需要关心 future 是如何产生的。）

#### 维护影响

D4134 向我们保证，无堆栈式的可恢复函数可以不受限制地无缝调用现有代码、库和 OS API。

考虑一个大型的现有代码库。它的一部分使用可恢复的函数来管理异步 I/O；其他不需要挂起的部分是简单的 C++，写入同步返回值而不是 `std::futures`。

不幸的情况是，当我们发现，在代码的调用树深处，以前从未需要挂起，我们引入了异步获取值的要求。那时我们正在调用 `A→B→C→D→E→F`；函数 F 必须获得新值。

因此我们必须更改 F 函数得签名，使其变为可恢复的。

不只是 E，而且每个调用 F 的函数都必须修改为可恢复的，并为 F 使用适当的调用。每个调用 E、D、C、B 或 A 的函数也是如此。

这需要对应该是本地的、增量维护的内容进行大规模、普遍的更改，这是所有无堆栈协程实现的弱点。这对开发人员来说已经够糟糕了——但对 QA 来说却是一场噩梦。

> 即无栈式的协程不具有很好的兼容性，以及具有传染性

### 有栈式挂起

有栈式协程通过向下传递控制来挂起。也就是说，它执行它认为是完全普通的函数调用。**它将挂起和恢复的实际机制委托给被调用函数**。这就是允许实现了有堆栈协程：调用者像任何普通的 C++ 函数一样编译，不知道在调用特定的其他函数期间可能会发生魔法。

上述这种”幸福的无知（blissful ignorance）“是具有传递性的。使用有栈式挂起，可能会挂起函数（caller function）的调用者同样不知道。它也是普通方式编译的。

确实，N3985 协程接受一个特殊的协程参数，该参数的方法执行实际的挂起和数据传递，并且该参数通常通过任何此类挂起所涉及的每个函数调用级别传递。

但是，将指向“当前”协程对象的指针存储在线程本地存储中是一个简短的步骤，无需显式传递它。另一个简短的步骤引入了一个用户态调度程序，同样可以通过线程本地指针找到。这样的调度程序可以拥有一组协程对象，识别“当前”对象并在就绪对象之间分派。

在任何一种情况下，都不需要以任何方式特别指定在堆栈协程上运行的函数。编译器不需要为函数体或其调用者生成特殊代码。它的签名不需要反映可能需要挂起。**在我们假设的大型代码库中，如果函数 F 需要引入新的异步调用，则 F 应该是唯一受影响的函数。**

### 有何不同

无堆栈式挂起（向上和向外）与堆栈式挂起（向下）的差异是它们的核心区别。我们还没有想好或听说过一种方式可以统一这两者之间的语义不同。

### 堆栈，进程或模拟

但在 D4134 和 N3985 之间有没有可能的中间地带？

在这里，我们从纯语义转向实现问题。

为了清楚起见，让我们将函数的“活动帧（activation frame）”称为查找其返回地址、参数值、局部变量和与当前活动调用有关的杂项的地方。通常活动帧位于处理器堆栈上。稍后会详细介绍

### N3985 协程

N3985 提出了堆栈式协程的库实现。这样的库必然依赖于整个程序的运行时堆栈实现。

典型的运行时堆栈实现需要一个足够大的连续内存区域来保存该堆栈上可能最深的调用链的活动帧。给定数据驱动的递归，这个大小一般来说，不能静态预测。一旦超出了堆栈空间，我们就进入了未定义行为的领域。最好的结果就是程序崩溃；这可以通过附加一个设置了权限以禁止任何访问的保护页面来强制执行。

超出保留堆栈空间的严重惩罚会导致保留较大的默认堆栈区域（即申请了过多了内存，从而导致内存浪费）。当然，现代操作系统可以根据需要将物理内存延迟提交给堆栈。但是，由于堆栈必须占用一个连续的地址范围，因此必须保留整个地址范围，即使它的物理提交的相对较少。

D4134 讨论了这对在 32 位地址空间中运行的高并发程序（大量不同的并发任务）造成的限制。用尽可用地址并不需要很多 1MB 的堆栈。

D4134 进一步指出，重写默认堆栈大小以指定小的连续堆栈需要编码人员做出通常她无法遵守的承诺。

最新版本的 GNU C++ 编译器引入了拆分堆栈（split stacks）的概念。这可以缓解问题，但可能仍然过于粗糙：D4134 提到该概念只是为了拒绝它。此外，Niklas 指出 Windows 内部验证明确禁止非连续处理器堆栈。



## 论文地址

https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2014/n4232.pdf