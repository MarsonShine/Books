# Stackful和Stackless协程的可恢复函数



## 背景

2014年6月在 Rapperswil，Nat Goodspeed 和 Oliver Kowalke 向 SG1 提出了在 C++ 中添加协程的提议。Niklas Gustafsson 提出了在 C++ 中添加可恢复函数的建议。SG1 指示我们将这些建议放在一个单一的概念空间中，以便尽可能统一它们。Nat、Oliver、Niklas 和 Torvald Riegel 在 Rapperswil 上详细讨论了这个概念空间。Nat 和 Gor Nishanov 在 Redmond 继续讨论。本文试图回应委员会的要求。

## 概述

### 协程

N3985 提出了一个 c++ 协程库。此可调用对象接受对额外的综合库的 `asymmetric_coroutine<T>::push_type` 的非常量引用；此 push_type 对象上的方法切换上下文并传输数据。（这个主题有一些变化，但就目前而言，这个案例就足够了。）

一个普通函数可以从函数体的中间返回一个值给它的调用者。

这些协程的另一个特点是调用者可以将控制权传递回函数体的中间，即它最后暂停执行的地方。

N3985 中提出的协程是有意 stackful 的。作者断言，这种协程的大部分价值在于它们的堆栈性质。

### 可恢复能力

N3858、N3977 和 D4134 提出了支持可恢复函数的新语言。不管编译器是否需要关键字来识别这样的函数，可恢复函数都是其特征是在其正文中至少存在一个“await”关键字。 （还有关于“yield”关键字的讨论，但目前我们只考虑“await”。）

可恢复函数返回一个潜在的值，一个在某来某个时刻返回给它的调用者。与期货一样，它在调用者接收到它的那一刻可能持有也可能不持有。称之为“returned”的future。（该提案还支持其他返回类型，但为简单起见，我们将讨论future。）

函数主体中的“return”语句用一个值填充返回到future，并退出函数。

函数体中的异常用异常填充返回给future。

函数主体中一个“await”表达式引入了对其它一些明确指定的future的依赖。这称之为“awaited” future。如果 awaited future 已经持有一个值了，“await”就会推送这个 awaited future 的值并延续函数体中后续的执行。但是如果这个 awaited future 仍在处理中，那么 “await” 会在 awaited future 获取值的一瞬间就会重新获取控制权。“await” 然后将一个待处理的future返回给它的调用者。在后续某个时间点 awaited future 将会填充这个值；这会导致可恢复函数在“await”暂停的地方重新进入。它将从那个地方开始，最终执行“return”语句或其它的”await“，又或是抛出异常。

尽管 N3858 考虑了可恢复函数的堆栈和无堆栈实现，但 D4134 的作者断言，可伸缩性的设计目标需要无堆栈实现。

### 挂起（suspension）

正如 Torvald 所指出的，N3985 协程和 D4134 可恢复程序的共同特征是挂起操作：控制可以以这样一种方式传递出函数体，以便以后可以在同一点恢复。

### 语义

到目前为止，大多数关于将协程与可恢复的想法统一起来的讨论已经很快的进入了实现领域。对于本文的大部分内容，我们努力保持在所需语义的范围内。在标准中有很多情况，不同的实现仍然可以产生相同的语义行为。在这里我们必须考虑语义本身是如何发散的（diverge）

```c++
// N3985 协程
typedef asymmetric_coroutine<int> coro_t;

void coro(coro_t::pull_type& source)
{
	before_suspend();
	source();
	int value = source.get()
	after_suspend();
}
```

```c++
// D4134 可恢复函数
future<int> somefunc();

future<int> resumable()
{
	before_suspend();
	int value = await somefunc();
	after_suspend();
	return value;
}
```

很明显，在进入时，`coro()` 和 `resumable()` 都会调用 `before_suspend()`。对 `source()` 的调用无条件地挂起 `coro()`；我们假设至少在某些情况下，`somefunc()` 需要等待一些外部资源，因此会暂停 `resumable()`。最后，在恢复时，`coro()` 和 `resumable()` 都会调用 `after_suspend()`。这些都是相似之处

关键的区别在于每个函数的挂起方式。

出于讨论的目的，让我们将函数调用链可视化为向下增长。也就是说，程序的 main() 堆栈帧位于顶部。main() 调用的函数 foo() 的堆栈帧低于 main 的；由 foo() 调用的函数 bar() 位于它们的下方。

```c++
int main()
{
	int n = 0;
	foo();
	return 0;
}

int foo()
{
	bar();
	return 0;
}

int bar()
{
	return 0;
}
```

### 无栈式挂起

#### 调用者责任

一个无堆栈的可恢复函数必须通过上下传递控制来挂起。也就是说，从根本上说，函数必须以某种方式将控制权返回给它的调用者。这不是实现细节；这是“无堆栈”的本质要求的。称其为对实现的约束。

这意味着调用者有义务区分普通返回（可用值）和暂停（还没有值）。考虑一系列可恢复函数：A → B → C。B 必须在这两种情况下表现非常不同。如果 C 正在暂停，B 也必须同样暂停；当 C 返回一个值时，B 可以继续执行它自己的主体。

有几种方法可以让可恢复的将这种区别传达给它的调用者。例如：

1. 可恢复函数可以通过抛出异常来挂起。调用者可以捕获它，更新自己的恢复信息并依次向调用者重新抛出异常。可恢复函数的正常返回意味着有值可用。这具有一定的直接吸引力，尽管可能会影响性能。
2. 可恢复函数可以返回一个可能包含也可能不包含值的类型，例如 `std::future`。现有技术使用了这种策略，一旦填充了 "awaited" future，就利用 `std::future::then()`将控制权传递回暂停的可恢复函数。
3. 可恢复函数可以接受一个非常量引用参数，通过该参数将区别传达给它的调用者。这与前面的非常相似，我们将把两者合并。
4. 可恢复函数可以设置全局状态——更确切的说，该状态在每个执行代理数据区域中。

要点是：不管实现细节如何，调用无堆栈可恢复函数的代码必须知道该函数可能返回值，也可能不返回值。（但是，已经返回的函数（例如`std::future`）可以透明地转换为可恢复函数或从可恢复函数转换：调用者不需要关心 future 是如何产生的。）

#### 维护影响

D4134 向我们保证，无堆栈式的可恢复函数可以不受限制地无缝调用现有代码、库和 OS API。

考虑一个大型的现有代码库。它的一部分使用可恢复的函数来管理异步 I/O；其他不需要挂起的部分是简单的 C++，写入同步返回值而不是 `std::futures`。

不幸的情况是，当我们发现，在代码的调用树深处，以前从未需要挂起，我们引入了异步获取值的要求。那时我们正在调用 `A→B→C→D→E→F`；函数 F 必须获得新值。

因此我们必须更改 F 函数得签名，使其变为可恢复的。

不只是 E，而且每个调用 F 的函数都必须修改为可恢复的，并为 F 使用适当的调用。每个调用 E、D、C、B 或 A 的函数也是如此。

这需要对应该是本地的、增量维护的内容进行大规模、普遍的更改，这是所有无堆栈协程实现的弱点。这对开发人员来说已经够糟糕了——但对 QA 来说却是一场噩梦。

> 即无栈式的协程不具有很好的兼容性，以及具有传染性

### 有栈式挂起

有栈式协程通过向下传递控制来挂起。也就是说，它执行它认为是完全普通的函数调用。**它将挂起和恢复的实际机制委托给被调用函数**。这就是允许实现了有堆栈协程：调用者像任何普通的 C++ 函数一样编译，不知道在调用特定的其他函数期间可能会发生魔法。

上述这种”幸福的无知（blissful ignorance）“是具有传递性的。使用有栈式挂起，可能会挂起函数（caller function）的调用者同样不知道。它也是普通方式编译的。

确实，N3985 协程接受一个特殊的协程参数，该参数的方法执行实际的挂起和数据传递，并且该参数通常通过任何此类挂起所涉及的每个函数调用级别传递。

但是，将指向“当前”协程对象的指针存储在线程本地存储中是一个简短的步骤，无需显式传递它。另一个简短的步骤引入了一个用户态调度程序，同样可以通过线程本地指针找到。这样的调度程序可以拥有一组协程对象，识别“当前”对象并在就绪对象之间分派。

在任何一种情况下，都不需要以任何方式特别指定在堆栈协程上运行的函数。编译器不需要为函数体或其调用者生成特殊代码。它的签名不需要反映可能需要挂起。**在我们假设的大型代码库中，如果函数 F 需要引入新的异步调用，则 F 应该是唯一受影响的函数。**

### 有何不同

无堆栈式挂起（向上和向外）与堆栈式挂起（向下）的差异是它们的核心区别。我们还没有想好或听说过一种方式可以统一这两者之间的语义不同。

### 堆栈，进程或模拟

但在 D4134 和 N3985 之间有没有可能的中间地带？

在这里，我们从纯语义转向实现问题。

为了清楚起见，让我们将函数的“活动帧（activation frame）”称为查找其返回地址、参数值、局部变量和与当前活动调用有关的杂项的地方。通常活动帧位于处理器堆栈上。稍后会详细介绍

### N3985 协程

N3985 提出了堆栈式协程的库实现。这样的库必然依赖于整个程序的运行时堆栈实现。

典型的运行时堆栈实现需要一个足够大的连续内存区域来保存该堆栈上可能最深的调用链的活动帧。给定数据驱动的递归，这个大小一般来说，不能静态预测。一旦超出了堆栈空间，我们就进入了未定义行为的领域。最好的结果就是程序崩溃；这可以通过附加一个设置了权限以禁止任何访问的保护页面来强制执行。

超出保留堆栈空间的严重惩罚会导致保留较大的默认堆栈区域（即申请了过多了内存，从而导致内存浪费）。当然，现代操作系统可以根据需要将物理内存延迟提交给堆栈。但是，由于堆栈必须占用一个连续的地址范围，因此必须保留整个地址范围，即使它的物理提交的相对较少。

D4134 讨论了这对在 32 位地址空间中运行的高并发程序（大量不同的并发任务）造成的限制。用尽可用地址并不需要很多 1MB 的堆栈。

D4134 进一步指出，重写默认堆栈大小以指定小的连续堆栈需要编码人员做出通常她无法遵守的承诺。

最新版本的 GNU C++ 编译器引入了拆分堆栈（split stacks）的概念。这可以缓解问题，但可能仍然过于粗糙：D4134 提到该概念只是为了拒绝它。此外，Niklas 指出 Windows 内部验证明确禁止非连续处理器堆栈。

事实上，Gor 断言虚拟地址消耗问题是堆栈协程的主要障碍。虽然承认在某些方面它们比无堆栈协程更强大和更灵活，但他对可扩展性要求感到遗憾，这使得它们无法在 32 位服务器上使用。

### D4134 可恢复函数

使用 D4134 可恢复函数，**暂停函数调用的嵌套链在概念上类似于分配在堆或特定内存池中的各个活动帧的链表。这样每个帧的大小都是最小的。而不是 4Kb 页面，每个可恢复函数在进入时为其自己的活动帧准确分配所需的帧。这个帧是可恢复函数在暂停和恢复之间的唯一开销——这就是高可伸缩性的来源**。

无堆栈可恢复函数在挂起时不消耗处理器堆栈，因为挂起涉及返回到其调用者。这满足了关于连续处理器堆栈的 Windows 约束：堆栈帧的链表与处理器堆栈不同。

当 D4134 可恢复函数被恢复时（例如，通过一个 waited future 的 then() 方法），它会在顶部重新进入。这将创建一个新的处理器堆栈条目。生成的逻辑在其小的活动帧中询问函数的状态，并分派到函数体内的适当恢复点。从那里开始，每条代码路径都会导致函数以一种或另一种方式退出——再次删除其处理器堆栈条目。

当函数最终返回结果时，该结果将用于填充其返回的 future。填充其返回的 future 可能会将控制权传递给另一个挂起的可恢复函数——它的原始调用者——它会被恢复。

这种策略模拟处理器堆栈的行为，同时避免处理器堆栈上的持久条目。

## 想法实验

在这个领域，编译器是公平的游戏：我们不受库实现的限制。如果编译器被指示通过构造一个活动帧的链表来实现普通函数调用和返回，从而最小化处理器堆栈的使用呢？

每个函数在进入时都会在堆上分配自己的活动帧。（D4134 讨论了在这些问题上自定义编译器选择的策略，例如用于堆栈帧的特定分配器。）从调用者已经构建的处理器堆栈条目中，函数 prolog 会将关键项弹出到新的活动帧中，特别是它的返回地址和参数必须在调用不透明函数时保持不变。在函数 prolog 结束时，处理器堆栈指针将恢复为其调用者的值。

从这样的函数返回将从堆活动帧中获取返回地址，释放该帧并跳转回调用者。

此外，这样的函数可以调用暂停操作，该操作仅通过在返回之前交换帧指针来恢复一些其他的活动帧链。

根据 D4134，以这种方式编译的函数可以很容易地调用现有的库代码或 OS API；它们会像往常一样消耗处理器堆栈——像往常一样在返回调用函数时删除。

编译器可以被指示以这种方式编译整个转换单元（translation unit），或者可以接受 #pragma 指令，遵循现有的先例。

无知的想象（ignorant imagination）表明，以这种方式编译的函数可能比 D4134 中提出的调度策略更简单，甚至可能更有效。它可以使用 “stackful” 范式，即通过对不那么普通的函数进行普通函数调用——而不是安排两种不同的返回方式。恢复不需要分派到函数体中的适当位置；被调用的函数只会返回到正确的位置。

尽管如此，这种“堆栈”功能仍将使用堆分配的最小尺寸活动帧来实现可扩展性，如 D4134 中那样。参与函数不需要特殊签名、特殊调用代码或特殊源注释，从而减轻了维护负担。

有人可能会问：调用 A → B 编译成现在，然后 B 调用 C → D 编译成活动帧链，然后 D 调用 E → F 编译成现在，然后 F 调用 G → H 编译成活动帧链，会有什么效果？帧？关于挂起函数 H，我们会怎么说？

显然 A、B、E 和 F 像往常一样消耗处理器堆栈。我们要求整个调用链 A → B → C → D → E → F → G → H 在语义上与所有都编译为现在的情况无法区分——暂停除外。

我们期望驻留在处理器堆栈上的最低级别的活动帧（在本例中为 F's）定义了一个边界，在该边界之下，独立的链接激活帧协程（linked-activation-frame coroutine）可以协作共享相同的内核线程。在此示例中，我们将忽略 C 和 D 已针对链接的活动帧进行编译的事实：E 和 F 的处理器堆栈帧呈现没有实际意义。

以这种方式引入调试模式诊断以捕获处理器堆栈的无意“锚定（anchoring）”似乎完全合理。

## 总结

D4134 使用编译器支持来生成无堆栈协程。这保证了高可扩展性，但代价是普遍的标记：将代码移植到该环境的大量开销。

N3985 提出了一个堆栈协程的库实现。这保证了更早的可用性（现已发布的实现可用！）加上更容易的维护负担 - 以每个任务的大保留地址范围为代价，限制了可扩展性。

似乎编译器对“堆栈式”协程的支持可以提供这两种方法的好处，利用 D4134 的原型技术。这本身并不是一个提案，只是一个在承诺现有提案之前探索该设计空间的建议。

## 论文地址

https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2014/n4232.pdf