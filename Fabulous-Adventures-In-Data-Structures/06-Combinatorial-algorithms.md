# 组合算法

本章内容包括

- 生成两个、三个或任意多个序列的笛卡尔积
- 生成一个序列的所有排列（重新排序方式）
- 生成一个序列的所有组合（子序列）
- 这三种组合运算与“把整数分解为若干整数之和”的各种方式之间的深层联系

组合学如今是一个非常宽泛的数学领域，从图论到优化理论都涵盖在内，但贯穿其中的共同主题是：我们关心的是用算法来解决涉及有限个离散元素的问题，比如长度为 n 的整数序列。在本章中，我们将讨论对序列进行的三种基本组合运算。

- 笛卡尔积接受两个序列，并产生由这两个序列中的元素所组成的所有对。随后我们会把这个运算扩展到处理多个序列，最后给出一个能够处理任意多个序列的笛卡尔积的简洁表达。
- 一个序列的排列，是该序列中所有元素的所有可能重排。我们会考察几种不同技巧实现的排列生成算法，其中有些算法可以追溯到几个世纪前，并且具有非常优雅的性质。
- 一个序列的组合，是所有可能的“不改变原有顺序”的子序列。我们会看一些生成组合的算法。
- 这些运算的输出都是“序列的序列”，因此我们自然会问一个问题：“给定一个整数 p，输出中的第 p 个序列是什么？”回答这个问题可让我们对“如何把整数分解为若干较小整数之和”获得一些洞见。

现代编程语言通常都自带用于操作序列的标准库。.NET 有一整套序列操作符：`Aggregate`、`Where`、`Select`、`Join`、`Max`，等等。我一直觉得有点奇怪的是，基础类库并没有附带生成一个序列所有排列或组合的算法。每当我需要它们时——通常是为了快速生成测试用例——我都得自己写。既然这些算法简单、优雅、经典而永不过时，而且我从中学到了很多并且乐在实现它们，我大概应该感谢它们并不是现成给我准备好的。解决这些实际问题的过程中，我们还能顺带获得对整数结构的洞见，这是一路上得到的额外收获；那就让我们来探索一下吧！

## 笛卡尔积

假设你在写一个游戏，其中有一组角色、一组武器：

```csharp
HashSet<CharacterClass> cs =
    [new Wizard(), new Warrior(), new Thief()];
HashSet<Weapon> ws =
    [new Longsword(), new Wand(), new Dagger()];
```

在这类对象模型中，通常会有一个方法，用来判断某个玩家是否允许使用某件武器。如果我们想生成一份报告，说明谁能用什么武器，当然可以搬出那匹老战马——嵌套循环：

```csharp
var sb = new StringBuilder();
foreach(var c in cs)
    foreach(var w in ws)
        sb.AppendLine($"{c.Name} {w.Name} {c.CanWield(w)}");
var s = sb.ToString();
```

这样写当然没问题，但它会让代码看起来像是“这段代码的目的就是跑一堆循环”；它强调的是机制，而不是意义。有些语言在语言或运行时层面内置了序列操作；在这些语言中，我经常更愿意用查询表达式，把“怎么展开为循环”的工作交给编译器和运行库。（如果你对 C# 中的查询表达式不熟，可以参考附录 A 的快速入门。）

```csharp
var q = from c in cs
        from w in ws
        select $"{c.Name} {w.Name} {c.CanWield(w)}";
var s = string.Join("\n", q);
```

不管我们用哪种写法，最后得到的字符串看起来大致是这样的：

```
Wizard Longsword False
Wizard Dagger True
Wizard Wand True
Warrior Longsword True
Warrior Dagger True
Warrior Wand False
Thief Longsword False
Thief Dagger True
Thief Wand False
```

无论我们是使用多个 `foreach` 语句还是多个 `from` 子句，本质上都是在遍历这两个集合的笛卡尔积。对于任意两个集合，记为 A 和 B，笛卡尔积就是：所有可能的元素对构成的集合，其中对中第一个元素来自集合 A，第二个元素来自集合 B。

数学家把它记作 A×B，读作“A 叉 B”。如果你懂一点 SQL，你会认出这个运算就是两个表的 `CROSS JOIN`。

> **小趣闻**
> 笛卡尔积以数学家 René Descartes（笛卡尔）的名字命名——就是那个“我思故我在”的人。

下面我们来看几种计算笛卡尔积的方法。一开始，我们把自己限制在两个或三个集合（或序列）上的实现。然后我们再来看一个更难的问题：如何计算任意多个序列的笛卡尔积？

### 少量集合或序列的笛卡尔积

.NET 类库中的 `HashSet<T>` 类实现了集合上你所期望的基本操作，比如交集和并集。出乎意料的是，它并没有实现笛卡尔积；幸运的是，我们可以很快地添加一个扩展方法来实现它。我们这样定义两个集合的笛卡尔积：由这两个集合中元素组成的所有二元组的集合：

代码清单 6.1 两个集合的笛卡尔积

```csharp
static class Extensions
{
    public static HashSet<(A a, B b)> CartesianProduct<A, B>(
        this HashSet<A> hsa, HashSet<B> hsb)
    {
        var result = new HashSet<(A a, B b)>();
        foreach (var a in hsa)
            foreach (var b in hsb)
                result.Add((a, b));
        return result;
    }
}
```

这是一个简短而漂亮的方法。此时你可能会好奇：如果我们再用一次这个方便的扩展方法，取三个集合的笛卡尔积，会发生什么？

```csharp
HashSet<Monster> ms =
    [new Vampire(), new Werewolf()];
foreach(var t in cs.CartesianProduct(ws).CartesianProduct(ms))
    Console.WriteLine($"{t.a.a} {t.a.b} {t.b}");
```

它会产生我们期望的输出：

```
Wizard Longsword Vampire
Wizard Longsword Werewolf
Wizard Wand Vampire
 … 依此类推
```

……但是，最后那行代码可不太好读。发生了什么？

- 第一次取积时，产生的是 `(CharacterClass a, Weapon b)` 这样的元组。
- 第二次取积时，产生的是 `((CharacterClass a, Weapon b) a, Monster b)` 这样的嵌套元组。

我们大概更希望得到的是三元组，而不是嵌套的二元组。没问题！只要再给 `Extensions` 类加一个扩展方法就行了：

代码清单 6.2 三个集合的笛卡尔积

```csharp
public static HashSet<(A a, B b, C c )> CartesianProduct<A, B,
    C>(
    this HashSet<A> hsa, HashSet<B> hsb, HashSet<C> hsc)
{
    var result = new HashSet<(A a, B b, C c)>();
    foreach (var a in hsa)
        foreach (var b in hsb)
            foreach (var c in hsc)
                result.Add((a, b, c));
    return result;
}
```

这样一来，上面的示例代码就稍微更易读一些了：

```csharp
foreach (var t in cs.CartesianProduct(ws, ms))
    Console.WriteLine($"{t.a} {t.b} {t.c}");
```

我们可以继续添加任意多的扩展方法来构造四个、五个或更多集合的笛卡尔积；我就不在这里赘述这一点了，我们会在本章后面回到“通用问题”的解决方案。

你大概已经注意到了，`CartesianProduct` 方法的签名其实比必要的更受限制。笛卡尔积是对集合的数学运算，但要把它推广到任意两个序列的笛卡尔积，其实一点也不牵强；为什么只限制在集合上呢？序列可以包含重复元素，而集合不能，但这不是什么强有力的反对理由。如果我们愿意接受序列中有重复元素，那么很可能也能接受两个序列笛卡尔积的结果中有重复。我们只需对“集合版本”的代码做一点小改动，再添加一个扩展方法：

代码清单 6.3 两个序列的笛卡尔积

```csharp
public static IEnumerable<(A a, B b)> CartesianProduct<A, B>(
    this IEnumerable<A> seqa, IEnumerable<B> seqb)
{
    foreach (var a in seqa)
        foreach (var b in seqb)
            yield return (a, b);
}
```

现在，这个方法可以用于任何一对序列，而不仅限于一对集合。我们在这里做的，真的只是把“嵌套 `foreach` 循环”的概念抽象成了一个单独的方法而已，但这完全没有问题。其它简单的序列扩展方法，比如 `Where` 和 `Select`，同样是对简单循环的抽象；它们的用处在于让代码更像是“对序列进行操作”，而不是强调“循环机制本身”。

这个更通用版本的 `CartesianProduct` 还是惰性的；先前那个利用哈希集合构建结果的版本则是急切的。也就是说，惰性版本在集合被遍历之前不会构造任何元组；原先的版本则会急切地把所有元组都构造出来，并放进哈希集合。如果笛卡尔积的结果集合非常大，而你并不需要一次性拿到全部结果，那么用惰性方式构造序列可能会更好。

我们能不能把这个方法做得“更好用”一些？目前为止，这些方法都返回元组，这多少有点烦人。多数时候，我们是想“对这对值做点事情”，而元组本身只是一个并不特别方便的容器而已。我们可以再写一个扩展方法，接受一个函数来解决这个问题：

代码清单 6.4 内置了 Select 的笛卡尔积

```csharp
public static IEnumerable<R> CartesianProduct<A, B, R>(
    this IEnumerable<A> seqa,
    IEnumerable<B> seqb,
    Func<A, B, R> projection)
{
    foreach (var a in seqa)
        foreach (var b in seqb)
            yield return projection(a, b);
}
```

本质上，我们在这里做的就是把 `CartesianProduct` 和 `Select` 这两个操作合并到一个小方法中。我还要再添加一个用来显示字符串序列的“流式风格”辅助扩展方法：

```csharp
public static string Newlines<T>(this IEnumerable<T> seq) =>
    string.Join("\n", seq);
```

于是我们就可以用一种流式风格重写最初的报表代码：

```csharp
string s = cs.CartesianProduct(ws,
               (c, w) => $"{c.Name} {w.Name} {c.CanWield(w)}")
             .Newlines();
Console.WriteLine(s);
```

……再次得到我们期望的输出：

```
Wizard Longsword False
Wizard Wand True
Wizard Dagger True
… 依此类推
```

我们还可以写一个接受三个序列和一个函数的扩展方法、再写一个接受四个序列和一个函数的扩展方法，等等，想写多少个都可以。但是，如果事先并不知道自己到底有多少个序列呢？我们还能否构造一个笛卡尔积，生成“每个序列取一个元素”的所有可能组合呢？

### 任意多个序列的笛卡尔积

对我来说，解决类似“如何对任意多个序列取笛卡尔积？”这类问题的第一步，就是先想一想方法的签名应该长什么样。我们已经知道：

- 传入的是任意多个序列。这暗示我们应该接收一个“序列的序列”。
- 我们要从每个序列中取出一个元素，但在运行时之前并不知道有多少个序列，所以结果类型如果是“元组的序列”就行不通了；元组的大小在编译时就得确定。
- 我们可以把从每个序列里抽出来的元素，装进一个单独的序列当作结果，而不是装进一个元组。
- 这就意味着，输出序列中的各个元素都应该是同一种类型。
- 进一步，这也意味着所有输入序列中的元素也都应是同一种类型。

把这些信息组合在一起，我们的扩展方法签名就应该是：

```csharp
public static IEnumerable<IEnumerable<T>> CartesianProduct<T>(
    this IEnumerable<IEnumerable<T>> sequences)
```

下一步就是考虑边界情况。如果我们传入的是一个空的“序列的序列”怎么办？如果传入的是只包含一个序列的“序列的序列”呢？我们可以从一般情况类推出这些特殊情况：

- 如果我们对两个序列取笛卡尔积，应该得到一个“由二元序列组成的序列”。
- 如果我们对三个序列取笛卡尔积，应该得到“由三元序列组成的序列”。
- 依此类推：如果我们对 n 个序列取笛卡尔积，应该得到“由 n 元序列组成的序列”。

这就回答了边界情况的问题：

- 如果一开始我们给的是 0 个序列，那就应该生成一个只包含一个“零元素序列”的序列：`[ [ ] ]`
- 如果一开始给的是一个序列，比如 `[[1, 2, 3]]`，那结果就应该是“由一元序列组成的序列”：`[[1], [2], [3]]`。

这帮助我们很好地理解了结果的“形状”，但要如何真正解决这个问题呢？我们先走一遍具体示例，来摸清自己到底要做什么。假设我们有三个整数序列 `[[1, 2, 3], [4, 5, 6], [7, 8]]`，我们想要它们的笛卡尔积，也就是：`[[1, 4, 7], [1, 4, 8], [1, 5, 7], …]`。

下面是一种算法，它一次处理一个序列，把结果“搭积木”式地构建出来：

- 我们从“0 个序列的笛卡尔积”开始，而刚才我们已经决定了，它就是“一个零元素序列构成的序列”：`[ [ ] ]`。
- 接着，我们对空序列 `[]` 做三份拷贝，再分别把 `[1, 2, 3]` 中的每个元素追加到这三份拷贝后面，得到 `[[1], [2], [3]]`。
- 然后，我们对 `[1]、[2]、[3]` 这三个序列分别做三份拷贝，再分别把 `[4, 5, 6]` 中的每个元素追加上去，得到 `[[1, 4], [1, 5], [1, 6], [2, 4], [2, 5], [2, 6], [3, 4], [3, 5], [3, 6]]`。
- 接下来，我们再对这些序列各做两份拷贝，把 `[7, 8]` 中的每个元素追加上去，就得到 `[[1, 4, 7], [1, 4, 8], [1, 5, 7], [1, 5, 8] … 以此类推]`。

当然，我们并不是真的想“拷贝”任何东西；那样拷贝量会非常可怕。我们需要的是一种方法，能够在不修改原序列的前提下，把一个元素追加到已有序列的右侧。幸运的是，这段代码我们已经写过了；这正是不可变双端队列（immutable deque）的 `PushRight()` 操作！到这里，我们已经对这个问题有了足够的理解，可以写出代码了：

代码清单 6.5 基于 LINQ 的任意笛卡尔积实现

```csharp
public static IEnumerable<IEnumerable<T>> CartesianProduct<T>(
    this IEnumerable<IEnumerable<T>> sequences)
{
    IEnumerable<IDeque<T>> result = [Deque<T>.Empty];
    foreach (var sequence in sequences)
        result = from deque in result
                 from item in sequence
                 select deque.PushRight(item);
    return result;
}
```

> 注意
> 这个解法强调了一个关于查询表达式的重要事实，我之前说过一次，这里再强调一遍：**查询表达式创建的是“表示查询的对象”，而不是执行查询本身。** 查询是在这个对象被枚举（迭代）时才真正执行的。

假设 `sequences` 有 n 个元素。我们先在 `result` 中放入“0 个序列的笛卡尔积”，然后循环 n 次，每次都创建一个查询，把当前序列的元素追加到 `result` 里的各个序列后面，如此反复，直到处理完所有序列。注意：这里我们实际上得到了“嵌套深度为 n 的查询对象”。它有一个很好的一面：完全惰性；由于这些嵌套查询只是构建出来而不会立即执行，**构建整个查询的时间复杂度是 O(n)**。

这段代码已经相当清晰了，但如果能把循环再挪到辅助方法里，我总是乐意这么做。我们快速看一下另一种写法：它没有显式的循环——或者说，把循环隐藏在别处。这里我们用的是“聚合（aggregation）”模式：

- 声明一个累加器 `result`，并给它一个初始值
- 对集合中的每个元素，根据累加器当前值和该元素来更新累加器
- 最后返回累加器

基础类库提供了一个扩展方法 `Aggregate`，它接受累加器的初始值和一个更新累加器的 lambda。如果我们愿意，可以把上面的代码重写成一行对这个辅助方法的调用：

代码清单 6.6 使用 Aggregate 隐藏最后一个循环

```csharp
public static IEnumerable<IEnumerable<T>> CartesianProduct<T>
    (this IEnumerable<IEnumerable<T>> sequences) =>
    sequences.Aggregate(
        (IEnumerable<IDeque<T>>) [Deque<T>.Empty], #A
        (accumulator, sequence) =>
            from deque in accumulator
            from item in sequence
            select deque.PushRight(item));
```

这个“无显式循环”的版本做的工作和前一个版本完全一样：构造一个嵌套深度为 n 的查询对象并返回它。你更喜欢哪一种写法，完全是风格问题。

我们来看一个小例子。首先，我再加一个小小的辅助扩展方法，让代码写起来更流畅一些：

```csharp
public static string Concat<T>(this IEnumerable<T> items) =>
    string.Join("", items);
```

现在我们就可以演示“任意多个序列的笛卡尔积”了。`string` 本身是一个 `char` 的序列，而字符串列表就是“字符序列的序列”，因此我们可以对这个“序列的序列”取笛卡尔积：

```csharp
List<string> items = ["ABC", "DEF", "GH"];
foreach (var seq in items.CartesianProduct())
    Console.Write(seq.Concat() + " ");
```

正如所料，我们得到 18 个长度为 3 的字符序列，其中第一个字符来自第一个序列，以此类推：

```
ADG ADH AEG AEH AFG AFH BDG BDH BEG BEH BFG BFH CDG CDH CEG CEH CFG CFH
```

这个算法的性能如何？像很多涉及查询表达式的情况一样，并不一眼就能看清。构造一个“表示查询的对象”本身在时间上是 O(1) 的；给定 n 个序列，这个算法循环 n 次，生成一个嵌套深度为 n 的查询对象，所以**初始化调用在时间和空间上都是 O(n)**。那这个查询对象每次迭代的成本是多少呢？当查询被枚举时，它会生成一个包含 n 个元素的 deque，而我们知道向 deque 中推入元素的摊还成本是 O(1)，因此“每生成一个序列”的成本也是 O(n)。

这个算法还有一个很好的性质：**如果输入的各个序列本身是排序好的，那么输出序列会按字典序（lexicographic order）生成**——也就是它们在字典中出现的顺序。这个事实自然引出了另外一个洞见：当我们在对“排好序的数值序列”取笛卡尔积时，可以从中看到什么样的结构特性。

### 与整数的联系

当然，你已经知道我们是如何用十进制来表示正整数的，不过我们还是快速回顾一下。如果有一个介于 0 和 10ⁿ-1 之间的数 p，就可以用 n 位十进制数字来表示它。比如，当 n 为 4 时，你可以把任意介于 0 和 9999 之间的 p 表示成一个四位数 ABCD，并满足

$p = A×10³ + B×10² + C×10¹ + D×10⁰$

当我们使用十进制表示时，本质上是在把任意介于 0 和 10ⁿ-1 之间的整数 p 分解成 n 个数，这 n 个数的和为 p。我们也可以从笛卡尔积的角度来看这件事。如果把序列 `[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]` 与自身做 n 次笛卡尔积，就能按字典序生成所有 n 位数字序列。

例如，当 n 为 4 时，我们会生成数字序列 0000、0001、0002，依此类推直到 9999。每个序列显然都对应着 0 到 9999 之间的一个数；一串数字本身就是我们表示数的方式。

对于 10 以外的进制，这也同样成立；我们同样可以生成所有 n 位十六进制数、八进制数、二进制数等等。将“一个序列与自身做笛卡尔积”得到的序列，与“某个进位制中的数字序列”之间，有一种非常自然的联系。这也许看上去显而易见到几乎不值得一提，但在接下来讨论排列和组合时，我们会看到：拆分整数还有一些更“异想天开”但同样合法的方法。

当你有多个相互独立的事物序列并想要探索所有可能的成对、成三元组的组合时，笛卡尔积非常方便。而另一个不同的问题是：**如何探索一个单独序列的所有重排方式**。让我们先告别笛卡尔积，转向下一个组合运算：排列。

## 排列

一个*排列*就是一个有限序列的一种*重新排列*。我使用排列最多的场景是生成测试用例；比如，一个对象有 “open”（打开）、“read”（读取）、“write”（写入）、“close”（关闭）这些操作，那就很有必要验证：在这些操作的所有可能顺序下，对象都能正确工作。可能的排列数量会非常多，但即使没法检查完所有情况，能够生成若干不同的执行顺序用于自动化测试仍然是很有用的。

另一个常见用例是“洗牌”；当你洗一副牌时，你是在对这副牌的序列生成一个新的排列，因此如果我们能生成一个随机排列，就能对任意序列进行“洗牌”。或者，我们也可能想给一组歌曲做重排；对序列进行重排有着广泛的应用场景。

可以想象，一个元素各不相同的序列，它的排列数量增长得非常快。假设我们限制自己只看 0 到 n-1 的 n 个互不相同的整数构成的序列，并开始列出它的所有排列。

> **注意**
> 在本节以及下一节（组合）中，会写出许多序列。为了简洁，当上下文已经很清楚我在谈的是一个序列时，我会有时候省略括号和逗号。例如，我可能写 CADB 来代替 `[C, A, D, B]`，或者写 `[012, 021, 102]` 来代替 `[[0, 1, 2], [0, 2, 1], [1, 0, 2]]`。

- 对于只有一个元素的序列，只有一种排列：`[0]`
- 对于两个元素的序列，有两种排列：`[01, 10]`
- 再往上是 6 种：`[012, 021, 102, 120, 201, 210]`
- 然后是 24 种：`[0123, 0132, …, 3210]`
- 再往上是 120 种：`[01234, 01243, …, 43210]`

当对一个含有 n 个元素的序列做排列时，我们可以任选 n 个元素中的任意一个作为第一个，再从剩下的 (n-1) 个元素中任选一个作第二个，再从剩下的 (n-2) 个元素中任选一个作第三个，以此类推。把所有可能性相乘，就得到 n 的阶乘；我们记作 n!。它增长极快；O(n!) 比指数增长还要糟。

在本节中，我们会看几种不同的算法，用来生成所有可能的排列。由于当 n 稍微大一点时，生成所有 n! 种排列会非常不方便，我们还会研究一些算法，用来在 0 到 n!-1 之间，给定任意一个“排列编号” p 时，直接生成对应的第 p 个排列，以及生成随机排列的算法。

如果一个 n 元序列中没有重复元素，那么只要能对序列 `0, 1, …, n-1` 做排列，就能通过某种排列方式重排任意一个无重复的原序列。下面是一个很方便的扩展方法：它接受任意类型的长度为 n 的列表、以及一个 0 到 n-1 的排列，返回一个新的列表，其中元素顺序是原列表按该排列重排后的结果。原始列表不会被修改：

代码清单 6.7 将一个排列应用到任意类型的列表上

```csharp
static class Extensions
{
    public static IList<T> Permute<T>(
        this IList<T> items, IList<int> permutation)
    {
        var result = new T[items.Count]; #A
        for(int i = 0; i < items.Count; i += 1)
            result[i] = items[permutation[i]];
        return result;
    }
}
```

我再添加一个小小的“流式风格”辅助扩展方法，用在示例中：

```csharp
public static string Space<T>(this
    IEnumerable<T> items) =>
    string.Join(" ", items);
```

如果我们有一个已经按排序顺序排列好的五个字符串的列表，以及排列 `[1, 0, 2, 4, 3]`，就可以生成一份重排后的副本：

```csharp
List<string> animals = ["cat", "dog", "elk", "fox", "hog"];
Console.WriteLine(animals.Permute([1, 0, 2, 4, 3]).Space());
```

……它会产生这样的输出：

```
dog cat elk hog fox
```

由于对 `0` 到 `n-1` 的排列足以重排任意一个“无重复元素”的列表，因此在本章中那些假设“无重复元素”的算法中，我们只需要考虑如何对这一串数字本身做排列。

排列一个序列的算法有非常多。接下来我们来看三个我最喜欢的算法：**字典序排列**、**Fischer–Yates 洗牌算法**，以及一个颇为有趣的传统“敲钟换序（change ringing）”系统。

### 字典序排列

我们要介绍的第一个算法非常古老；大概在 700 年前，由印度数学家 Narayana Pandita 发现。假设我们有字母序列 ACOST，以及两个排列，比如 COATS 和 TACOS。我们说 COATS 比 TACOS 更“小”，因为 COATS 在字典中会排在前面；这就是一种“字典序（lexicographic）”排序方式。

Pandita 的算法接受一个*已有某种排列结果* 的可变数组作为输入，通过“修改该数组”来生成“下一种字典序排列”。数组中允许出现重复元素，因此如果你要对包含重复元素的序列做排列，这是一个非常好的算法。我们会先通过一个例子看看它是如何工作的，然后再写出代码。

问题是：在 ACOST 的所有排列中，紧跟在 COATS 后面的字典序排列是什么？算法步骤如下：

1. 找到最右边的、且“左边紧挨着一个更大的元素”的那个元素。（如果不存在这样的元素，说明序列已经是逆序排列，不再有更大的排列。）在 COATS 中，S 和 T 的右边都没有更大的字母，而 A 的右边紧挨着更大的字母。
2. 找到右侧所有元素中“最右边的、且比第 1 步找到的元素大的那个元素”。（如果第一步成功，那这一项必然存在。）
    在 COATS 中，S 是序列中最右边的、且比 A 大的字母。交换这两个元素。现在我们得到的是 COSTA。
3. 将第 2 步中那个元素（交换后）所在位置右边的子序列做“反转”。
4. 我们刚才把 S 换了进来，所以要把 COSTA 中的 TA 反转成 AT，得到 COSAT。这就是 COATS 的下一个字典序排列。

你可以试着在脑海中对 COSAT 继续运行这套算法，生成接下来的几种排列（COSTA、COTAS、COTSA……）。有点感觉了吗？那我们开始写代码。

在这个算法中，我们会对可变序列做三件事：判断一个元素是否大于另一个元素、交换两个元素、以及反转一段连续元素。我会为这三件事分别写扩展方法。只要能让代码更好读、更易推理，就没有“小到不配做成辅助方法”的操作！

代码清单 6.8 Pandita 的字典序排列算法

```csharp
static class Extensions
{
    public static bool Greater<T>(this IList<T> items, int x,
        int y)
        where T : IComparable<T> =>
        items[x].CompareTo(items[y]) > 0;

    public static void Swap<T>(this IList<T> items, int x, int
        y) =>
        (items[x], items[y]) = (items[y], items[x]); #A

    public static void ReverseRange<T>(
        this IList<T> items, int start, int end)
    {
        for (; start < end; start +=1, end -=1) #B
            items.Swap(start, end);
    }

    public static bool NextLexiPermutation<T>(this IList<T>
        items)
        where T : IComparable<T>
    {
        int first = items.Count - 2;
        while (first >= 0 && !items.Greater(first + 1, first))
            first -= 1;
        if (first < 0)
            return false; #C
        int second = items.Count - 1;
        while (!items.Greater(second, first)) #D
            second -= 1;
        items.Swap(first, second);
        items.ReverseRange(first + 1, items.Count - 1);
        return true;
    }
}
```

如果你想生成一个列表的所有排列，就把它按字母顺序排好，然后不断调用 `NextLexiPermutation`，直到它返回 `false` 为止。我们来用一个带有重复元素的示例试试，看看它如何工作：

```csharp
List<char> list = ['A', 'B', 'B', 'E', 'Y'];
do
    Console.Write(list.Concat() + " ");
while (list.NextLexiPermutation());
```

这会生成 ABBEY（“修道院”）一词的所有字典序排列：

```
ABBEY ABBYE ABEBY ABEYB ABYBE ABYEB AEBBY AEBYB AEYBB AYBBE
AYBEB AYEBB
BABEY BABYE BAEBY BAEYB BAYBE BAYEB BBAEY BBAYE BBEAY BBEYA
BBYAE BBYEA
BEABY BEAYB BEBAY BEBYA BEYAB BEYBA BYABE BYAEB BYBAE BYBEA
BYEAB BYEBA
EABBY EABYB EAYBB EBABY EBAYB EBBAY EBBYA EBYAB EBYBA EYABB
EYBAB EYBBA
YABBE YABEB YAEBB YBABE YBAEB YBBAE YBBEA YBEAB YBEBA YEABB
YEBAB YEBBA
```

这个算法的性能如何？空间方面是 O(1)；我们是在原地修改列表。算法在循环内部所做的只有比较和交换，因此如果我们能数清比较和交换的次数，就能大致估计它的时间性能。

最坏情况其实不难找。如果 n 为 7，而我们要找 FGEDCBA 的下一种排列，那么要确定 “F 是唯一一个‘右边紧挨着更大元素’的元素”，需要做 n-2 次比较；随后要确定 “G 是需要和 F 交换的元素”，则需要再做 n-1 次比较。我们必须交换 F 和 G，然后反转列表剩余部分，这需要 1 + n/2 次交换。因此，在最坏情况下，比较和交换的次数都可能是 O(n) 级别。

不过，那只是最坏情况；平均情况如何呢？如果我们在为一个包含互不相同元素的列表生成所有排列——一共有 n! 种——那么在其中 50% 的排列中，最后两个元素已经是升序的。在这种最常见的情况里，我们只做两次比较和一次交换。这是数量极其庞大、但又非常廉价的调用。与之对比，那极少数的“最昂贵调用”数量极小；在 n! 种排列中只有一种是最坏情况。

这种状况跟我们之前实现的不可变 deque 很相似：如果最坏情况极其罕见，而绝大多数情况都是非常廉价的，那么摊还成本就会变得很低。如果你把整个数学推导做一遍，会发现这个算法平均每生成一个排列只做 3 次比较和 1.5 次交换。该算法的 *摊还时间复杂度* 是 O(1)，而在序列规模 n 的意义上，最坏情况是 O(n)。

既然我们可以按字典序列出一个长度为 n 的序列的全部 n! 个排列，就可以为每个排列指定一个 0 到 n!-1 之间的“排列编号”。理想中，我们应该有一个方法，它接受序列长度 n 和排列编号 p，返回对应的排列。为了实现这个算法，我们会做两个假设：要排列的序列是 0 到 n-1 的互不相同的整数，并且 p 在 0 到 n!-1 之间。

例如，当 n=4 时，按字典序排列的所有排列及其排列编号是：

```
0:0123  1:0132  2:0213  3:0231  4:0312  5:0321
6:1023  7:1032  8:1203  9:1230  10:1302 11:1320
12:2013 13:2031 14:2103 15:2130 16:2301 17:2310
18:3012 19:3021 20:3102 21:3120 22:3201 23:3210
```

我们希望能够：给定排列编号 0，就返回 0123；给定排列编号 3，就返回 0231，而无需从头开始依次计算每一个排列。应该怎么做呢？一个“视觉辅助”会很有帮助。

长度为 n 的序列有 n! 种排列，这意味着我们可以把它们排成一个有 n 行、(n-1)! 列的表格。例如，我们可以把 0123 的 24 个排列排成一个 4 行 6 列的表：

表 6.1 n 个元素的所有排列

​         0          1          2           3         4          5
 0   0123   0132   0213   0231   0312   0321
 1   1023   1032   1203   1230   1302   1320
 2   2013   2031   2103   2130   2301   2310
 3   3012   3021   3102   3120   3201   3210

第 0 行是所有“以 0 开头的 0123 的排列”；该行中每个条目都是“序列 123（即除去 0 以外的数字）的某个字典序排列”。第 1 行是所有“以 1 开头的 0123 的排列”；该行中每个条目都是“序列 023（即除去 1 以外的数字）的某个排列”，以此类推。

如果有一个排列编号 p 和大小 n，那么就可以按如下方式在这张表里定位对应的排列：行号为 `p/(n-1)!`，列号为 `p%(n-1)!`。于是我们就可以勾勒出一套算法：要生成“长度为 n 的 0..n-1 序列”的第 p 个排列：

- 令 r（行号） = `p/(n-1)!`
- 令 c（列号） = `p%(n-1)!`
- 第 p 个排列的第一个元素是 r。后面的部分是“在去掉 r 之后，序列 0..n-1 的第 c 个排列”。

> **注意**
> 你可能会好奇：如果一个序列中有重复元素，该如何生成“带重复元素的序列的第 p 个字典序排列”？比如，给定序列 ABB，那么 ABB、BAB 和 BBA 是排列编号 0、1、2 的三种字典序排列。那我们如何根据排列编号取回对应的排列呢？实现的复杂之处在于：以每个可能的首元素开头的排列数量并不相同。大体上，你需要先算出“以每个候选首元素开头的排列有多少种”，然后再利用这些计数来反推“给定的排列编号 p 在哪一行”。这并不难，只是过程繁琐，所以我在这里就不展开了。

听起来，这就是一个递归算法，但我们可以很轻松地把递归改写成循环。下面来看看代码：

代码清单 6.9 根据排列编号生成相应的排列

```csharp
using System.Numerics;

static IList<int> GetLexiPermutation(int n, BigInteger p) #A
{
    var remaining = new List<int>(Enumerable.Range(0, n));
    var result = new List<int>(n); #B
    var f = n.Factorial();
    for (int cur = n; cur > 0; cur -= 1)
    {
        f /= cur; #C
        var r = (int)(p / f); #D
        p %= f;
        result.Add(remaining[r]);
        remaining.RemoveAt(r);
    }
    return result;
}

static class Extensions
{
    public static BigInteger Factorial(this int n) #E
    {
        BigInteger result = 1;
        for(int i = 2; i <= n; i += 1)
            result *= i;
        return result;
    }
}
```

> 注意
> 我们使用 `System.Numerics` 命名空间中的任意精度整数 `BigInteger` 来表示排列编号，因为对于相对较小的 n，n! 就已经超过 `long` 的最大可表示值了。数值库中居然没有优化过的阶乘方法，这有点令人惊讶，不过这个简单实现已经足够我们在这里使用。

我们来做个简单例子。假设要找 0123 的第 p=9 个排列。跟着我一起在脑中走一遍这段调用：

```csharp
Console.WriteLine(GetLexiPermutation(4, 9).Concat());
```

一开始，`remaining` 为 `[0, 1, 2, 3]`，`p` 为 9，`f` 为 24，然后我们进入循环。

- `f` 变成 6，`r` 变成 1，`p` 变成 3，`result` 变成 `[1]`，`remaining` 变成 `[0, 2, 3]`。
   现在我们要在序列 `[0, 2, 3]` 中找“第 3 个排列”。我们重新开始下一轮循环。
- `f` 变成 2，`r` 变成 1，`p` 变成 1，`remaining[r]` 是 2，因此 `result` 变成 `[1, 2]`，`remaining` 变成 `[0, 3]`。
   现在我们要在序列 `[0, 3]` 中找“第 1 个排列”。继续循环。
- `f` 变成 1，`r` 变成 1，`p` 变成 0，`remaining[r]` 是 3，因此 `result` 变成 `[1, 2, 3]`，`remaining` 变成 `[0]`。
- 最后一轮循环中，`r` 变成 0，`remaining[r]` 是 0，因此 `result` 变成 `[1, 2, 3, 0]`，`remaining` 变成 `[]`。

确实，我们输出的是 `1230`，和前面表格中的结果一致。

这个算法的性能如何呢？

- 一开始创建 `remaining` 是时间和空间上都是 O(n) 的。
- 你可能会以为调用扩展方法 `n.Factorial()` 是 O(n) 的，因为它做了 O(n) 次乘法，但要记住：**只有当被乘数的位数有上界时，乘法才是常数时间操作**，而 `BigInteger` 的大小是没有上界的！对任意精度整数做乘法，所需时间与参与运算的数字位数成正比。用这种方式计算阶乘，当 n 大于 20 左右时，最坏情况是 O(n log n)。 （确实存在比这种朴素实现更好的阶乘算法，但本书不打算展开。）
- 同样，循环中的 `BigInteger` 除法和取模运算也可能是 O(log n) 的，而它们被执行了 n 次，因此这部分在最坏情况下也是 O(n log n)。
- 不幸的是，`RemoveAt` 用的是非常朴素的实现。如果你从列表中移除第 5 个元素，那么 `RemoveAt` 会把位置 6 的元素移到位置 5，再把位置 7 的元素移到位置 6，如此类推。平均下来这是 O(n) 的操作，并且会被调用 n 次，因此算法整体的复杂度是 O(n²)。

看来这个恼人的“列表删除”拖了后腿。能不能做得更好呢？在第 3 章中，我们实现了两个不可变 deque 的“廉价拼接”；但我们当时没有实现“逆操作”：在某个位置把一个 deque 拆成两个 deque。不过，这个操作实际上可以在 O(log n) 时间内完成。随后，基于 deque 的 `RemoveAt(x)` 可以通过：先在 x 处把 deque 拆成两半，再在其中一半中“弹出”不需要的元素，最后再把两半拼接回来实现；这些操作都可以做到最坏情况 O(log n)。由于一共要做 n 次 `RemoveAt`，因此它们的总最坏情况代价就是 O(n log n)，和计算阶乘的渐近复杂度相同。

在继续其他排列算法之前，我想更深入地挖一挖：我们刚才是如何把“针对规模为 n 的排列的排列编号 p”递归分解为“行号”和“针对规模为 n-1 的排列的更小的排列编号”的？我们在这里实际上揭示了一个关于整数的、有趣的底层数学事实。

### 排列编号的阶乘进位制表示

之前我们提到过，笛卡尔积和十进制记法之间有非常紧密的联系。我们可以把任意一个介于 0 和 10ⁿ-1 之间的整数 p 分解为 n 个十进制数字；这一串 n 位数字正好是序列 `[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]` 自身取 n 次笛卡尔积所得结果中的一个成员。

分解数字的方式并不只有这一种。在前面我们手工走查 `GetLexiPermutation(4, 9)` 的例子时，循环四次得到的 r 的值依次为 1、1、1 和 0；这四个数就是把 9 分解为四个数之和时的“数字”，只不过每一位的“权重”不是 10 的幂，而是阶乘：

9 = 1×3! + 1×2! + 1×1! + 0×0!

我们可以说，在“阶乘进位制”记法中，9 写作 1110。你可以按步调试一下当 p=19 时的代码，会看到 r 的值依次为 3、0、1、0，对应的和是：

19 = 3×3! + 0×2! + 1×1! + 0×0!

> 注意
> 从右往左数，第 i 位“数字”的取值范围总是在 0 到 i 之间，因此在“阶乘进位制”记法中，最右边那一位始终是 0。

在阶乘进位制下，19 写作 3010。每一位的“基数”都不同，这样的记法乍看有点怪，但用阶乘作为“权重”与我们习惯的 10 的幂相比，其实同样合理。若我们把排列编号 p 写成阶乘进位制的形式：pₙ₋₁ pₙ₋₂ … p₁ p₀，那么求对应排列的算法就可以写得非常简洁：

- 构造一个 `remaining` 列表，内容是 0 到 n-1；再构造一个空的 `result` 列表。
- 从左到右依次处理每一位“阶乘数字”：从 `remaining` 中删除该位置上的元素，并将其追加到 `result` 中。

> 注意
> 因为在阶乘进位制中，第 i 位数字 pᵢ 的取值范围总是在 0 到 i 之间，而此时 `remaining` 列表中有 i+1 个元素，所以我们始终是在从这些元素中选一个。当 `remaining` 中只剩一个元素时，最右边那位数字必然是 0。

当你用这种方式来描述字典序排列算法时，会觉得有点似曾相识——很可能你以前已经见过和它“极其相似”的东西了。

### Fischer–Yates 洗牌算法

Fischer–Yates 随机重排一个可变列表的算法非常有名。对一个含有 n 个元素的可变列表进行洗牌时，它只做 n 次交换：

- 生成一个长度为 n 的随机数序列 rₙ₋₁,…,r₀，其中 rᵢ 的取值范围是 0 到 i。
- 对每个下标 i，把下标为 i 的元素与下标为 i+rᵢ 的元素交换。

就这么简单！下面是一个实现该算法的扩展方法：

代码清单 6.10 Fischer–Yates 洗牌

```csharp
static class Extensions
{
    public static void FYShuffle<T>(this IList<T> items)
    {
        var r = new Random();
        for ( int i = 0; i < items.Count - 1; i += 1)
            items.Swap(i, i + r.Next(0, items.Count-i));
    }
}
```

我们可以很容易地测试一下：

```csharp
List<int> shuffleMe = [0, 1, 2, 3];
shuffleMe.FYShuffle();
Console.WriteLine(shuffleMe.Concat());
```

在我机器上，它打印出了 3012，但当然，它也完全可能是任意其他排列。关键是：现在我们知道为什么“字典序排列的阶乘进位制解释”看起来那么熟悉了。

生成的那串 n 个随机数，完全可以看作是某个“排列编号”的阶乘进位制数字。只不过它并不是“字典序排列对应的排列编号”罢了！我们可以写出一个“根据排列编号生成 Fischer–Yates 排列”的版本，对所有可能的 Fischer–Yates 洗牌施加一个“顺序”：

代码清单 6.11 一个非字典序的排列生成器

```csharp
static IList<int> GetFYPermutation(int n, BigInteger p)
{
    var result = new List<int>(Enumerable.Range(0, n));
    var f = n.Factorial();
    for (int cur = n; cur > 0; cur -= 1)
    {
        f /= cur;
        var r = (int)(p / f);
        p %= f;
        result.Swap(n - cur, n - cur + r);
    }
    return result;
}
```

生成“第 p 个字典序排列”和“第 p 个 Fischer–Yates 排列”的这两个算法几乎一模一样。它们对所有排列施加的顺序也类似，但并不相同。我们来看一下：

```csharp
for (int p = 0; p < 24; p += 1)
    Console.Write($"{p,2}:{GetFYPermutation(4, p).Concat()} ");
```

我们得到的这个“非字典序”的排列顺序是：

```
0:0123 1:0132 2:0213 3:0231 4:0321 5:0312
6:1023 7:1032 8:1203 9:1230 10:1320 11:1302
12:2103 13:2130 14:2013 15:2031 16:2301 17:2310
18:3120 19:3102 20:3210 21:3201 22:3021 23:3012
```

它在“最左边的数字”上仍然是字典序的，但很快就和字典序在其他位置上产生了差异。虽然这种“排列编号 → 排列”的映射方式不再具备“按字典序枚举”的优点，但它有一个非常好的性质：它做的是 n 次 O(1) 的交换操作，而不是 n 次 O(n) 的 `RemoveAt()`。

如果你想出于某种原因生成“整数的第 p 个排列”，而并不在乎它是不是按字典序生成的，那么这种技术要廉价得多。

字典序排列的优点是生成顺序非常直观自然；Fischer–Yates 算法的优点是，它为我们提供了一种高效、廉价的方式来实现公平洗牌。在实际应用中，它们都足够好用。但用于生成排列的算法远不止这两种，有些算法即便在实用性上稍微逊色一点，也依然非常有趣。接下来，我们来看看我个人最喜欢的一种重排序列的方式：“换序敲钟（change ringing）”算法。

### 递归的“换序敲钟”算法

假设你有一组 n 个互不相同的钟，从 0 到 n-1 编号，每个钟发出的音符都不同。如果我们把自己限制在正好敲 n 声的“乐曲”，并且每个钟只敲一次，那么很容易看出一共有 n! 种不同的旋律：它们就是钟的所有排列。

现在我们再加上一条限制：当我们枚举所有可能的排列时，每一个“下一个”排列，都必须通过恰好一次“相邻两钟交换”得到。也就是说，我们从“按编号排序的钟的顺序”开始敲，按该顺序敲一遍。然后通过交换一对钟的位置得到下一个排列，再按新的顺序敲一遍。如此反复：每次只交换一对相邻的钟，直到每一种可能的旋律都被敲过且只敲一次为止。**换序敲钟问题**就是：如何仅用 n! 次交换（每种排列一次），做到这件事？

> 注意
> 在英国，敲教堂钟或手钟的“换序”游戏自 17 世纪以来一直颇受欢迎；对“排列顺序的限制条件”和“生成这些排列顺序的算法”都有很多变体。在本书中，我们只讨论“每次只交换一对相邻元素”这一种限制，以及一个解决这一问题的算法。

Pandita 的算法在这里就不适用了。若我们有三个钟 0、1、2，那么字典序排列是 012、021、102，很明显已经违反了“换序敲钟”的限制。有没有一种顺序是满足要求的？比如：012、021、201、210、120、102 就可以，并且更妙的是：最后一个排列只需交换一次，又能回到第一个排列。

下面给出一个递归算法，用来生成满足换序要求的排列。同样地，我们会把排列拆成一个有 n 行、(n-1)! 列的表，以帮助理解算法。

这一次，我们将按“列”读取表中的排列，而不是像之前那样按“行”读取。

- 如果你有 0 个钟，那就没有排列。空排列列表在“换序”的意义上是平凡成立的。
- 如果你有 1 个钟，只有一种排列：0。所有排列的列表同样在换序意义上平凡成立。
- 若有 2 个钟，只有两种排列：01 和 10。它们同样构成了一个平凡成立的换序序列。

对于 3 个钟，我们从 2 个钟的排列开始。再次构造一个有 n 行、(n-1)! 列的表格。行标为 0、1、2；每一列对应一个 2 钟排列，因此列标也从 0 开始。再为各列交替标记方向：“右”“左”“右”“左”…

接着，在每一格中往 2 钟排列的“适当位置”插入一个 2，该位置由“行号”和“列方向”共同决定：

表 6.2 从 2 钟排列生成 3 钟排列

Row 0 right   1 left
 0   012       210
 1   021       120
 2   201       102

我们是把“2 钟排列的副本”拿来，在上面“按行号+方向”插入数字 2 的：

- 在第 0 列（方向为 right）中，我们从右往左数，分别在位置 0、1、2 插入 2；
- 在第 1 列（方向为 left）中，我们从左往右数，分别在位置 0、1、2 插入 2。

随后，我们按列从上到下依次读出这些排列：得到的序列就是

012, 021, 201, 210, 120, 102

对于 4 个钟，我们再一次构造一个有 n 行、(n-1)! 列的表。每一列都填上“4 份 3 钟排列”，然后按行号和列方向插入 3：

Row 0 right   1 left   2 right   3 left   4 right   5 left
 0   0123      3021     2013      3210     1203      3102
 1   0132      0321     2031      2310     1230      1302
 2   0312      0231     2301      2130     1320      1032
 3   3012      0213     3201      2103     3120      1023

然后，我们仍然按列逐列读取：

0123, 0132, 0312, 3012, 3021, 0321, …

一般情形下，对于 n 个钟，我们构造一个 (n-1)! 列、n 行的表，在每个单元格中填入上一轮“n-1 钟排列”的拷贝，再在适当的位置插入数字 (n-1)。我相信你已经能看出，这样构造的排列序列具有我们想要的性质：它枚举了所有可能的排列，并且由于构造顺序足够巧妙，**相邻的两个排列之间总是恰好有一对元素互换了位置**。

这段代码写起来会很有意思。和之前一样，我会把主要工作放进一个“描述性命名”的扩展方法里，从而让主算法简短且易读：

代码清单 6.12 递归的换序敲钟算法

```csharp
static IEnumerable<IEnumerable<int>> Changes(int n)
{
    if (n == 0) #A
    {
        yield return [];
        yield break;
    }
    bool fromLeft = false; #B
    foreach (var perm in Changes(n - 1))
    {
        for (int row = 0; row < n; row += 1)
            yield return perm.InsertAt(fromLeft ? row : n-row-
                1, n-1);
        fromLeft = !fromLeft; #C
    }
}
static class Extensions
{
    public static IEnumerable<T> InsertAt<T>(
        this IEnumerable<T> items, int index, T insert)
    {
        int current = 0;
        foreach (T item in items)
        {
            if (current == index)
                yield return insert;
            yield return item;
            current += 1;
        }
        if (current == index)
            yield return insert;
    }
}
```

如果我们尝试生成所有 4 钟的“换序”：

```csharp
foreach (var change in Changes(4))
    Console.Write(change.Concat() + " ");
```

……我们会得到一个合法的 4 钟换序排列的顺序，共 24 种：

0123 0132 0312 3012 3021 0321 0231 0213 2013 2031 2301 3201
 3210 2310 2130 2103 1203 1230 1320 3120 3102 1302 1032 1023

这又是一种不同的排列顺序；那么，给定一个介于 0 和 n!-1 之间的排列编号时，我们能否直接生成对应的换序排列呢？和刚才一样，我们通过把排列组织成一张表，已经解决了大部分问题。根据排列编号生成换序排列的算法如下：

- 如果 n 为 0，就生成空排列，结束。否则：
  - 列号 c = ⌊p / n⌋。
  - 递归地生成“规模为 n-1、排列编号为 c 的排列”。
  - 行号为 p % n；这就是我们要插入 (n-1) 的位置。
  - 如果 c 是偶数，则“从右边数起”插入；否则“从左边数起”插入 (n-1)。

毫不意外，代码看起来与刚刚的实现非常相似：

代码清单 6.13 根据排列编号生成换序排列

```csharp
static IEnumerable<int> GetChange(int n, BigInteger p)
{
    if (n == 0)
        return [];
    var row = (int)(p % n);
    var column = p / n;
    var perm = GetChange(n - 1, column);
    var fromLeft = column % 2 != 0;
    var i = fromLeft ? row : n - row – 1;
    return perm.InsertAt(i, n - 1);
}
```

现在我们可以按编号生成某一个具体的“换序”：

```csharp
Console.WriteLine(GetChange(4, 5).Concat());
```

它会输出 0321，正是我们所期待的结果。借助这些算法，我们既可以按顺序生成所有排列，也可以在给定编号时直接生成某一个。

当生成一个规模为 n 的单个排列时，这些算法的时间性能如何？由于它们本质上是同一个思路，我们只考察 `GetChange()` 的性能即可。

一个略显“不尽人意”的答案是：它是 O(1) 的，因为 `InsertAt` 是惰性的。使用 `yield return` 的方法，在返回的序列被枚举之前，其内部代码不会真正执行。不过这有点误导；我们真正想知道的是，“**把这个排列的 n 个元素都枚举一遍的成本是多少**”。

我们可以简单做个心算例子，看看实际发生了什么。继续之前的例子，如果你展开递归调用，并把扩展方法“去语法糖化”，会发现它实际上做的是：

```csharp
InsertAt(InsertAt(InsertAt(InsertAt([], 0, 0), 1, 1), 1, 2), 1,
    3)
```

也就是说，我们从空序列 `[]` 开始，在位置 0 插入 0 得到 `[0]`；在位置 1 插入 1 得到 `[0, 1]`；在位置 1 插入 2 得到 `[0, 2, 1]`；在位置 1 插入 3 得到 `[0, 3, 2, 1]`。

但每当我们枚举该序列的一个元素时，背后实际上可能会触发最多 n 层嵌套调用，具体层数取决于我们要生成的是哪一个排列。由于要枚举 n 个元素，因此最坏情况下，该算法的复杂度是 O(n²)。当然，n 通常不会特别大——你一般不会去排列一个包含一百万个元素的序列——但 O(n²) 仍然算不上理想。能否做得更好？

真正拖累我们的，是这 O(n) 层的 `InsertAt` 嵌套调用；就像在生成字典序排列时，列表上的 O(n) `RemoveAt` 成为了瓶颈一样。我当时建议，可以在不可变 deque 上实现一个 O(log n) 的 `RemoveAt`；同理，我们也可以在不可变 deque 上实现一个 O(log n) 的 `InsertAt`。这样一来，每个排列的生成在最坏情况下就能在 O(n log n) 时间内完成。

有点讽刺的是：一个从“上一个排列”到“下一个排列”只交换一对元素的算法，单次生成的复杂度却高于线性。下一小节，我们会看看一个更巧妙的方案，用来生成所有“换序敲钟”的排列，它在“每生成一个排列的成本”上表现得更好。

### Even 的“换序敲钟”算法

前面用于生成“换序顺序”下 n 个数字所有排列的那种“制表法”，其实已经被人们使用了几百年，但一直到 20 世纪，它才被正式作为组合数学问题来研究。数学家 Hugo Steinhaus、Selmer Johnson 和 Hale Trotter 各自独立地提出了“每生成一个排列只需 O(n) 时间”的算法，用于枚举所有换序排列；而计算机科学家 Shimon Even 则在他们算法的基础上提出了一个变体，它既快速又易于说明。我觉得它和 Pandita 的字典序算法颇为相似：同样使用一个可变数组来生成下一个排列，再用线性查找确定需要交换的元素。

Even 算法的基本想法，来自对前面递归算法的一个观察：递归算法大部分时间都在“把当前最大的数字来回推到两端”。只有当这个最大数字被推到某一边的极限时，我们才会移动更小的数字，并且每个较小数字同样会往左、往右移动。Even 的换序排列算法是他所著《Algorithmic Combinatorics》一书中给出的第一个算法，大致过程如下：

1. 排列中的每个数字都有一个“方向”，要么向左，要么向右。我会在排列中的数字旁边用箭头标出这个方向。
2. 若排列中的某个数字，在“它指向的方向”上，“紧挨着它的位置”上有一个更小的数字，则称它是“可动的（mobile）”。
    例如，在 ←0 ←1 ←2 ←3 中，可动数字是 1、2 和 3；它们的左侧都紧挨着一个更小的数字，而 0 没有。（0 永远不是可动的。）
    再比如，在 ←1 2→ ←3 ←0 中，只有 3 是可动数字，因为它左边紧挨着 2。1 左边没有数字，而 2 右边紧挨着的是更大的数字。
3. 用起始排列构造一个数组。所有数字的方向初始都设为“向左”。
4. 如果没有任何可动数字，说明已经到了最后一个排列，算法结束。
5. 把“最大的可动数字”和它指向方向上的邻居交换。
6. 反转所有“比刚刚移动的这个数字更大的数字”的方向。
7. 回到第 4 步。

让我们用四个数字的例子跑一下前几步，你就能体会到算法的运行过程了：

- 从 ←0 ←1 ←2 ←3 开始。最大的可动数字是 3，把它和左边的数字交换。没有比 3 更大的数字，所以没有任何方向被反转。
- 我们得到 ←0 ←1 ←3 ←2。情况相同：把 3 再向左交换一次。
- 得到 ←0 ←3 ←1 ←2。仍然相同。
- 得到 ←3 ←0 ←1 ←2。此时最大的可动数字是 2，把它向左交换，并反转所有比 2 大的数字的方向。
- 得到 3→ ←0 ←2 ←1，如此继续。此时 3 又是最大的可动数字……

只要 3 还能移动，它就会移动。每当它暂时不能移动时，我们会先短暂移动一个更小的数字，然后反转 3 的方向，接着它又继续移动。

Even 算法使用两个可变数组：一个用于存放当前排列本身；另一个用于存放每个数字对应的布尔型“方向值”，我们把这个布尔值解释为“指向左还是右”。在代码中，我们约定用 1 表示“向右”，用 -1 表示“向左”，原因在看到代码时就一目了然了。那我们来写代码吧！

这一次，我仍然会把小块逻辑拆到“具描述性的辅助方法”里，以避免嵌套循环，不过这些辅助方法将作为局部函数写在主函数内部，而不是扩展方法：

代码清单 6.14 Even 的换序敲钟算法

```csharp
static IEnumerable<IList<int>> EvensChanges(int n)
{
    var perm = Enumerable.Range(0, n).ToArray();
    var dirs = Enumerable.Repeat(-1, n).ToArray(); #A
    bool IsMobile(int i) #B
    {
        int j = i + dirs[perm[i]];
        return 0 <= j && j < n && perm[j] < perm[i];
    }
    int? MaxMobile() #C
    {
        int max = -1;
        int? maxIndex = null;
        for(int i = 0; i < perm.Length; i += 1)
        {
            if (IsMobile(i) && perm[i] > max)
            {
                maxIndex = i;
                max = perm[i];
            }
        }
        return maxIndex;
    }
    while(true)
    {
        yield return perm.ToList(); #D
        int? maxIndex = MaxMobile();
        if (maxIndex == null)
            yield break; #E
        int mi = maxIndex.Value;
        int m = perm[mi];
        perm.Swap(mi, mi + dirs[m]); #F
        for (int k = m + 1; k < n; k += 1) #G
            dirs[k] = -dirs[k];
    }
}
```

要注意的一点是：绝不要 `yield` 出一个“之后仍将被修改”的数据结构引用。调用方完全有理由认为：它拿到的是一个可以放心使用的对象——既可以安全读取，也可以按需修改，而不用担心影响到其他代码。这也是为什么我们要在 `yield` 之前用 `ToList` 把当前排列拷贝一份。

如我们所愿，我们可以按“换序顺序”生成 0123 的所有排列。下面这段代码：

```csharp
foreach (var perm in EvensChanges(4))
    Console.Write(perm.Concat() + " ");
```

……会产生如下输出：

```
0123 0132 0312 3012 3021 0321 0231 0213 2013 2031 2301 3201
3210 2310 2130 2103 1203 1230 1320 3120 3102 1302 1032 1023
```

Even 算法在空间上的开销是：为每个 `yield` 出的排列调用一次 `ToList`，需要额外 O(n) 空间；这并不意外。那在“每生成一个排列”意义下，该算法的时间性能如何？

- `ToList` 是 O(n) 的；它会把 n 个元素拷贝到一个列表中。
- 当前实现中的 `MaxMobile` 会遍历排列中的每一个数字，而 `IsMobile` 是 O(1) 的，所以 `MaxMobile` 始终是 O(n)。
- `Swap` 是 O(1) 操作，而更新方向的那段循环在最坏情况下是 O(n)。

综合起来，这个算法在“每生成一个排列”上的时间复杂度是 O(n)，比我们之前那个可能达到平方级复杂度的递归实现要好得多。

你也许已经注意到，我这个版本的 `MaxMobile` 在查找“最大的可动元素”时，会不加区分地检查排列中的每一个元素。这里有不少可做的优化；一个显然的优化就是：一旦确定 (n-1) 是可动的，就可以停止继续查找更大的元素了。还有许多其他优化；在他的书中，Even 给出了一个更复杂的 `IsMobile` 实现，可以进一步提升性能。

不过，我就不再展开这种改进了；在这里，我们就以此收尾排列这一节，把目光转向最后一个话题：组合。

## 组合

一个长度为 n 的序列的*组合*，是指该序列中长度为 k 的各种子序列。子序列中元素的相对顺序保持不变，只是删除了其中的一部分元素。比如，序列 ABCDE 在 k=3 时的所有组合是：ABC、ABD、ABE、ACD、ACE、ADE、BCD、BCE、BDE 和 CDE。

排列适合用来生成“如果我们按不同顺序做事情会发生什么？”这类测试用例；组合则适合回答“如果我们跳过一些东西会发生什么？”这样的问题。

我们之前注意到，如果你需要对任意类型的列表做排列，只要对 0 到 n-1 的整数序列做排列就够了；再用得到的“重排后的整数序列”作为下标去重排任何别的列表即可。对于组合，我们也可以做完全相同的论证：我们真正需要做的，只是从 0,…,n-1 中生成一个含有 k 个元素的子序列。之后我们可以把这个组合当作下标序列，去选择任何列表里的元素：

代码清单 6.15 生成任意列表的组合

```csharp
static class Extensions
{
    public static IList<T> Combine<T>(
        this IList<T> items, IList<int> combination)
    {
        var result = new T[combination.Count];
        for (int i = 0; i < combination.Count; i += 1)
            result[i] = items[combination[i]];
        return result;
    }
}
```

如果我们手头有一个组合，比如 `[1, 2]`，就可以把它应用到任意一个列表上：

```csharp
List<string> foods = ["ham", "jam", "spam", "lamb"];
Console.WriteLine(foods.Combine([1, 2]).Space());
```

……得到令人愉悦的组合：`jam spam`。

就像在排列那一节中所做的，我们会看几种不同的方式来枚举组合；先从一个类似 Pandita 排列算法的字典序算法开始，然后看一个不需要可变数据结构、却能得到相同结果的优雅递归算法。最后，我们会介绍几种直接生成“第 p 个组合”的方法，并顺带学习一种关于“以非标准方式分解整数”的有趣事实。

### 带一点小花样的字典序组合

我们之前是通过“从第一个排列开始，一直原地修改得到下一个排列”来按字典序生成排列的；同样地，我们也可以按字典序生成所有组合，不过我们会在排序方式上做一点小小的改动：**我们约定按“从右往左”读组合时的字典序来枚举组合**。

也就是说，当 n=6、k=4 时，我们会按下面这个顺序枚举组合：

```
0123 0124 0134 0234 1234 0125 0135 0235 1235 0145 0245 1245
0345 1345 2345
```

也就是说，我们先列出所有“最右边的数字是 3 的组合”，然后列出所有“最右边是 4 的组合”，最后以“最右边是 5 的组合”收尾，等等。这仍然是一种字典序排序，只不过“起点”换成了右端。

> 注意
> 另一种表示组合的方式是用比特串：如果某个比特位置属于组合，则该位为 1，否则为 0。比特串的高位在左，因此如果我们把 n=6、k=4 的组合用比特串表示，并按“从左到右”的字典序来排列，就会得到 `001111, 010111, 0010111, …, 111100`。按这种字典序来生成组合会很方便；同时，用“长度为 k 的递增整数序列”来表示组合比用“长度为 n 的比特串”也更方便。综合起来，就造成一个略微“别扭”的结果：我们将按“从右往左的字典序”来枚举“用整数序列表示的组合”。

我们先走一个例子，再来写代码。假设 n=6，因此我们有序列 012345，并希望生成上面列出的 k=4 的组合。问题是：在这些组合中，紧跟在 1245 后面的“下一个字典序组合”是什么？算法如下：

- 在一个组合中，如果某个数字小于 n-1，并且在它加 1 之后仍然小于其右边的数字（如果存在右边数字的话），那么这个数字就是“可递增的”。在上面的例子中，1 和 4 都不可递增，因为它们一旦自增，就会和右边的数相等；而 5 已经等于 n-1，也不可递增。
- 找到最右边那个可递增的数字。如果不存在这样的数字，则说明我们处在字典序中的最后一个组合，可以停止了。在例子中，2 就是最右边的可递增数字。
- 把这个数字加 1。此时组合变为 1345。
- 把刚刚自增的这个数字左侧的所有数字都设置成“尽可能小”的值：在例子中得到 0345。这就是下一个字典序组合。

要按字典序枚举所有组合，只需要从第一个组合开始，一直把当前组合“变为下一个组合”直到再也没有下一项为止。照例，我会写一个小小的辅助方法 `Increasable`，让代码更容易表达出“含义”。我会给你看两种枚举组合的方式，所以先给第一种实现起名叫 `Combinations1`：

代码清单 6.16 通过修改生成下一个字典序组合

```csharp
static bool NextLexiCombination(int n, IList<int> c)
{
    int k = c.Count;
    bool Increasable(int i) =>
        i == k - 1 ? c[i] < k + 1 : c[i] + 1 < c[i + 1];
    int i = 0;
    while (i < k && !Increasable(i)) #A
        i += 1;
    if (i == k) #B
        return false;
    c[i] += 1; #C
    for (int j = 0; j < i; j += 1)
        c[j] = j; #D
    return true;
}
static IEnumerable<IList<int>> Combinations1(int n, int k)
{
    var c = Enumerable.Range(0, k).ToArray(); #E
    do
        yield return c.ToList(); #F
    while(NextLexiCombination(n, c));
}
```

在看示例之前，我们先简单想一下几个边界情况。

如果我们要求“从 0、1、2、3 中选出 k=6 个数”的所有组合，很显然没有这样的组合。`Combinations1` 在这种情况下会产生一个空的组合序列。

如果 k=0 呢？长度为 0 的组合恰好只有一个：空组合。`Combinations1` 会返回一个列表，其中仅包含一个空列表。

再来看具体例子：比如从 012345 中选出所有 4 个数字的组合：

```csharp
foreach (var comb in Combinations1(6, 4))
    Console.Write(comb.Concat() + " ");
```

这会输出：

> 0123 0124 0134 0234 1234 0125 0135 0235 1235 0145 0245 1245
> 0345 1345 2345

……这就是在“从右往左读”的字典序排列下，15 个可能的组合。

这个算法在“每生成一个组合”时的性能如何？如果我们看 `NextLexiCombination`，可以发现它有两个循环。第一个循环可能会检查所有 k 个元素，第二个循环可能会更新 k-1 个元素。最坏情况下，k 可以等于 n，因此这个算法的最坏时间复杂度看起来是 O(n)。

这确实是最坏情况，但就像我们在 Pandita 算法中看到的那样，大部分时候最左边的数字就是可递增的！只有在“最后一个组合”的那一次，第一重循环才需要跑满。平均情况下，**寻找并更新当前组合的这部分工作是 O(1)**，不过我们随后要调用 `ToList()`，它是 O(k) 的。

我们还可以用一个优雅的递归方法来生成组合，而且完全不需要做任何修改操作。这个算法的动机是这样一个事实：对于任何从 0 到 n-1 的组合，如果 n-1 出现在组合中，它一定只会出现在组合的最右端。因此，我们可以先枚举所有**不包含 n-1** 的组合，再枚举所有**以 n-1 结尾**的组合。这样就能保证我们前面说的“按右端字典序”的顺序：

代码清单 6.17 一个优雅的递归组合生成算法

```csharp
static IEnumerable<IDeque<int>> Combinations2(int n, int k)
{
    if (k > n || k < 0)
        yield break; #A
    if (k == 0)
    {
        yield return Deque<int>.Empty; #B
        yield break;
    }
    foreach (var r in Combinations2(n - 1, k)) #C
        yield return r;
    foreach (var r in Combinations2(n - 1, k - 1)) #D
        yield return r.PushRight(n-1);
}
```

由于我们是在把元素追加到组合的右端，并且希望避免修改，因此用我们之前实现的不可变 deque 来存储组合会比较合适。如果之后需要把它变成列表，调用 `ToList()` 扩展方法就足够简单了。

这个方法在“每生成一个组合”时的性能如何？基例显然是 O(1) 的。在递归情形下，每生成一个组合，恰好会调用 k 次 `PushRight()`，而这些操作的摊还成本都是 O(1)，所以总共是 O(k)。不过，为了完成这 k 次 `PushRight()`，我们最多可能做 O(n) 次递归调用，因此更准确地说，这个算法是一个 **时间复杂度 O(n)、并在最坏情况下使用 O(n) 栈空间** 的算法。

能按顺序生成组合当然很好，但组合的数量可能会非常巨大。我们知道，长度为 n 的序列有 n! 种排列；那一共有多少种不同的组合？我们能否像对排列所做的那样，生成“第 p 个字典序组合”？为了解答这些问题，我们接下来看看“组合数（choose）”运算。

### 计算组合数

对于“从数字 0 到 n-1 中选出 k 个元素有多少种组合？”这一操作，有多种标准记号。我将在这里使用一个新的二元运算符 **C**：从 n 个元素中选出 k 个元素的组合数记作 **n C k**。该运算符读作“n choose k（n 选 k）”。我们可以从中推导出以下一些性质：

- 如果 **k > n**，则 **n C k = 0**。从一个序列中选出的元素个数不能多于序列中的元素个数，因此组合数为零。
- 对所有 n，**n C 0 = 1**。选择零个元素只有一种方式，即空组合。
- **n C k = n C (n – k)**。从 n 个可能性中选 n-k 个元素与选 k 个元素的方式数相同。

我们可以通过再次观察 n=6、k=4 的组合，并在旁边写出未被选中的数字，来理解这一点：

```
0123|45  0124|35  0125|34  0134|25 …
```

每个独特的“选中 4 个元素”的组合，都对应一个独特的“未选中的 2 个元素”的组合，因此 **n=6、k=2 的组合数必须与 n=6、k=4 相同**。

- **n C k = (n-1) C (k-1) + (n-1) C k。**正如我们在先前递归算法中所看到的，从 0 到 n-1 中选 k 个元素的所有组合要么包含 n-1，要么不包含 n-1。包含 n-1 的组合数量为：从剩下的 n-1 个数字中选 k-1 个。不包含 n-1 的组合数量为：从剩下的 n-1 个数字中选 k 个。因此两者之和就是全部组合数量。

- **n C k = (n)(n-1)…(n-k+1) / k!**。至此我们终于有了一个无需使用递归即可直接计算 n C k 的公式。

  我们可以通过如下思路证明：假设我们像 Fisher–Yates 洗牌那样逐个挑选元素来构造一个排列，但只挑选前 k 个元素：第一个元素有 n 种选择，第二个有 (n-1) 种选择，…，最后一个有 (n-k+1) 种选择。但对于这 k 个元素，有 k! 种排列方式，而只有一个排列是排序后的组合，所以需除以 k! 用来消除重复计数。

虽然这个公式可以实现 n C k 的计算，但如果先完成全部乘法再做全部除法，就会产生非常大的整数，导致 BigInteger 算术开销巨大。我们希望数值尽量小。例如，若天真地计算 20 C 18，我们会先算 20×19×18×…×3，然后除以 18、17、…、2，得出结果 190——这需要很多步骤。

我们可以用两个优化方法。首先注意：**20 C 18 = 20 C 2**，计算时只需算 20×19 再除以 2，开销大幅减少。但这个技巧对 **20 C 10** 就无效；于是我们用第二个优化，通过比较 n C k 与 n C (k-1)：

```
n C k     = (n)(n-1)…(n-k+2)(n-k+1) / (k)(k-1)!
n C (k-1) = (n)(n-1)…(n-k+2) / (k-1)!
因此：
n C k = (n C (k-1)) (n-k+1) / k
```

这给我们提供了一个可高效利用的递推式以保持数值较小。我将再次写一个方便的扩展方法：

**代码如下：**

```csharp
static class Extensions
{
    public static BigInteger Choose(this int n, int k)
    {
        if (k > n)
            return 0;                 #A
        if (k > n / 2)                 #B
            k = n - k;
        BigInteger result = 1;         #C
        for (int i = 1; i <= k; i += 1)
            result = result * (n - k + i) / i;   #D
        return result;
    }
}
```

> **注意**
> 你明白我为何说要注意吗？此处很容易想使用复合赋值运算符 `*=`，但那会产生 bug。`a = a*b/c` 的含义是 `(a*b)/c`，但 `a *= b/c` 的含义是 `a = a*(b/c)`。若先执行除法再执行乘法，可能导致不必要的整数舍入错误！例如，在计算 20 C 10 时开头几步为：$1*11/1$、$11*12/2$、$66*13/3$，但若写成 $66*(13/3)$，由于整数除法会被舍入结果就不对了。

要问“从 20 个数中选择 10 个数共有多少种方式？”：

```csharp
Console.WriteLine(20.Choose(10));
```

输出结果是 184756，数量相当大。

n C k 的规模可能非常大；那这个操作有多昂贵？最坏情况是 k=n/2：循环执行 k 次，每次 BigInteger 乘除在最坏情况下要 O(log n) 时间，因此总体最坏为 O(n log n)，最好为 O(k)。

从 0 到 n-1 中选 k 个数共有 n C k 个组合，因此我们可以按字典序给每个组合编号，从 0 到 (n C k)-1。若能通过组合编号直接生成对应组合将非常方便。但如何做到？

> **注意**
> 这在生成随机组合时尤为有用：只需生成一个 0 到 (n C k)-1 之间的随机数，再生成对应组合即可。

我们将用两种方法实现。第一种是对前面递归生成组合算法的简单改造。第二种展示一个令人惊讶的事实：只用 p 和 k 就能生成对应的组合。

我们先回到递归组合生成算法。给定 n 和 k，字典序排列的组合列表前面是所有**不以 n-1 结尾的 (n-1) C k 个组合**，其后是 **以 n-1 结尾的 (n-1) C (k-1) 个组合**。
 因此一个生成第 p 个组合的递归算法也自然遵循这个结构。给定 n、k 和组合编号 p（范围 0 到 n C k - 1）：

若 k 为 0 或 k > n，则组合为空。
 若 p < (n C (k-1))，则该组合不以 n-1 结尾。递归生成从 0 到 n-2 中选 k 个元素的第 p 个组合。
 否则，递归生成从 0 到 n-2 中选 k-1 个元素的第 p - (n C (k-1)) 个组合，并在末尾附加 n-1。

代码如下：

```csharp
static IDeque<int> GetCombination(BigInteger p, int n, int k)
{
    if (k > n || k == 0)
        return Deque<int>.Empty;
    var boundary = (n - 1).Choose(k);
    return p < boundary ?
        GetCombination(p, n - 1, k) :
        GetCombination(p - boundary, n - 1, k - 1).PushRight(n - 1);
}
```

例如，若我们想要从 6 个数中选 4 个的组合里编号为 8 的组合：

```csharp
Console.WriteLine("Listing 6.20 sample code");
Console.WriteLine(GetCombination(8, 6, 4).Concat());
```

输出为正确结果 **1235**。

该函数的性能分析与 `Combinations2()` 类似。仍然有恰好 k 次 `PushRight()`，并由最多 O(n) 次递归调用产生。额外开销来自可能代价较高的 Choose() 调用，其最优 O(k)、最坏 O(n log n)，因此整体最坏可达 O(n² log n)（当 n 与 k 都很大时）。

一个合理的优化方式是借鉴先前 Gosper 算法的经验，对 Choose() 做 memoization，用更多的内存换取可能的速度提升。

我们刚才将组合编号按“是否以右端数字结尾”拆解为两个子区间，这暗示了两件事：

- 我们可以生成上述方法的逆过程：即写一个方法输入组合，输出其字典序编号。
- 正如 0 到 n!-1 可用“阶乘进制”表示一样，0 到 (n C k)-1 也能用一种“组合进制”表示。

我们将在本章最后一节看到如何实现这两件事。

### 组合的组合进制表示

我们刚刚看到，你可以从它的组合编号 p 生成一个组合。反过来应该也很直接：如果我们有 n、k 以及一个组合，我们就能用同样的逻辑“反向”推导出它的组合编号：

- 如果组合为空，那么它的编号只能是 0。
-  否则，如果组合中最右边的数等于 n-1，那么它的组合编号必然大于或等于 (n–1) C k。弹出最右边的数，递归地为大小为 k – 1 的组合求组合编号，然后把它加到 (n-1) C k 上。
-  否则，我们可以用 n-1 递归计算该组合的组合编号，因为它不包含 n-1。

代码几乎是自然而然就写出来了：

清单 6.20 从组合递归生成组合编号

```csharp
static class Extensions
{
    public static BigInteger GetCombNumber(this IDeque<int> comb, int n, int k) =>
    	comb.IsEmpty ? 
        0 : 
    	comb.Right() == n-1 ?
    		(n-1).Choose(k) + comb.PopRight().GetCombNumber(n-1, k-1) :
    		comb.GetCombNumber(n-1, k);
}
```

让我们按字典序把它们全部列出来，并验证组合编号确实是该顺序中的索引：

```csharp
foreach (var c in Combinations2(6, 4))
Console.Write($"{c.GetCombNumber(6, 4),2}:{c.Concat()} ");
```

果然，我们得到：

```
0:0123 1:0124 2:0134 3:0234 4:1234 5:0125 6:0135 7:0235
8:1235 9:0145 10:0245 11:1245 12:0345 13:1345 14:2345
```

代码是可行的，但我们可以在计算方式上更聪明一点，从而发现一个更优雅的解法。关键事实是：如果一个组合中最右边的数是 z，那么它的组合编号至少是 z C k。在我们刚刚为 n=6、k=4 生成的输出里，你可以看到：

- 以 3 结尾的第一个组合的组合编号是 3 C 4 = 0。
- 以 4 结尾的第一个组合的组合编号是 4 C 4 = 1。
- 以 5 结尾的第一个组合的组合编号是 5 C 4 = 5。

我们可以利用这个事实，高效地根据一个组合求出它的组合编号。我们先做一个例子，然后再写代码。假设我们想知道 0245 的组合编号。

最右边的数是 5，所以可能的最小组合编号是 5 C 4 = 5。让我们回顾一下所有以 5 结尾的组合。它们是：

```
0125 0135 0235 1235 0145 0245 1245 0345 1345 2345
```

现在看最右边两个数。在上面这串以 5 结尾的组合列表里，我们要走多远才能找到第一个以 45 结尾的组合？我们可以把末尾的 5 都去掉，把问题简化为在这个列表里找到第一个以 4 结尾的组合：

```
012 013 023 123 014 024 124 034 134 234
```

这些正好是大小为 3 的组合，而我们知道第一个以 4 结尾的组合位置是 4 C 3 = 4。因此，该组合的组合编号至少是 4 + 5。

只考虑以 4 结尾的组合，并去掉 4，我们得到：

```
01 02 12 03 13 23
```

我们要走多远才能找到一个以 2 结尾的？这些是大小为 2 的组合，所以答案是 2 C 2 = 1。组合编号至少是 1 + 4 + 5。

只考虑以 2 结尾的组合，并去掉 2：

```
0 1
```

我们要走多远才能找到一个以 0 结尾的？那是 0 C 1，也就是 0。于是 0245 的组合编号是 0 + 1 + 4 + 5 = 10。

你看到规律了吗？我们从组合 0245 出发，它的组合编号最终变成了 (0 C 1) + (2 C 2) + (4 C 3) + (5 C 4)。太有意思了！

一般情况是：对任意包含 k 个元素的组合，记为 x0, x1, … xk-1，它在按字典序排列的组合列表中的索引是 (x0 C 1) + (x1 C 2) + … + (xk-1 C k)。注意，这个公式完全不需要提到 n；我们不必知道组合是从多少个数里抽出来的，就能知道它在字典序中的位置。

我们来写一个版本，把组合保存在列表里而不是 deque，因为这样可以方便地按下标直接访问：

清单 6.21 直接生成组合编号

```csharp
static class Extensions
{
    public static BigInteger GetCombNumber(this IList<int> comb)
    {
        BigInteger result = 0;
        int k = comb.Count;
        for (int i = 0; i < k; i += 1)
        	result += comb[i].Choose(i + 1);
        return result;
    }
}
```

如果我们枚举示例中的所有组合，就能看到每一个都生成了正确的组合编号：

```csharp
foreach (var c in Combinations1(6, 4))
Console.Write($"{c.GetCombNumber(),2}:{c.Concat()} ");
```

我们得到与之前相同的输出，但这次不需要递归、不需要弹出 deque，甚至不需要知道 n 的值：

```
0:0123 1:0124 2:0134 3:0234 4:1234 5:0125 6:0135 7:0235
8:1235 9:0145 10:0245 11:1245 12:0345 13:1345 14:2345
```

这个小方法的性能如何？我们不知道 n，但当然 n 不可能小于组合中的最大数字，所以我们就用它作为 n。我们会调用 Choose 共 k 次，而每次会做 k 次乘法和除法。BigInteger 的数学运算在最好情况下是 O(1)，最坏情况下是 O(lg n)。由于 k 最高可以达到 n，最坏情况就是 O(n^2 log n)，最好情况是 O(k^2)。同样地，如果我们必须处理很大的 n 和 k，用空间换时间并对 Choose 做记忆化缓存会很划算，从而加速计算。

能够在“由整数序列表示的组合”和“BigInteger 的组合编号”之间来回转换非常方便，但这里还有一个更深的数学事实。我们现在知道：对每个 k 和每个 p，都存在唯一一个由 k 个数 x0, x1, … xk-1 组成的组合，使得

```
p = (x0 C 1) + (x1 C 2) + … + (xk-1 C k)。
```

就像我们把数字分解为 n 个唯一的“阶乘进制”分量（每个排列对应一个分量）一样，我们也可以把任意数字 p 分解为 k 个唯一的“组合进制”分量（每个组合对应一个分量）。

> 历史注记
> 这种把整数分解为由 k 个元素构成的唯一和的表示方法，被称为“Macaulay 表示”，以纪念英国数学家 Francis Macaulay。我们在这里使用的应用——计算组合与其在按字典序排列的列表中的位置之间的映射——由美国数学家 D.H. Lehmer 发现。

## 总结

- 有限序列上的基本组合运算——笛卡尔积、排列枚举、组合枚举——通常不会由标准库直接提供，但它们对于生成测试用例以及许多其他实际应用都很有用。
- 笛卡尔积本质上就是隐藏起来的多重嵌套循环。我们可以通过写一个带有 2、3、4、… 层嵌套循环的小辅助方法来计算 2、3、4、… 个序列或集合的笛卡尔积。在末尾接一个投影函数而不是返回一个元组也非常实用。
- 要计算 n 个序列的笛卡尔积，而 n 只在运行时才知道时，我们可以写一个惰性方法，把一个嵌套查询对象聚合起来完成这项工作。
- 如果你想枚举一个包含重复元素的集合的排列，并且不介意直接对序列进行原地修改，那么 Pandita 的算法很有帮助。
- 用于枚举排列以及直接生成枚举中的第 p 个排列的算法有很多。按字典序枚举排列比使用 Fischer-Yates 洗牌方法枚举排列的代价更高。
- 还有一些更“异国情调”的排列生成顺序，例如几百年前敲钟人设计的“变钟”（change ringing）排列。
- 枚举组合的算法同样很多，也有直接生成第 p 个组合的方法。
- 组合数学的研究表明，整数中存在一些你此前可能没有注意到的结构。普通的十进制记法把 0 到 10^n -1 之间的数分解为 n 个数的和；我们也可以对 0 到 n! -1 之间的数进行类似分解，还可以对 0 到 (n C k) -1 之间的数进行分解（对任意 k 均成立）。这些分解与从 0 到 n-1 这些数字的排列与组合有着很强的关联。