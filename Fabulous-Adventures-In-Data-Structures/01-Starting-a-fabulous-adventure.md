# 开启一段奇妙的冒险

本章内容包括

- 探索是什么让某些算法和数据结构如此奇妙
- 定义数据结构、算法与复杂度
- 反转一个不可变链表

算法是一种解决问题的方式；数据结构是一种组织数据的方式。利用有组织的数据来解决问题正是计算机编程的核心，但是什么让它们“奇妙”呢？对我来说，它是以下因素的某种组合：

- **解决真实问题，但走一条不寻常的道路**。我学习本书中大多数算法和数据结构，是为了在现实世界里解决某些没有现成库可用的问题。例如，为了解决“这些代码变更中有哪些共同的编辑模式？”这个问题，我不得不学习“反统一算法(anti-unification algorithm)”。我通常是通过阅读研究论文来学习这些对我来说全新的概念，因为它们并不在我书架上那些本科教材中出现。
- **获得反直觉的结果**。实现撤销-重做(undo-redo)逻辑以管理应用中的数据变更，最好的办法之一，竟然是将状态存储在不可变的数据结构中。默认拥抱不可变数据结构改变了我思考代码解决问题的方式。与此同时，它也让我的代码更健壮、更少 bug、也更容易推理。本书第一部分会介绍不可变数据结构。
- **将同一个解决方案应用到多个领域。**回溯（backtracking）——即深度优先搜索——在树中查找元素是很自然的事。但发现类似的回溯搜索既能给地图国家上色，又能解决数独谜题，这就有点令人惊讶了。更奇妙的是，它还构成了编辑器中自动美化代码的算法基础。看到这些联系改变了我的问题思考方式，让我愿意把特定问题视为可解通用问题的特殊情形。本书中间部分会介绍这类算法。
- **强调意义，而不是机制。**很多代码看起来像是在更新一堆变量、运行循环、处理异常等等，但那不是它的目的，那只是为达成目的而使用的机制。如果代码文本使用的是它正在解决的问题固有的概念，那么代码就会更容易阅读、编写、维护和推理。本书的最后部分将特别探讨如何不仅实现概率相关问题的算法，还能写出在更高抽象层面上可读的代码。
- **像魔术一样。**Hughes 列表实际上是一个实现了链表特性的二叉树数据结构，但乍一看似乎完全不包含数据；这怎么可能？揭开幕后看看这项魔术是如何完成的，可以洞见编译器如何替你生成隐藏的数据结构。充分利用语言特性。现代编程语言（如 C#）的“表面积”巨大，而绝大多数时候我们只使用了其中的一小部分。我一直到实现了一个用 finger tree 构建的不可变双端队列，并看到它如何通过一种模板语言中不可能实现的递归泛型类型来确保类型安全，才真正理解了 C# 泛型与 C++ 模板的差异。
- **挑战框架，改变游戏。**有时我们专注于挤出微小的改进，但其实可以退后一步思考，是否有完全不同的方式来解决问题。对我来说最好的例子是 Gosper 的 HashLife 算法，用于运行元胞自动机。通过将一个位网格重新想象为不可变的四叉树，而不是可变数组，我们能够获得看似不可能的性能提升。
- **与理论建立联系。**你不需要了解恒星物理就能造望远镜，也不需要懂范畴论就能写程序。话虽如此，学习函数、可空值类型、任务、序列和随机数生成器这些看似不同的数据类型如何共享底层模式，既令人着迷，也让人获益良多。
- **享受乐趣！**编程从字面上就是一种创造行为。你想到机器可以如何解决问题，你把你的解决方案精确地输入，然后这个抽象的想法在片刻之后就成为一个真实的、能解决问题的机器。从我九岁在小学图书馆用 Commodore PET 编程开始，它一直是我快乐的源泉。那种创造出一个真正能工作的东西的满足感从未消失。实现本书里的算法和数据结构，是我工作中最快乐的体验之一。

在本科计算机科学课程中，你会学到很多优秀的书籍所涵盖的内容：如何平衡一棵树、如何排序一个数组、如何构建一个优先队列。我们会从一些基础概念开始，比如栈和队列，但会很快越过这些，进入那些学校里通常不讲、类库里也不常见、却依然十分实用的奇妙算法和数据结构。在工业界工作的那些年，我不得不不断为自己的工具箱添置新工具，而我希望这本书也能为你做到这一点。但我更大的目标，是让你获得同样的那种迷醉、快乐与发现的感觉。并且，也许还能在这个过程中改变你思考编程的方式。

## 定义数据结构，算法和复杂度

让我们先简要定义一些关键概念。

**数据结构（data structure）** 就如其名：一种以有组织、有结构的方式存储信息的方法。我们会像你所预期的那样，使用 C# 的数组、类、结构体、记录和接口来创建数据结构。

**算法（algorithm）** 是一系列有限的步骤，执行后便能解决某个问题。算法不一定是确定性的；许多算法都包含“选择一个随机数”这样的操作。算法也不一定必须由计算机执行。即使算法的步骤数量很大，它的概念也不一定复杂。例如：“估计如果某用户看了这些广告的平均收益，然后展示预期收益最高的广告”这件事涉及大量数学计算，但并不难理解。

> **趣味知识**
>
> “algorithm（算法）”这个词来源于 9 世纪波斯数学家 Al-Khwarizmi 的名字，他的工作也为我们带来了“algebra（代数）”这个词。

**算法的复杂度（complexity）** 描述的是：算法所解决问题的规模，与解决该规模问题所需的代价之间的关系。代价用时间或内存等资源来衡量。让我们依次讨论这些概念。

描述规模与代价关系的标准方法是 **“大 O 表示法（big O notation）”**，由德国数学家 Bachmann 和 Landau 于 19 世纪末发明。以下是一些常见的复杂度，从低到高排列，并附有示例：

- **O(1)** “常数时间”算法的代价不会因问题规模增大而变化。例如：“这个数组的第一个值是什么？”无论数组多大，代价都相同。
- **O(log n)** “对数级”算法的代价在问题规模翻倍时只增加一小步。例如，如果我们有 n 个对象，每个都需一个唯一的短字符串标识符，那么字符串的长度将与 log n 成正比。对数算法的增长速度非常慢，在实际程序中几乎不会成为性能瓶颈。（对数的底通常视为 2，但选择什么底本质上无关紧要。）
- **O(n)** “线性”算法在问题规模翻倍时，代价也翻倍。例如，求 n 个 32 位整数的和，当 n 翻倍时，总时间也会翻倍。线性算法的成本会随着问题规模变大而开始被用户注意到，但用户通常能接受：表格大小翻倍，总和所需时间也翻倍。
- **O(n log n)** “准线性（quasilinear）”算法的代价增长比线性更快，但比二次慢得多。“对 n 个字符串排序”通常用准线性时间算法实现。列表长度翻倍时，排序耗时会比两倍稍多，但远不到四倍。
- **O(n²)** “二次（quadratic）”算法在问题规模翻倍时，代价变为原来的四倍。朴素地把 n 个小字符串拼接成一个大字符串的算法，在时间和内存上都是二次复杂度；类似这些本可优化却未优化的算法通常被称作“意外的二次算法（accidentally quadratic）”。在实践中，如果你希望程序能扩展到更大的规模，就应避免二次或更差的算法；用户会注意到，当他们把问题规模增加 10 倍时，代价却增加了 100 倍！
- **O(2ⁿ)** “指数级（exponential）”和 **O(n!)** “阶乘级（factorial）”算法的代价增长极快，以至于除了微小规模的问题外都难以处理。那些所有算法都至少是指数级的问题被称为“难处理（intractable）”。例如：“列出含 n 张牌的一副牌的所有排列方式”就是难处理的问题。

图 1.1 展示了这些函数的增长，以及它们“陡峭程度”的变化。对数函数随着 n 增加反而越不陡峭；线性函数陡峭程度恒定；准线性函数逐渐变陡；二次和指数函数陡峭程度迅速增加。

![](asserts/01-01.png)

图 1.1 一张对比对数型、线性、准线性、二次和指数增长曲线的图。对数增长最平缓，增长极慢；指数增长最快。

问题的规模通常是直观明了的；如果一个算法处理的是一个集合，我们一般会使用集合中元素的数量作为规模衡量。如果规模的度量方式并不明显，就必须明确指出。例如，许多关于树的算法是 O(n)，但这里的 n 指的是**树的高度**，而不是**树的节点数**；这一点必须说明清楚。

开发者有时会犯一个坏习惯，只从“时间”角度考虑代价。务必要记住两件事。第一，我们经常关心非时间成本，例如内存或其他系统资源。第二，“时间”本身也有很多种类：最佳情况时间、平均情况时间、最坏情况时间，这些都相关，并且正如我们将在下一章看到的，可能非常微妙。如果一个算法的复杂度可能存在歧义，我会尽量指出其对应的成本类型。

> **警告**
>
> 一个具有更好渐近性能的算法，不一定是更好的选择。
>  当我在 Visual Basic 团队实习时，我注意到实现 VB 字符串搜索方法的朴素算法在最坏情况下是 O(n²)。我在学校学过这个问题是可以用线性时间解决的，那为什么还要使用“更差”的算法呢？该方法的作者耐心地向我解释：可扩展性只有在问题变大时才重要。Visual Basic 程序员并不会在百万字符的字符串中搜索几千字母的模式；他们通常做的是在短字符串中查找空格或逗号。虽然朴素算法的**最坏情况**很糟糕，但在**典型输入**上，它快得惊人。

## 不可变链表集合

作为热身练习，我们先来写一个不可变的列表类，并实现把它反转的代码。这也是一个顺便复习性能分析的好机会。现在，让我们先用递归的方式给这个数据结构下个定义：“链表”要么是空的，要么是一个值加上一个“尾部”链表。关于为什么不可变性很重要、很有用，我们会在下一章详细讨论。

清单 1.1 一个不可变链表

```csharp
sealed record LinkedList<T>(T? Value, LinkedList<T>? Tail)
{
    public static LinkedList<T> Empty = new (default, null); // #A
    public LinkedList<T> Push(T value) => new (value, this);
    public bool IsEmpty => this == Empty; // #B
    public override string ToString()
    {
        var s = "";
        for (var list = this; !list.IsEmpty; list = list.Tail!)
            s += list.Value + " "; // #C
        return s;
    }
}
```

（如果你对 C# 记录类（record）或用 `?` 和 `!` 来标记可空性与非空性不熟悉，请参见附录 A。）

在短短几行代码里，我已经做出了一些重要的设计决策；你能看出其中比较值得怀疑的地方吗？我们一起来看看其中的一些优点和不足。

- record 类的参数默认是只读的，这使得 record 非常适合用来简洁地定义不可变类型。
- 在较老的语言（比如 C）中，我们通常用一个 null 引用来表示空链表；但在面向对象语言中，这种选择会带来问题。空链表应该是一个合法对象，我们应该能在它上面调用方法。我这里选择用“值和尾部都为 null 的链表”来表示空链表。这依然是容易出错的！例如，完全可以构造出一个“非空”的链表，但它的 Tail 却是无效的；理想情况下，应该让处于这种无效状态的对象变得很难甚至不可能被创建出来。我们会在下一章讨论一种更好的方式来构造空链表。
- `Push` 和 `IsEmpty` 这两个成员并不是绝对必要的，但它们为这种类型的使用者提供了更愉悦、更易读的语法。

### 到目前为止的性能表现

在我们反转链表之前，先来看看目前这个实现的性能特性如何。

- 用 `new` 或 `Push` 创建一个新的链表，在时间和额外内存上的复杂度都是 O(1)，因此，用这种方式创建一个包含 n 个元素的链表，在时间和内存上的复杂度都是 O(n)，正如我们所预期的那样。

- 你有没有注意到 `IsEmpty` 里有个小问题？如果你不熟悉 record 类型，很可能会错过这一点：record 会自动重写相等运算符。这个实现会先检查 `this` 是否与 `Empty` 在引用上相等。然后，它会运行一大堆代码，最终调用 `int` 的相等运算符；如果我们正在检查的这个链表刚好以 0 开头，那么在最终对 `this.Tail` 和 `Empty.Tail` 做引用比较之前，我们还会多跑一堆代码。代码本身没错，复杂度也是 O(1)，但与更好的实现 `IsEmpty => Tail == null` 相比，它要昂贵得多。

- 说到这里：我自己经常会忘记去分析那些“自动生成”的代码的性能，但这些代码确实存在，而且用户是可以调用到的。record 类会免费获得编译器生成的 `IEquatable<T>` 实现、重载的相等运算符等等。这些生成的代码针对的是链表的“值相等”，而不是“引用相等”。对链表做值相等比较，其复杂度是 O(n)，其中 n 是两条链表在表头开始相等的元素个数。

  不过还有个更糟糕的问题：由于这个数据结构是递归定义的，相等运算符也是递归的。对两条很长的链表做相等检查时，可能会导致调用栈溢出！如果我们确实想要对链表进行值相等比较，就应该提供非递归的自定义实现。

- 你大概也注意到了，朴素实现的 `ToString` 在字符串拼接上有一个经典的“意外二次” O(n²) 问题。每次我们把一个字符串追加到累加器上时，之前的字符串都会被复制到新的字符串中，而旧字符串则变成垃圾。这个实现的时间和额外内存复杂度都是 O(n²)，应该用一个基于 `StringBuilder` 的 O(n) 实现来替代。

即便是小而看似微不足道的代码片段，也可能隐藏着性能问题。

### 反转一个不可变链表

在前言中，我提到过自己 1996 年在微软面试时的经历：第一位面试官就让我反转一条链表。我当时给出的解决方案，其本质等同于我们可以为上面的类添加的这个方法：

```csharp
public LinkedList<T> Reverse()
{
    var result = Empty;
    for (var list = this; !list.IsEmpty; list = list.Tail!)
        result = result.Push(list.Value!);
    return result;
}
```

这段代码非常直观！创建一个空链表，然后逐个遍历当前链表，把每个元素都 push 进那个空链表，最终就生成了一条包含相同元素但顺序相反的新不可变链表。由于链表是不可变的，原链表保持不变。如果我们写几行测试代码，例如：

```csharp
var list =
    LinkedList<int>.Empty.Push(10).Push(20)
    .Push(30).Push(40).Push(50);
var list2 = list.Reverse();
Console.WriteLine(list);
Console.WriteLine(list2);
```

……输出会如你所料：

```
50 40 30 20 10
10 20 30 40 50
```

`Reverse` 方法的性能也很容易看出：它在 **时间** 和 **额外内存** 上的复杂度都是 **O(n)**。

## 前方的挑战

我们这段奇妙的冒险，将从一些大家都熟悉的传统数据结构开始——栈、队列、树——但每一种都会带着一点新意。我们将讨论持久化与记忆化带来的空间与时间压缩、优雅的列表重排算法，以及一种近乎离奇、看似能在常数时间内反转链表的方法。

接下来，我们会探索一些我在开发者工具领域工作时遇到的算法。我们将研究用于图着色与代码排版的回溯搜索算法，并学习统一（unification）与反统一（anti-unification）在树结构上的妙用与优势。

旅程的最后一段，将开始构建一套工具箱，供需要处理概率、随机性和统计推断的开发者使用。贝叶斯推断在许多行业中变得越来越重要，但传统课程对此关注不足，许多语言内置的随机库也无法满足需求。当我在工作中不得不匆忙学习统计推断时，从零开始构建一小套工具库极大地帮助我整理思路、理解基础原理，并写出更好的代码。

旅途中，我们还会安排几段简短的插曲，浅尝一下范畴论这些“数学胡言乱语”与我们日常使用的常见数据类型之间的深层理论联系。

本书的实现语言是 C#，但几乎所有内容都同样适用于其他现代主流面向对象语言。不熟悉 C# 的 C++、Java 或 Python 开发者也能理解这些代码。

在下一章，我们将更深入地探讨不可变链表以及我们可以用它们做什么。我们会基于本章看到的不可变链表构建一些稍微复杂一些的数据结构，并且看看一种极其怪异的链表表示方法，它会让传统的性能分析完全颠倒。

## 小结

关于列表、树、哈希表等标准数据结构，以及对它们进行排序和搜索的算法，已有许多书籍，也有大量现成的类库实现。本书将关注那些不太常见、更偏离主流路径的数据结构和算法——这些都是我在职业生涯中不得不学习的内容。我选择的是那些我认为最奇妙的主题：反直觉的、近乎魔术的、或能突破语言边界的。

本书中的几乎所有主题，都是我在工作中遇到难题、需要向工具箱中添加新工具时才不得不去学习的。我希望这本书能让你免于像我一样去啃那些晦涩难懂的论文——如果你也遇到了类似的问题。

不过，比这些更重要的是，这些奇妙的探索让我更加尊敬计算机程序员所能做到的事情。它们改变了我对编程这门手艺的看法。而且，我在这个过程中玩得非常开心！希望你也一样。

渐近复杂度告诉我们：当问题规模增长时，一个解决方案的表现如何。若希望程序能扩展到处理大型问题，我们通常希望算法的复杂度优于二次复杂度。

复杂度分析可能很微妙。务必记住：时间并不是唯一重要的资源；用户可能会关心内存、甚至会思考避免最坏情况是否比追求更好的平均性能更重要。

如果问题始终很小，那么渐近复杂度就不那么重要了。

反转不可变链表是非常直接的！下一章我们会看看其他类型的不可变链表。