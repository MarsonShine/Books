# Redis性能探秘

在我们查询redis相关资料的时候，一定会看到的一句话是：redis 用的但是单线程，为什么还这么快？

现在让我们来探究一下redis到底是不是真的单线程的？

## Redis单线程为什么还这么快？

首先我们要明确的是，redis 并不是只有单线程；**只有在数据读写和网络I/O操作才是单线程的**。而其它功能特性方面，redis采用的还是多线程方式，如释放内存、内存持久化、异步相关的操作（异步删除、集群数据同步等）都是由额外的进程/线程执行的。

那么 redis 为什么会选择用单线程模型来处理 redis 的读写能力？

因为如果采用多线程，势必就会增加对公共资源竞争的场景，这样就会导致大量的并发操作，就会把大量的资源都用在数据并发的控制上。而如果采用的是单线程的话，就完全不用考虑这些问题。

那么单线程为什么会这么快？每秒达到数十万的操作数。

首先 redis 采用的是基于**网络I/O的多路复用**技术，最大化的提高了单线程对 socket 的并发处理能力（一个 socket 就能处理多个客户端），在 linux 的多路复用的支持下（select/epoll 函数）在客户端建立连接/接收的时候（accep/reciv 函数）会**注册对应的回调事件**；一旦内核发成之前的连接/接收操作完成了就会触发之前注册的**回调函数进入到一个事件队列**中，而 **redis 主线程会一直对这个事件队列进行处理**（单线程、事件函数回调进入事件队列，这个过程是不是很像 Javascript 的事件触发过程）。

因为 redis 的数据读写和I/O操作是单线程，所以我们一定要注意以下两类场景：

1. 因为读写时钟是单线程的，所以当客户端进行的读写操作是个非常耗时的操作时，就会阻塞整个 redis，从而整体的性能就会大打折扣（如 AOF 刷盘、大批脸数据读写、范围查询、缓存大量失效）；
2. 超量的并发量，超过了单线程能处理的最大量（到达了单线程的瓶颈）。这个时候 **redis6.0 推出了多线程模型**来处理这种情况。

> 注意：这里的多线程模型仅仅只是在客户端的读写是并行的，而 redis 服务器真正的读写命令还是单线程的。

还有最后一点，Redis大部分操作的都是内存部分，很少的磁盘操作。

## Redis如何保证数据不会丢失？

已经使用过 redis 的朋友估计都知道是通过 AOF 日志来实现的。那么 redis 是不是一定就能保证数据 100% 数据不丢失呢？AOF 日志到底做了什么？

首先让我们思考一下 MYSQL 是如何保证数据不丢失的？

MYSQL 是通过[预写日志（WAL）](https://github.com/MarsonShine/MS.Microservice/blob/master/docs/patterns-of-distributed-systems/Write-Ahead-Log.md)再配合 binlog 以及 redolog 来保证数据不会丢失的。而 redis 采用的是**写后日志**，即先是执行 redis 命令，然后在写入日志。

为什么？

因为 redis 记录的是 redis 操作命令（如 set hi marsonshine）。如果 redis 同样是采用 WAL 的话，那么当写入日志后，redis 宕机了，但是由于日志已经写入了，恢复的时候就会恢复一个实际没有发生的操作，导致数据不一致性。而如果是写后日志，就会有以下好处：

- 因为日志操作是执行 redis 后，所以完全不用验证记录的命令是否正确。
- 因为能避免阻塞 redis 的读写能力，因为日志这种磁盘操作相对于内存操作来说是非常耗时的，所以写后日志是不会影响 redis 命令执行的。

那么写后日志就会保证数据不丢失么？

并不是，因为在执行完 redis 命令之后，落盘操作之前发生宕机了，那么一样也会丢失数据，导致数据不一致。而 redis 给出的方案就是指定三种级别，来合理的在数据安全和性能方面做个平衡：

- Always，命令执行完就会立即执行日志，这样能最大化的减少数据丢失的可能，但是性能最低，因为每次命令都会进行一次磁盘操作。
- EverySec，redis 的每个命令的日志都会先写入内存的缓冲区中，每秒把缓存中的所有日志内容写入磁盘
- No，redis 的每个命令的日志都会先写入内存的缓冲区中，什么时候同步到磁盘依赖操作系统，这样性能最高。

所以我们要知道，redis 并不能 100% 保证数据一定不会丢失，所以把 redis 当作数据库使用的一定要慎重。

## 生成AOF文件越来越大怎么办？

生成的AOF文件越来越大会有什么影响？文件越大，内容越多，所以恢复的速度也就越慢。因为I/O处理是单线程的，所以这样也会影响整体 redis 的使用。

这个时候就可以采用 AOF 重写机制来减小文件的大小。

AOF 重写：当生成的 AOF 文件达到一定值时就会触发重写机制。**这个过程时通过主进程 fork 子进程执行的，所以 AOF 重写不会阻塞 redis 主线程**，AOF 重写就会重新生成一个新的 AOF 文件，都生成新的文件了怎么会减少文件大小呢？因为原来的 AOF 文件内部包含大量的相同 key 的重复命令操作，而重写时只需要记录最新一个命令即可。只要重写结束就会将原来的 AOF 文件删除，这样就大大减小了文件的大小了。

这里还有一个隐含的问题：AOF 是通过 fork 另一个进程来完成的，redis 此时还可以正常读写数据。那么当 redis 有新的命令进来时该怎么办呢？

1. 当是读取操作时，两边进程是互不影响的。
2. 当是主线程写操作时，将对应的数据拷贝出来，将对应的修改放到新的缓冲区中，这样重写日志时，即使宕机了也可以恢复数据。

AOF 恢复总是要扫描文件中的每一个命令，这样速度肯定是比较慢的。这个时候其实可以采用另一种恢复数据的方式——内存快找模式（RDB）

### 内存快照模式（RDB）

内存快照模式：通过 `bgsave()` fork 子进程进行 RDB 快照。当主线程知识读取的时候，这两个进程是互不影响的，一旦主线程执行写操作，主线程就会触发**写时复制（cow）**操作，把目标数据生成一个拷贝副本，然后子进程就把这个副本的数据写入了 RDB 文件。RDB 操作是个非常耗时的操作，因为它执行的全量复制操作，如果为了不丢失数据，将RDB执行的时间间隔设置的非常短，这样反而不好。因为：

1. 本身快照这个操作非常耗时，会占用 redis 服务的宽带
2. fork 出来的字进程虽然不阻塞主线程，但是在执行 fork 本身的时候是会阻塞主进程的（要拷贝主进程的必要的数据结构与内存信息，如页表等）

redis4.0 提供了一种解决方案：在两个时间间隔内采用 AOF 的方式记录这段变换。这样就能获得一个数据与性能的平衡点。