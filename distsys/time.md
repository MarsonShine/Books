# 时序

什么是顺序？为什么它很重要

什么叫“什么是顺序”？

我的意思是，我们为什么如此执着于顺序？我们为什么关心 A 是否发生在 B 之前？为什么我们不关心其他属性，比如“颜色”？

好吧，我疯狂的朋友，让我们回到分布式系统的定义上来回答这个问题。

你可能还记得，我曾将分布式编程描述为一门艺术，即使用多台计算机解决在单台计算机上可以解决的相同问题。

事实上，这正是对顺序的痴迷的核心所在。任何一次只能做一件事的系统，都会产生一个总的操作顺序。就像人们通过一扇门一样，每个操作都有明确的前置和后继。这基本上就是我们一直努力维护的编程模型。

传统模式是：一个程序、一个进程、一个内存空间在一个 CPU 上运行。操作系统抽象掉了可能存在多个 CPU 和多个程序的事实，也抽象掉了计算机上的内存实际上是由许多程序共享的事实。我并不是说线程编程和面向事件编程不存在，只是它们是 “一个/一个/一个”模型之上的特殊抽象。程序的编写是为了以有序的方式执行：从顶层开始，然后向下执行。

顺序作为一种属性受到如此多的关注，是因为定义“正确性”的最简单方法就是说 “它能像在单台机器上一样运行”。这通常意味着：a）我们运行相同的操作；b）我们以相同的顺序运行这些操作--即使有多台机器。

分布式系统能保持顺序（为单个系统定义的顺序）的好处在于它们是通用的。你不需要关心操作是什么，因为它们的执行方式与单台机器上的完全一样。这一点非常好，因为你知道，无论操作是什么，你都可以使用同一个系统。

实际上，分布式程序运行在多个节点上，有多个 CPU 和多个操作流。你仍然可以分配一个总顺序，但这需要精确的时钟或某种形式的通信。你可以用一个完全精确的时钟为每个操作打上时间戳，然后用它来计算总顺序。或者你也可以使用某种通信系统来分配总顺序中的顺序号。

## 总有序和局部有序

分布式系统的自然状态是[局部顺序](https://en.wikipedia.org/wiki/Partially_ordered_set)。网络和独立节点都不保证相对顺序；但在每个节点上，你都能观察到局部顺序。

[总顺序](https://en.wikipedia.org/wiki/Total_order)是一种二元关系，它定义了某个集合中每个元素的顺序。

当两个不同元素中的一个大于另一个时，这两个元素就具有可比性。在部分有序集合中，有些元素对不具有可比性，因此部分有序并不指定每个项目的精确顺序。

总排序和部分排序都具有[传递性](https://en.wikipedia.org/wiki/Transitive_relation)和[反对称性](https://en.wikipedia.org/wiki/Antisymmetric_relation)。对于 X 中的所有 a、b 和 c，以下陈述在总排序和部分排序中都成立：

```
If a ≤ b and b ≤ a then a = b (antisymmetry);
If a ≤ b and b ≤ c then a ≤ c (transitivity);
```

但是，总有序就是[有序](https://en.wikipedia.org/wiki/Total_relation)的：

```
a ≤ b or b ≤ a (totality) for all a, b in X
```

而部分有序只有[反身性](https://en.wikipedia.org/wiki/Reflexive_relation)：

```
a ≤ a (reflexivity) for all a in X
```

请注意，总体性意味着反身性；因此，部分有序是总体有序的弱变体。对于部分有序中的某些元素来说，总体性属性并不成立--换句话说，某些元素并不具有可比性。

Git 分支就是部分顺序的一个例子。大家可能都知道，git 修订控制系统允许从一个基本分支（如主分支）创建多个分支。每个分支都代表了基于共同祖先的源代码修改历史：

```
[ branch A (1,2,0)]  [ master (3,0,0) ]  [ branch B (1,0,2) ]
[ branch A (1,1,0)]  [ master (2,0,0) ]  [ branch B (1,0,1) ]
                  \  [ master (1,0,0) ]  /
```

分支 A 和 B 来自一个共同的祖先，但它们之间并没有明确的顺序：它们代表了不同的历史，如果不进行额外的工作（合并），就无法还原成单一的线性历史。当然，你也可以将所有提交按任意顺序排列（例如，先按祖先排序，然后通过先 A 后 B 或先 B 后 A 的方式打破联系），但这样做会在不存在总顺序的情况下强加一个总顺序，从而丢失信息。

在一个由单个节点组成的系统中，总顺序是必然出现的：在单个程序中，指令以特定的、可观察到的顺序执行，信息以特定的、可观察到的顺序处理。我们已经开始依赖这种总体顺序--它使程序的执行具有可预测性。这种顺序可以在分布式系统中保持，但代价是：通信费用昂贵，时间同步困难且脆弱。

## 为什么是时间？

时间是顺序的源泉--它让我们定义操作的顺序--巧合的是，它也有人们能够理解的解释（一秒、一分钟、一天等等）。

从某种意义上说，时间就像其他整数计数器一样。只是因为它足够重要，所以大多数计算机都有一个专用的时间传感器，也称为时钟。它如此重要，以至于我们想出了如何利用一些不完美的物理系统（从蜡烛到铯原子）来合成同一个计数器的近似值。我所说的“合成”，是指我们可以通过某种物理特性，在物理上遥远的地方近似得到整数计数器的值，而无需直接进行通信。

时间戳实际上是一种速记值，用来表示从宇宙开始到当前时刻的世界状态--如果某件事发生在某个特定的时间戳，那么它就有可能受到在它之前发生的所有事情的影响。这种想法可以推广到因果时钟中，明确追踪原因（依赖关系），而不是简单地假设在时间戳之前发生的所有事情都是相关的。当然，通常的假设是，我们应该只关心特定系统的状态，而不是整个世界。

假设时间在任何地方都以相同的速度流逝--这是个很大的假设，我稍后再谈--那么在程序中使用时间和时间戳时，有几种有用的解释。这三种解释是

- 顺序
- 持续时间
- 解释（Interpretation）

**顺序**。当我说时间是顺序的源泉时，我的意思是：

- 我们可以为无序事件附加时间戳，使其有序化
- 我们可以使用时间戳来强制执行操作或信息传递的特定顺序（例如，如果操作不按顺序到达，则延迟该操作）。
- 我们可以使用时间戳的值来确定某件事情是否按时间顺序发生在其他事情之前

**解释**--时间是一个普遍可比的值。时间戳的绝对值可以解释为日期，这对人们很有用。如果从日志文件中获得停机时间的时间戳，就可以知道是上周六，当时有雷雨。

**持续时间**--以时间衡量的持续时间与现实世界有一定关系。算法一般不会在意时钟的绝对值或将其解释为日期，但它们可能会使用持续时间来做出一些判断。特别是，花费在等待上的时间可以提供一些线索，说明系统是被分割了，还是仅仅出现了高延迟。

就其本质而言，分布式系统的各组成部分并不能以可预测的方式运行。它们不能保证任何特定的顺序、前进速度或无延迟。每个节点都有一些本地顺序--因为执行是（大致）按顺序进行的--但这些本地顺序是相互独立的。

强加（或假设）顺序是减少可能执行和可能发生的空间的一种方法。当事情可能以任何顺序发生时，人类就很难对事情进行推理--要考虑的排列组合实在是太多了。

## 各地的时间进度是否相同？

我们每个人都根据自己的个人经验对时间有一个直观的概念。不幸的是，这种直观的时间概念让我们更容易想象出整体顺序，而不是局部顺序。我们更容易想象出事情一个接一个发生的顺序，而不是同时发生的顺序。推理单一顺序的信息比推理以不同顺序和不同延迟到达的信息更容易。

不过，在实施分布式系统时，我们要避免对时间和顺序做出强烈的假设，因为假设越强烈，系统就越容易受到“时间传感器”（或机载时钟）问题的影响。此外，强加顺序也是有代价的。我们能容忍的时间非确定性越多，就越能利用分布式计算的优势。

对于“时间是否在任何地方都以相同的速度流逝”这一问题，有三种常见的答案。它们是

- “全球时钟”：是
- “本地时钟”：不是，但是
- “没有时钟”：不是！

这些假设大致对应于我在第二章中提到的三种时序假设：同步系统模型有一个全局时钟，部分同步模型有一个本地时钟，而在异步系统模型中，根本不能使用时钟。让我们来详细了解一下这些假设。

### 采用“全局时钟”假设

全球时钟假设是，有一个精确度极高的全局时钟，每个人都可以使用这个时钟。这就是我们思考时间的方式，因为在人际交往中，时间上的微小差异并不重要。

![](./asserts/global-clock.png)

全局时钟基本上是一个总顺序源（所有节点上每个操作的精确顺序，即使这些节点从未进行过通信）。

然而，这是一种理想化的世界观：在现实中，时钟同步只能达到有限的精确度。这受到以下因素的限制：商品计算机的时钟精度不够；使用 [NTP](https://en.wikipedia.org/wiki/Network_Time_Protocol) 等时钟同步协议时的延迟；以及[时空性质](https://en.wikipedia.org/wiki/Time_dilation)的根本原因。

假设分布式节点上的时钟完全同步，意味着假设时钟以相同的值开始，并且永远不会偏移。这是一个很好的假设，因为你可以随意使用时间戳来确定全局总顺序（受时钟漂移而非延迟的约束），但这是一个非同小可的操作挑战，也是异常的潜在来源。在许多不同的情况下，一个简单的故障，如用户不小心更改了一台机器的本地时间，或一台过时的机器加入集群，或同步时钟以略微不同的速率漂移等，都可能导致难以追踪的异常。

尽管如此，现实世界中还是有一些系统做出了这样的假设。Facebook 的 [Cassandra](https://en.wikipedia.org/wiki/Apache_Cassandra) 就是一个假设时钟同步的系统。它使用时间戳来解决写入之间的冲突--时间戳较新的写入获胜。这意味着，如果时钟漂移，新数据可能会被忽略或被旧数据覆盖；同样，这也是一个操作上的挑战（据我所知，人们也非常清楚这一点）。另一个有趣的例子是谷歌的 [Spanner](https://research.google.com/archive/spanner.html)：这篇论文介绍了他们的 TrueTime API，它可以同步时间，也可以估计最坏情况下的时钟漂移。

### 采用“本地时钟”假设