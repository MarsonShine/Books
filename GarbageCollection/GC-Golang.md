# Golang 的垃圾回收机制

存储数据的地方只有两个地方：堆（Heap）和栈（Stack）。而栈不受垃圾回收器管理，是编译器和垃圾回收算法工程师共同管理。

从为对象分配内存到收集垃圾对象最后清理垃圾，涉及到 Go 语言的三个核心对象：

- 用户程序（Mutator）
- 内存分配器（Allocator）
- 收集器（Collector）

整个过程：当用户程序运行时需要申请占用内存时，就会向内存分配器申请内存，而后者会负责从堆中初始化对应的内存空间。用完之后就需要将不要用的内存对象（垃圾对象）由收集器扫描出来并执行清理操作。

## 分配内存

Go 将所有对象分为三个类型，**内存分配器根据对象大小的不同执行不同的分配策略**：

- 微对象：(0，16)；内存分配器会优先使用微型分配器，然后尝试线程缓存、中心缓存最后是页缓存即堆内存分配。
- 小对象：[16B，32KB]，优先尝试线程缓存、中心缓存最后堆内存分配
- 大对象：(32KB，+∞)，直接再堆上分配内存

分配方式有两种：

- **线性内存分配**：这种方式内部可以想象成一个数组，用户程序申请多少尺寸的内存，这个内部数组指针就便宜对应的大小即可。速度很快，但是会产生严重的内存碎片问题。因为是内存连续分布的，当已经分配过的内存被回收之后，是不会被重复利用的。所以这个时候就得靠垃圾回收算法来解决这种问题。**这个时候就要用到标记删除算法中的内存压缩，要么就是复制回收垃圾算法中重新开辟一个连续的内存，将没有被回收的对象依次拷贝过去，又或是分代垃圾回收算法等。**

  > 关于标记清除/压缩、复制回收、分代垃圾回收等 GC 算法之后找个时间在谈

- **空闲链表分配**：顾名思义就是通过链表结构的方式，所以分配对象的时候就得从链表头部一次编译找到对应的内存区域分配。所以它相较于先行内存分配来说效率是比较慢的，但是它没有前者那么明显的内存碎片的问题。并且 Go 团队在此基础之上进行了优化，**将一整块内存分割成了由 4、8、16、32 字节的内存块组成的链表**，这样它就能减少遍历的次数从而提高了内存分配效率

在分配内存的过程中，Go 还采用了**多级缓存**的概念。从每个处理的线程开始，从上往下依次是**线程缓存、中心缓存（Central Cache）、页堆（Page Heap）**。这跟 CPU 的多级缓存是一致的。每个线程有自己独立的缓存空间，减少了并发的可能，当对象比较大时，线程缓存装不下就去中心缓存查询，再没有就直接找页堆查询（页堆一般放的都是大对象）

与操作系统一样，采用了虚拟内存映射的设计方式。原来是采用连续分布的虚拟内存布局，初始化整片虚拟内存区域，其结构由三个组成：

- spans：存储内存管理单元的地址指针，每个内存管理单元会管理几页的空间，默认大小 8 KB
- bitmap：这个是标识位，用来标识 arena 区域具体哪些区域是分配对象
- arena：真正的数据初始化分配的堆区，同样 8K 一页。

由于连续的内存布局浪费空间严重，于是就改成了稀疏的内存布局，spans, bitmap 还是一样，取消 arena 增加了 `zeroedBase ` 指针指向内存的基地址。

Go 语言整体内存布局图如下：

![](./asserts/go-memory-layout.png)

​																					(上图出自：《Go 语言设计与实现》——内存管理组件)

内存管理单元有一个功能就是设置内存区域的状态：

- 再垃圾回收任意阶段，状态 mSpanFree -> mSpanInUse / mSpanManual
- 清除阶段，可能从 mSpanInUse / mSpanManual -> mSpanFree
- 标记阶段，不能从 mSpanInUse / mSpanManual -> mSpanFree

要注意的时候，在修改状态的操作期间必须是同步（原子性）的，防止垃圾回收造成的线程竞争问题。

