CLR 中的堆栈遍历
===

作者：Rudi Martin（[@Rudi-Martin](https://github.com/Rudi-Martin)）- 2008

CLR 大量使用一种称为堆栈遍历（stack walking，或 stack crawling）的技术。它会迭代某个线程的调用帧（call frame）序列，从最新的帧（线程当前正在执行的函数）一直往下走到堆栈底部。

运行时会出于多种目的进行堆栈遍历：

- 运行时在垃圾回收期间会遍历所有线程的堆栈，寻找托管根（即托管方法栈帧中的局部变量，它们持有对象引用，需要向 GC 报告，以便对象保持存活，并且在 GC 决定压缩堆时可能需要跟踪它们的移动）。
- 在某些平台上，堆栈遍历器会用于异常处理（第一遍寻找处理器，第二遍回退/展开堆栈）。
- 调试器在生成托管堆栈跟踪（managed stack trace）时会使用该功能。
- 各种杂项方法（通常靠近某些公开的托管 API）会执行一次堆栈遍历，以获取其调用方的信息（例如该调用方的方法、类或程序集）。

# 堆栈模型

这里我们定义一些常见术语，并描述线程堆栈的典型布局。

从逻辑上讲，堆栈被划分为若干个 _帧（frame）_。每个帧表示某个函数（托管或非托管）——该函数要么正在执行，要么调用了另一个函数并在等待其返回。一个帧包含该函数这次调用所需的状态。通常包括：局部变量空间、为调用另一个函数而压入的参数、保存的调用方寄存器等。

帧的精确定义因平台而异，并且在许多平台上并不存在一种所有函数都遵循的刚性帧格式（x86 就是一个例子）。相反，编译器通常可以自由地优化帧的具体格式。在这类系统上，无法保证堆栈遍历能返回 100% 正确或完整的结果（用于调试时，会使用 pdb 等调试符号来填补缺口，从而让调试器能够生成更准确的堆栈跟踪）。

不过这对 CLR 不是问题，因为我们并不需要一个完全泛化的堆栈遍历。我们只关心那些托管帧（即表示托管方法的帧），以及在一定程度上关心来自用于实现运行时自身的那部分非托管代码的帧。尤其是，对于第三方非托管帧的保真度并没有保证——除非只是标记这些帧在何处进入或离开运行时自身（即我们确实关心的一种帧类型）。

因为我们控制着我们感兴趣的帧的格式（稍后会深入细节），我们可以确保这些帧可以 100% 保真地被遍历。唯一额外的要求是：需要一种机制把运行时帧中不连续的若干组链接起来，从而能够跳过中间任何介入的非托管（也因此无法遍历的）帧。

下图展示了一个包含所有帧类型的堆栈（注意本文采用一种约定：堆栈向页面顶部增长）：

![image](images/stack.png)

# 让帧可遍历

## 托管帧

因为运行时拥有并控制 JIT（Just-in-Time，即时）编译器，它可以安排托管方法始终留下一个可遍历的帧。一种方案是让所有方法都采用固定的帧格式（例如 x86 的 EBP 帧格式）。但在实践中这可能效率不高，尤其对于小型叶子方法（例如常见的属性访问器）。

由于方法被调用的次数通常远多于其栈帧被遍历的次数（至少相对于方法调用频率而言，堆栈遍历在运行时中相对少见），因此用一定的遍历开销来换取更好的方法调用性能是合理的。基于这一点，JIT 会为它编译的每个方法生成额外的元数据，其中包含足够的信息，让堆栈遍历器能够解码属于该方法的栈帧。

这些元数据可通过哈希表查找获得：以落在该方法内部某处的指令指针作为键。JIT 还会使用压缩技术，以尽量减小这些“按方法”增加的元数据带来的影响。

给定少数几个重要寄存器的初始值（例如在基于 x86 的系统上是 EIP、ESP 和 EBP），堆栈遍历器就可以定位到一个托管方法以及它关联的 JIT 元数据，并利用这些信息把寄存器值回滚到该方法调用方中的值。这样，就能从最新的调用方一路遍历到最老的调用方，形成一串托管方法帧。这个操作有时被称为 _虚拟回退（virtual unwind）_（之所以叫“虚拟”，是因为我们并不会真的更新 ESP 等寄存器的真实值，从而保持堆栈不被破坏）。

## 运行时非托管帧

运行时部分由非托管代码实现（例如 coreclr.dll）。其中大部分代码很特殊：它作为 _手动托管（manually managed）_ 代码运行。也就是说，它遵循托管代码的许多规则与协议，但以显式、受控的方式来做到这一点。例如，这类代码可以显式启用或禁用 GC 的抢占模式（pre-emptive mode），并据此管理对象引用的使用方式。

这种与托管代码的小心交互在堆栈遍历期间也很重要。由于运行时的非托管代码大多用 C++ 编写，我们无法像对托管代码那样控制方法的帧格式。与此同时，在堆栈遍历期间，运行时的某些非托管帧里又包含重要信息。例如：某些非托管函数在局部变量中保存了对象引用（必须在垃圾回收期间报告），以及异常处理相关的信息。

与其试图让每个非托管帧都可遍历，不如让包含需要向堆栈遍历报告的“有趣数据”的非托管函数，把这些信息打包到一个称为 Frame 的数据结构中。这个名字的选择不太理想，因为它容易在与堆栈相关的讨论中产生歧义。本文将始终把这种数据结构版本称为首字母大写的 Frame。

Frame 实际上是一个 Frame 类型层次结构的抽象基类。Frame 会被进一步细分，以表达堆栈遍历可能关心的不同信息种类。

那么堆栈遍历器如何找到这些 Frame？它们又与托管方法使用的那些帧有什么关系？

每个 Frame 都属于一个单向链表，包含一个 next 指针指向该线程堆栈中下一个更老的 Frame（如果该 Frame 已经是最老的，则为 null）。CLR 的 Thread 结构保存着指向最新 Frame 的指针。运行时的非托管代码可以通过操作 Thread 结构与 Frame 链表，按需压入或弹出 Frame。

通过这种方式，堆栈遍历器就能够按从新到旧的顺序迭代非托管 Frame（这与迭代托管帧的顺序一致）。但托管方法与非托管方法可能交错出现，如果把所有托管帧处理完再处理所有非托管 Frame（或反过来），都无法准确反映真实的调用序列。

为了解决这个问题，对 Frame 还施加了进一步限制：它们必须分配在“把它们压入 Frame 链表”的那个方法的栈帧上。由于堆栈遍历器知道每个托管帧的堆栈边界，它可以通过简单的指针比较来判断某个 Frame 相对某个托管帧是更老还是更新。

本质上，堆栈遍历器在解码完当前帧后，总是有两个候选的“下一（更老）帧”可选：

- 通过对寄存器集合进行一次虚拟回退得到的下一托管帧。
- Thread 的 Frame 链表中下一个更老的 Frame。

它可以通过判断哪一个在堆栈上更靠近栈顶来决定该选哪一个。实际计算与平台相关，但通常归结为一到两次指针比较。

当托管代码调用进入运行时的非托管代码时，非托管目标方法通常会压入若干种“过渡 Frame（transition Frame）”之一。这既用于记录调用方托管方法的寄存器状态（这样堆栈遍历器在枚举完非托管 Frame 后，能够继续对托管帧做虚拟回退），也常常是因为托管对象引用会作为参数传入非托管方法——一旦发生垃圾回收，就必须把这些引用报告给 GC。

对可用 Frame 类型及其用途的完整描述超出了本文范围。更多细节可参见头文件 [frames.h](https://github.com/dotnet/runtime/blob/main/src/coreclr/vm/frames.h)。

# Stackwalker 接口

完整的堆栈遍历接口只对运行时的非托管代码开放（托管代码通过 System.Diagnostics.StackTrace 类可以使用一个简化子集）。典型入口是运行时 Thread 类上的 StackWalkFramesEx() 方法。

该方法的调用者需要提供三个主要输入：

1. 一些上下文，用于指示遍历的起点。这要么是一组初始寄存器值（例如你暂停了目标线程，并能对其调用 GetThreadContext()），要么是一个初始 Frame（在你知道相关代码位于运行时非托管代码中的情况下）。虽然大多数堆栈遍历从栈顶开始，但如果你能确定正确的起始上下文，也可以从更靠近栈底的位置开始。
2. 一个函数指针及其关联上下文。堆栈遍历器会为每个“有趣的帧”调用该函数（按从新到旧的顺序）。传入的上下文值会被传递到每次回调调用中，以便回调在遍历过程中记录或累积状态。
3. 标志位，用于指示哪类帧会触发回调。例如，调用者可以指定只报告纯托管方法帧。完整列表请参阅 [threads.h](https://github.com/dotnet/runtime/blob/main/src/coreclr/vm/threads.h)（紧挨着 StackWalkFramesEx() 声明的上方）。

StackWalkFramesEx() 会返回一个枚举值，指示遍历是正常终止（到达栈底且没有更多方法可报告）、被某个回调中止（回调会返回同类型枚举来控制堆栈遍历），还是遭遇了其他杂项错误。

除了传给 StackWalkFramesEx() 的 context 值外，堆栈回调函数还会收到另一份上下文：CrawlFrame。该类定义于 [stackwalk.h](https://github.com/dotnet/runtime/blob/main/src/coreclr/vm/stackwalk.h)，包含了堆栈遍历过程中收集到的各种上下文。

例如，CrawlFrame 会为托管帧提供 MethodDesc*，为非托管 Frame 提供 Frame*。它还会提供到当前为止通过虚拟回退推导出来的寄存器集合。

# 堆栈遍历实现细节

关于堆栈遍历实现的更多底层细节，目前超出了本文范围。如果你了解这些并愿意分享，欢迎更新本文档。
