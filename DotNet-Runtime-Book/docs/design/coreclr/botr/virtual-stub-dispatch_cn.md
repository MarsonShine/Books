> 在计算机科学中，尤其是 .NET Runtime (CoreCLR) 的文档里，**Stub**（中文常译为“存根”，也有人叫它“桩”）是一个非常高频的词。
>
> 简单来说：**Stub 是一小段在运行时动态生成的、高度优化的机器码（汇编指令），它像是一个“中转站”或“胶水代码”，负责处理函数调用过程中的各种“杂活”。**
>
> 为了彻底理解，我们不用专业术语，用几个生活场景和具体的 CLR 场景来解释：
>
> ### 1. 形象类比：电影票的存根
>
> 为什么叫“存根”？就像电影票，你手里拿的那一小块（存根）虽然不是电影本身，但它上面写着：**你应该去几号厅看哪部电影**。 在代码里，Stub 就是那块“存根”，它告诉你真正要执行的代码在哪里，并且在带你去之前，先帮你检票、安检。
>
> ### 2. CLR 中 Stub 的三个核心用途（为什么需要它？）
>
> 在 .NET 这种高度动态的运行时里，Stub 主要干这三件事：
>
> #### A. 懒加载（JIT 编译的占位符）
>
> 当你第一次调用一个方法时，这个方法可能还没被编译成机器码（还是 IL 码）。
>
> - **做法：** CLR 会为这个方法先指派一个 **JIT Stub**（也叫 Precode Stub）。
> - 流程：
>   1. 你调用方法 A。
>   2. 实际上你跳到了 A 的 Stub。
>   3. Stub 检查发现：“咦，A 还没编译成机器码呢”。
>   4. Stub 调用 JIT 编译器：“快给 A 编译一下”。
>   5. JIT 编译完，Stub 把 A 的入口地址**改写**成真正的代码地址。
>   6. 以后再调用，就不再走这个 Stub 了。
>
> #### B. 跨界桥梁（P/Invoke 或 COM 互操作）
>
> 当你从 C# 调用一个 C++ 的 DLL 函数时，两边的规则不一样（比如 C# 用的是托管栈，C++ 是非托管栈；字符串格式也不同）。
>
> - **做法：** CLR 生成一个 **P/Invoke Stub**。
> - **职责：** 这个 Stub 负责“翻译”。它把 C# 的参数搬运到 C++ 能理解的地方，切换线程状态（进入非托管模式），等 C++ 执行完，再把结果搬回来。
>
> #### C. 虚函数调用的“导购员”（Virtual Stub Dispatch）
>
> 对于接口调用（比如 `IMyInterface.DoWork()`），运行时并不知道具体该跑哪个实现类的方法。
>
> - **做法：** CLR 使用 **Virtual Stub**。
> - **优化：** Stub 会缓存上一次调用的结果。它会想：“上次调用这个接口的是 `Class A`，那这次大概率还是 `Class A`”。如果猜对了，Stub 直接几行汇编就跳过去了，比查表快得多。如果猜错了，它才会去走复杂的查找逻辑。
>
> ### 3. Stub 到底长什么样？
>
> 如果你去看源码或者反汇编，一个 Stub 通常只有几行汇编指令。例如：
>
> Assembly
>
> ```
> mov rax, 0x12345678  ; 把真正的方法地址存进寄存器
> jmp rax              ; 跳过去执行
> ```
>
> 或者包含一些简单的判断逻辑（Cache Check）。
>
> ### 4. 为什么要用这么奇怪的翻译“存根”？
>
> 在中文里，“存根”通常指票据留存的部分，作为**凭证**和**索引**。
>
> - 它是**轻量**的（只有几个字��）。
> - 它是**临时**的（一旦真正的代码准备好了，它可能就被替换掉）。
> - 它是**代理**（你以为在调方法，其实在调 Stub）。
>
> ### 总结
>
> 你以后看到 **Stub**，就把它脑补成 **“一小段负责跑腿、中转、或打掩护的底层汇编代码”**。
>
> 它之所以在 .NET 这种运行时里重要，是因为 .NET 有很多东西是**动态确定**的（比如 JIT、泛型、接口、多态）。Stub 就像是在杂乱的逻辑中架起的一座座**快速通道**，让 CPU 能以最高速度跳到该去的地方

> 为了理解这里的 Stub 到底是什么，我们需要先看它要解决的**核心痛点**。
>
> ### 1. 痛点：为什么接口调用很慢？
>
> 在 C# 中，调用类的方法（Virtual Call）相对简单，因为每个类都有自己的 `MethodTable`，查表就行。 但接口调用（Interface Call）很难：
>
> - 一个 `IList` 接口，当前实例可能是 `List<int>`，也可能是 `ArrayList`，还可能是你自定义的类。
> - 每个类实现的接口方法，在各自 `MethodTable` 里的位置（偏移量）都不一样。
> - **传统做法：** 每次调用接口都要进行复杂的全局搜索（查接口表、算偏移），非常耗时。
>
> ### 2. VSD 里的 Stub 是什么？
>
> VSD 的核心思想是：**“接口调用虽然有很多种可能，但在某个具体的代码位置，通常调用的都是同一种类型。”**
>
> 于是，CLR 在接口调用点放了一个 **Stub**。这个 Stub 在 VSD 中其实分为三种形态（或者说三个阶段的进化）：
>
> #### 第一阶段：查找存根 (Lookup Stub) —— “我是新生”
>
> 当你第一次运行到这行代码时：
>
> - 这里的 Stub 是一个 **Lookup Stub**。
> - 它的代码逻辑非常简单：直接跳转到内核里的“寻找者”（Resolver）。
> - **作用：** 它告诉运行时：“我不知道该调谁，请帮我找一下，顺便帮我进化一下”。
>
> #### 第二阶段：分派存根 (Dispatch Stub) —— “我有记忆了（缓存）”
>
> 当 Resolver 找到了真正的目标方法后，它会**改写**调用点的代码，把 Lookup Stub 替换成 **Dispatch Stub**。
>
> - 这段 Stub 包含以下汇编逻辑：
>   1. 检查当前对象的类型（MethodTable 地址）。
>   2. 把它与“上一次”调用的类型进行比较（这是一个硬编码在 Stub 里的地址）。
>   3. **如果一致（命中缓存）：** 直接跳转到目标方法。**这只需要几条 CPU 指令，快如闪电。**
>   4. **如果不一致（缓存失效）：** 跳转到第三阶段。
>
> #### 第三阶段：解析存根 (Resolve Stub) —— “我是专家”
>
> 如果这个调用点经常出现不同的类型（比如一会儿是 `List`，一会儿是 `Array`），Dispatch Stub 就会失效。
>
> - 此时 Stub 会进化成 **Resolve Stub**。
> - 它内部包含一个更高级的“小哈希表”。它会快速检查：这个点最近常用的 3-5 个类型分别对应哪个方法。
> - 如果还是找不到，才去调用最慢的全局搜索。
>
> ### 3. 直观对比：传统的查表 vs VSD 的 Stub
>
> - 传统查表（像查字典）：
>   1. 拿到对象 -> 2. 找到类 -> 3. 找到接口映射表 -> 4. 找到方法 -> 5. 执行。
> - VSD Stub（像安检口）：
>   1. Stub 直接问：“你还是上次来的那个人吗？”
>   2. 如果是，门直接打开（跳转执行），整个过程不到 1 纳秒。