# CLR 线程概览

# 托管线程与原生线程

托管代码在“托管线程”上执行，它们不同于操作系统提供的原生线程。原生线程是原生代码在物理机器上的执行线程；托管线程是 CLR 虚拟机上的虚拟执行线程。

正如 JIT 编译器将“虚拟” IL 指令映射为在物理机器上执行的原生指令一样，CLR 的线程基础设施将“虚拟”托管线程映射到操作系统提供的原生线程上。

在任何给定时间，托管线程可能会也可能不会被分配给原生线程来执行。例如，一个已创建（通过 “new System.Threading.Thread”）但尚未启动（通过 System.Threading.Thread.Start）的托管线程是一个尚未分配给原生线程的托管线程。同样，原则上，托管线程可能会在其执行过程中在多个原生线程之间移动，尽管实际上 CLR 目前不支持这样做。

托管代码可用的公共 Thread 接口有意隐藏了底层原生线程的细节，因为：

- 托管线程不一定映射到单个原生线程（并且可能根本不映射到原生线程）。
- 不同的操作系统为原生线程暴露不同的抽象。
- 原则上，托管线程是“虚拟化”的。

CLR 为托管线程提供了等效的抽象，由 CLR 自身实现。例如，它不暴露操作系统的线程本地存储 (TLS) 机制，而是提供托管的“线程静态”变量。同样，它不暴露原生线程的“线程 ID”，而是提供一个独立于操作系统生成的“托管线程 ID”。但是，出于诊断目的，可以通过 System.Diagnostics 命名空间中的类型获取底层原生线程的一些细节。

托管线程需要通常原生线程不需要的额外功能。首先，托管线程在其栈上持有 GC 引用，因此 CLR 必须能够在每次 GC 发生时枚举（并可能修改）这些引用。为此，CLR 必须“挂起”每个托管线程（将其停止在可以找到其所有 GC 引用的点）。其次，当卸载 AppDomain 时，CLR 必须确保没有线程正在该 AppDomain 中执行代码。这需要强制线程从该 AppDomain 展开的能力。CLR 通过向此类线程注入 ThreadAbortException 来做到这一点。

# 数据结构

每个托管线程都有一个关联的 Thread 对象，定义在 [threads.h][threads.h] 中。该对象跟踪 VM 需要了解的有关托管线程的所有信息。这包括_必要_的东西，例如线程当前的 GC 模式和帧链，以及仅出于性能原因按线程分配的许多东西（例如一些快速的 arena 风格分配器）。

所有 Thread 对象都存储在 ThreadStore 中（也在 [threads.h][threads.h] 中定义），它是所有已知 Thread 对象的简单列表。要枚举所有托管线程，必须首先获取 ThreadStoreLock，然后使用 ThreadStore::GetAllThreadList 枚举所有 Thread 对象。此列表可能包括当前未分配给原生线程的托管线程（例如，它们可能尚未启动，或者原生线程可能已经退出）。

[threads.h]: ../../../../src/coreclr/vm/threads.h

当前分配给原生线程的每个托管线程都可以通过该原生线程上的原生线程本地存储 (TLS) 槽访问。这允许在该原生线程上执行的代码通过 GetThread() 获取相应的 Thread 对象。

此外，许多托管线程有一个_托管_ Thread 对象 (System.Threading.Thread)，它不同于原生 Thread 对象。托管 Thread 对象为托管代码提供了与线程交互的方法，并且主要还是原生 Thread 对象提供的功能的包装器。当前托管 Thread 对象可以通过 Thread.CurrentThread（从托管代码）访问。

在调试器中，SOS 扩展命令“!Threads”可用于枚举 ThreadStore 中的所有 Thread 对象。

# 线程生命周期

在以下情况下创建托管线程：

1. 托管代码通过 System.Threading.Thread 显式要求 CLR 创建新线程。
2. CLR 直接创建托管线程（见下文["特殊线程"](#special-threads)）。
3. 原生代码在尚未与托管线程关联的原生线程上调用托管代码（通过“反向 p/invoke”或 COM 互操作）。
4. 托管进程启动（在进程的主线程上调用其 Main 方法）。

在情况 #1 和 #2 中，CLR 负责创建原生线程来支持托管线程。这直到线程实际_启动_时才会完成。在这种情况下，原生线程由 CLR “拥有”；CLR 负责原生线程的生命周期。在这些情况下，CLR 知道线程的存在，因为 CLR 是一开始创建它的。

在情况 #3 和 #4 中，原生线程在创建托管线程之前就已经存在，并且由 CLR 外部的代码拥有。CLR 不负责原生线程的生命周期。CLR 在这些线程第一次尝试调用托管代码时意识到它们。

当原生线程死亡时，CLR 会通过其 DllMain 函数收到通知。这发生在 OS “加载器锁”内部，因此在处理此通知时几乎无法（安全地）做任何事情。因此，与其销毁与托管线程关联的数据结构，不如简单地将线程标记为“死亡”并通知终结器线程运行。终结器线程随后扫描 ThreadStore 中的线程，并销毁任何既已死亡_且_无法通过托管代码访问的线程。

# 挂起

CLR 必须能够找到对托管对象的所有引用才能执行 GC。托管代码不断访问 GC 堆，并操作存储在栈和寄存器中的引用。CLR 必须确保所有托管线程都停止（这样它们就不会修改堆），以便安全可靠地找到所有托管对象。它只会在_安全点_停止，此时可以检查寄存器和栈位置的活动引用。

换一种说法是，GC 堆以及每个线程的栈和寄存器状态都是“共享状态”，由多个线程访问。与大多数共享状态一样，需要某种“锁”来保护它。托管代码在访问堆时必须持有此锁，并且只能在安全点释放锁。

CLR 将此“锁”称为线程的“GC 模式”。处于“协作模式”的线程持有其锁；它必须与 GC “协作”（通过释放锁）以便 GC 进行。处于“抢占”模式的线程不持有其锁——GC 可以“抢占式”进行，因为已知该线程没有访问 GC 堆。

只有当所有托管线程都处于“抢占”模式（未持有锁）时，GC 才能进行。将所有托管线程移动到抢占模式的过程称为“GC 挂起”或“挂起执行引擎 (EE)”。

此“锁”的一个朴素实现是让每个托管线程在每次访问 GC 堆前后实际获取和释放真正的锁。然后 GC 只需尝试获取每个线程上的锁；一旦它获取了所有线程的锁，就可以安全地执行 GC。

然而，这种朴素的方法由于两个原因不能令人满意。首先，这将要求托管代码花费大量时间来获取和释放锁（或者至少检查 GC 是否试图获取锁——称为“GC 轮询”）。其次，这将要求 JIT 发出描述 JIT 代码中每个点的栈和寄存器布局的“GC 信息”；此信息将消耗大量内存。

我们通过将 JIT 的托管代码分为“部分可中断”和“完全可中断”代码来改进这种朴素的方法。在部分可中断代码中，唯一的安全点是对其他方法的调用，以及 JIT 发出代码以检查 GC 是否挂起的显式“GC 轮询”位置。只需要为这些位置发出 GC 信息。在完全可中断代码中，每条指令都是安全点，JIT 为每条指令发出 GC 信息——但它不发出 GC 轮询。相反，完全可中断代码可以通过劫持线程（本文档稍后将讨论的过程）被“中断”。JIT 根据启发式方法选择发出完全可中断还是部分可中断代码，以在代码质量、GC 信息大小和 GC 挂起延迟之间找到最佳折衷。

鉴于上述情况，有三个基本操作需要定义：进入协作模式、离开协作模式和挂起 EE。

## 进入协作模式

线程通过调用 Thread::DisablePreemptiveGC 进入协作模式。这将为当前线程获取“锁”，如下所示：

1. 如果 GC 正在进行中（GC 持有锁），则阻塞直到 GC 完成。
2. 将线程标记为处于协作模式。在线程重新进入抢占模式之前，GC 无法进行。

这两个步骤就像原子操作一样进行。

## 进入抢占模式

线程通过调用 Thread::EnablePreemptiveGC 进入抢占模式（释放锁）。这只是简单地将线程标记为不再处于协作模式，并通知 GC 线程它可以进行。

## 挂起 EE

当需要发生 GC 时，第一步是挂起 EE。这是通过 GCHeap::SuspendEE 完成的，其过程如下：

1. 设置全局标志 (g\_fTrapReturningThreads) 以指示 GC 正在进行中。任何试图进入协作模式的线程都将阻塞，直到 GC 完成。
2. 查找当前在协作模式下执行的所有线程。对于每个这样的线程，尝试劫持该线程并强制其离开协作模式。
3. 重复直到没有线程在协作模式下运行。

## 劫持

GC 挂起的劫持由 Thread::SysSuspendForGC 完成。此方法尝试强制当前在协作模式下运行的任何托管线程在“安全点”离开协作模式。它通过枚举所有托管线程（遍历 ThreadStore），并针对当前在协作模式下运行的每个托管线程来做到这一点。

1. 挂起底层原生线程。这是使用 Win32 SuspendThread API 完成的。此 API 强制停止线程运行，在其执行的某个随机点（不一定是安全点）。
2. 通过 GetThreadContext 获取线程的当前 CONTEXT。这是一个操作系统概念；CONTEXT 表示线程的当前寄存器状态。这允许我们检查其指令指针，从而确定它当前正在执行的代码类型。
3. 再次检查线程是否处于协作模式，因为它可能在被挂起之前已经离开了协作模式。如果是，该线程处于危险区域：该线程可能正在执行任意原生代码，并且必须立即恢复以避免死锁。
4. 检查线程是否正在运行托管代码。它可能正在协作模式下执行原生 VM 代码（见下文同步），在这种情况下，必须像上一步一样立即恢复该线程。
5. 现在线程在托管代码中被挂起。根据该代码是完全可中断还是部分可中断，执行以下操作之一：
  * 如果是完全可中断的，在任何点执行 GC 都是安全的，因为根据定义，线程处于安全点。将线程留在此时被挂起是合理的（因为它是安全的），但各种历史操作系统错误阻止了这种做法，因为之前检索到的 CONTEXT 可能已损坏。相反，线程的指令指针被覆盖，将其重定向到一个存根，该存根将捕获更完整的 CONTEXT，离开协作模式，等待 GC 完成，重新进入协作模式，并将线程恢复到之前的状态。
  * 如果是部分可中断的，根据定义，线程不处于安全点。然而，调用者将处于安全点（方法转换）。利用这一知识，CLR “劫持”最顶层栈帧的返回地址（物理覆盖栈上的那个位置），使用类似于完全可中断代码所用的存根。当方法返回时，它不再返回其实际调用者，而是返回存根（方法也可能在该点之前执行 JIT 插入的 GC 轮询，这将导致它离开协作模式并撤消劫持）。

# ThreadAbort / AppDomain-Unload

为了卸载 AppDomain，CLR 必须确保没有线程在该 AppDomain 中运行。为此，枚举所有托管线程，并“中止”任何具有属于正在卸载的 AppDomain 的栈帧的线程。ThreadAbortException 被“注入”到正在运行的线程中，这会导致线程展开（沿途执行回退代码），直到它不再在该 AppDomain 中执行，此时 ThreadAbortException 被转换为 AppDomainUnloaded 异常。

ThreadAbortException 是一种特殊类型的异常。它可以被用户代码捕获，但 CLR 确保在执行用户的异常处理程序后重新抛出异常。因此，ThreadAbortException 有时被称为“不可捕获”，尽管这并不完全正确。

ThreadAbortException 通常通过简单地在托管线程上设置一个位将其标记为“中止中”来‘抛出’。CLR 的各个部分（最明显的是每次从 p/invoke 返回时）都会检查此位，通常设置此位就是及时中止线程所需的全部操作。

但是，如果线程正在执行长时间运行的托管循环，它可能永远不会检查此位。为了让这样的线程更快中止，线程被“劫持”并被迫引发 ThreadAbortException。这种劫持与 GC 挂起的方式相同，除了线程被重定向到的存根将导致引发 ThreadAbortException，而不是等待 GC 完成。

这种劫持意味着 ThreadAbortException 可以在托管代码中的几乎任何任意点引发。这使得托管代码极其难以成功处理 ThreadAbortException。因此，除了 AppDomain-Unload 之外，将其用于任何其他目的是不明智的，AppDomain-Unload 确保任何被 ThreadAbort 损坏的状态将与 AppDomain 一起被清理。

# 同步：托管

托管代码可以访问许多同步原语，收集在 System.Threading 命名空间中。这些包括原生 OS 原语（如 Mutex、Event 和 Semaphore 对象）的包装器，以及一些抽象（如 Barriers 和 SpinLocks）。然而，大多数托管代码使用的主要同步机制是 System.Threading.Monitor，它在_任何托管对象_上提供高性能锁定设施，并额外提供“条件变量”语义用于通知锁保护的状态更改。

Monitor 实现为“混合锁”；它具有自旋锁和基于内核的锁（如 Mutex）的功能。这个想法是大多数锁只被短暂持有，所以简单地自旋等待锁释放比调用内核来阻塞线程花费的时间更少。不浪费 CPU 周期进行自旋很重要，所以如果在短暂的自旋后仍未获取锁，实现将回退到内核中的阻塞。

因为任何对象都可能被用作锁/条件变量，所以每个对象都必须有一个位置来存储锁信息。这是通过“对象头”和“同步块”完成的。

对象头是位于每个托管对象之前的机器字大小的字段。它用于多种用途，例如存储对象的哈希码。其中一个用途是持有对象的锁状态。如果需要的每个对象数据超过了对象头所能容纳的范围，我们通过创建“同步块”来“膨胀”对象。

同步块存储在同步块表中，并通过同步块索引寻址。每个具有关联同步块的对象都在对象头中包含该索引的索引。

对象头和同步块的详细信息定义在 [syncblk.h][syncblk.h]/[.cpp][syncblk.cpp] 中。

[syncblk.h]: ../../../../src/coreclr/vm/syncblk.h
[syncblk.cpp]: ../../../../src/coreclr/vm/syncblk.cpp

如果对象头有空间，Monitor 会存储当前持有对象锁的线程的托管线程 ID（如果没有线程持有锁，则为零 (0)）。在这种情况下，获取锁只是简单地自旋等待直到对象头的线程 ID 为零，然后原子地将其设置为当前线程的托管线程 ID。

如果在一定次数的自旋后无法以这种方式获取锁，或者对象头已经被用于其他目的，则必须为该对象创建一个同步块。这有额外的数据，包括一个可用于阻塞当前线程的事件，允许我们停止自旋并有效地等待锁释放。

用作条件变量的对象（通过 Monitor.Wait 和 Monitor.Pulse）必须始终膨胀，因为对象头中没有足够的空间来保存所需的状态。

# 同步：原生

CLR 的原生部分也必须意识到线程，因为它将被多个线程上的托管代码调用。这需要原生同步机制，例如锁、事件等。

ITaskHost API 允许主机覆盖托管线程的许多方面，包括线程创建、销毁和同步。主机覆盖原生同步的能力意味着 VM 代码通常不能直接使用原生同步原语（关键部分、互斥锁、事件等），而必须使用 VM 对这些原语的包装器。

此外，如上所述，GC 挂起是一种特殊类型的“锁”，它几乎影响 CLR 的每个方面。VM 中的原生代码如果必须操作 GC 堆对象，可能会进入“协作”模式，因此“GC 挂起锁”成为原生 VM 代码以及托管代码中最重要的同步机制之一。

原生 VM 代码中使用的主要同步机制是 GC 模式和 Crst。

## GC 模式

如上所述，所有托管代码都在协作模式下运行，因为它可能会操作 GC 堆。通常，原生代码不接触托管对象，因此在抢占模式下运行。但是 VM 中的一些原生代码必须访问 GC 堆，因此必须在协作模式下运行。

原生代码通常不直接操作 GC 模式，而是使用两个宏：GCX\_COOP 和 GCX\_PREEMP。这些进入所需的模式，并建立“持有者”以在退出作用域时使线程恢复到先前的模式。

重要的是要理解 GCX\_COOP 实际上获取了 GC 堆上的锁。当线程处于协作模式时，GC 无法进行。并且原生代码不能像托管代码那样被“劫持”，因此线程将保持在协作模式，直到它显式切换回抢占模式。

因此，不鼓励在原生代码中进入协作模式。在必须进入协作模式的情况下，应尽可能缩短时间。线程不应在此模式下被阻塞，特别是一般不能安全地获取锁。

同样，GCX\_PREEMP 可能会_释放_线程持有的锁。在进入抢占模式之前，必须非常小心地确所有 GC 引用都得到适当保护。

[代码规则](../../../coding-guidelines/clr-code-guide.md)文档描述了确保 GC 模式切换安全的必要纪律。

## Crst

正如 Monitor 是托管代码的首选锁定机制一样，Crst 是 VM 代码的首选机制。像 Monitor 一样，Crst 是一种混合锁，它知道主机和 GC 模式。Crst 还通过“锁分级”实现死锁避免，在 [BotR 的 Crst 分级章节](../../../coding-guidelines/clr-code-guide.md#2.6.4)中进行了描述。

在协作模式下获取 Crst 通常是非法的，但在绝对必要的情况下会有例外。

# 特殊线程

除了管理由托管代码创建的线程外，CLR 还会为自己的使用创建几个“特殊”线程。

## 终结器线程

此线程在每个运行托管代码的进程中创建。当 GC 确定可终结对象不再可达时，它将该对象放入终结队列。在 GC 结束时，终结器线程收到信号处理当前在此队列中的所有终结器。然后每个对象被逐个出队，并执行其终结器。

此线程还用于执行各种 CLR 内部清理任务，并等待某些外部事件的通知（例如低内存条件，这向 GC 发出信号以更积极地收集）。有关详细信息，请参阅 GCHeap::FinalizerThreadStart。

## GC 线程

当在“并发”或“服务器”模式下运行时，GC 创建一个或多个后台线程以并行执行垃圾回收的各个阶段。这些线程完全由 GC 拥有和管理，并且从不运行托管代码。

## 调试器线程

CLR 在每个托管进程中维护一个原生线程，该线程代表附加的托管调试器执行各种任务。

## AppDomain-Unload 线程

此线程负责卸载 AppDomain。这是在一个单独的 CLR 内部线程上完成的，而不是请求 AD 卸载的线程，以便 a) 为卸载逻辑提供保证的栈空间，以及 b) 允许请求卸载的线程从 AD 中展开（如果需要）。

## ThreadPool 线程

CLR 的 ThreadPool 维护一组托管线程用于执行用户“工作项”。这些托管线程绑定到 ThreadPool 拥有的原生线程。ThreadPool 还维护少量原生线程来处理诸如“线程注入”、计时器和“注册等待”之类的功能。
