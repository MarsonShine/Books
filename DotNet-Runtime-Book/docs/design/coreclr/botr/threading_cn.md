# CLR 线程概览

# 托管线程与原生线程

托管代码在“托管线程”上执行，它们不同于操作系统提供的原生线程。原生线程是原生代码在物理机器上的执行线程；托管线程是 CLR 虚拟机上的虚拟执行线程。

正如 JIT 编译器将“虚拟” IL 指令映射为在物理机器上执行的原生指令一样，CLR 的线程基础设施将“虚拟”托管线程映射到操作系统提供的原生线程上。

在任何给定时间，托管线程可能会也可能不会被分配给原生线程来执行。例如，一个已创建（通过 “new System.Threading.Thread”）但尚未启动（通过 System.Threading.Thread.Start）的托管线程是一个尚未分配给原生线程的托管线程。同样，原则上，托管线程可能会在其执行过程中在多个原生线程之间移动，尽管实际上 CLR 目前不支持这样做。

托管代码可用的公共 Thread 接口有意隐藏了底层原生线程的细节，因为：

- 托管线程不一定映射到单个原生线程（并且可能根本不映射到原生线程）。
- 不同的操作系统为原生线程暴露不同的抽象。
- 原则上，托管线程是“虚拟化”的。

CLR 为托管线程提供了等价的抽象，并由 CLR 自身实现。例如，它不会暴露操作系统的线程本地存储（TLS）机制，而是提供托管的“线程静态”（thread-static）变量。类似地，它不会暴露原生线程的“线程 ID”，而是提供一个独立于操作系统生成的“托管线程 ID”。不过，出于诊断目的，可以通过 System.Diagnostics 命名空间中的类型获取底层原生线程的一些细节。

托管线程需要一些原生线程通常不需要的额外功能。首先，托管线程会在其栈上持有 GC 引用，因此 CLR 必须能够在每次发生 GC 时枚举（并可能修改）这些引用。为此，CLR 必须“挂起”每个托管线程（在一个能够找到其所有 GC 引用的位置将其停止）。其次，当卸载某个 AppDomain 时，CLR 必须确保没有任何线程正在该 AppDomain 中执行代码。这需要具备强制线程从该 AppDomain 中回退（unwind）出来的能力。CLR 通过向这类线程注入一个 ThreadAbortException 来实现这一点。

> ### 1. 什么是原生线程 (Native Thread)？
>
> 操作系统（如 Windows, Linux）提供的底层执行单元。
>
> - **管理者：** 操作系统内核。
> - **特点：** 创建原生线程非常耗资源（需要分配栈内存、内核对象等）。操作系统通过“时间片轮转”算法，决定哪个原生线程在 CPU 上运行。
> - **代码：** 直接操作硬件指令（如 C/C++ 编译后的代码）。
>
> ### 2. 什么是托管线程 (Managed Thread)？
>
> .NET 运行时（CLR）暴露给开发者的逻辑对象（在代码中表现为 `System.Threading.Thread` 类的实例）。
>
> - **管理者：** CLR（Common Language Runtime）。
> - **特点：** 它是一个**抽象概念**。你在 C# 里创建一个 `Thread` 对象，CLR 会在后台为你安排工作，但这并不代表这个对象本身就是一颗“螺丝钉”。
> - **执行环境：** 托管线程在 CLR 这个“虚拟机”里跑，CLR 负责监控它的生命周期、安全权限和内存使用情况。
>
> ### 3. “托管线程”与“原生线程”的关系
>
> 这句话最核心的意思是：**Managed Thread ≠ Native Thread。**
>
> 在大多数当前的 .NET 实现（如现代的 Windows .NET 6/7/8）中，**一个托管线程通常映射到一个原生线程上**（1:1 关系）。但在架构设计上，它们是解耦的：
>
> - **逻辑标识 vs. 物理执行：** CLR 可以随时改变托管线程与原生线程的绑定。例如，一个托管线程在某一时刻可能在原生线程 A 上运行，但在它暂停又恢复后，CLR 可能会把它调度到原生线程 B 上执行（虽然目前 .NET 较少这样做，但架构上允许）。
> - 垃圾回收（GC）的控制：这是两者区别最明显的场景。当 .NET 需要进行垃圾回收时，它必须暂停所有代码执行。
>   - 如果直接操作原生线程，CLR 很难安全地停止它。
>   - 因为有“托管线程”这一层封装，CLR 只要向自己的“虚拟线程”发个指令：“喂，那个托管线程，在安全点停一下”，它就能精准控制，而不需要去硬性杀掉操作系统的线程。

# 数据结构

每个托管线程都有一个关联的 Thread 对象，定义在 [threads.h](https://github.com/dotnet/runtime/blob/main/src/coreclr/vm/threads.h) 中。该对象跟踪 VM 需要了解的关于该托管线程的一切信息。这既包括必需的信息，例如线程当前的 GC 模式和 Frame 链，也包括许多出于性能原因而按线程分配的内容（例如一些快速的 arena 风格分配器）。

所有 Thread 对象都存储在 ThreadStore 中（也在 [threads.h][https://github.com/dotnet/runtime/blob/main/src/coreclr/vm/threads.h] 中定义），它是所有已知 Thread 对象的简单列表。要枚举所有托管线程，必须首先获取 ThreadStoreLock，然后使用 ThreadStore::GetAllThreadList 枚举所有 Thread 对象。此列表可能包括当前未分配给原生线程的托管线程（例如，它们可能尚未启动，或者原生线程可能已经退出）。

当前分配给原生线程的每个托管线程都可以通过该原生线程上的原生线程本地存储 (TLS) 槽访问。这允许在该原生线程上执行的代码通过 GetThread() 获取相应的 Thread 对象。

此外，许多托管线程有一个_托管_ Thread 对象 (System.Threading.Thread)，它不同于原生 Thread 对象。托管 Thread 对象为托管代码提供了与线程交互的方法，并且主要还是原生 Thread 对象提供的功能的包装器。当前托管 Thread 对象可以通过 Thread.CurrentThread（从托管代码）访问。

在调试器中，SOS 扩展命令“!Threads”可用于枚举 ThreadStore 中的所有 Thread 对象。

# 线程生命周期

在以下情况下创建托管线程：

1. 托管代码通过 System.Threading.Thread 显式要求 CLR 创建新线程。
2. CLR 直接创建托管线程（见下文["特殊线程"](#特殊线程)）。
3. 原生代码在尚未与托管线程关联的原生线程上调用托管代码（通过“反向 p/invoke”或 COM 互操作）。
4. 托管进程启动（在进程的主线程上调用其 Main 方法）。

在情况 #1 和 #2 中，CLR 负责创建原生线程来支持托管线程。这直到线程实际_启动_时才会完成。在这种情况下，原生线程由 CLR “拥有”；CLR 负责原生线程的生命周期。在这些情况下，CLR 知道线程的存在，因为 CLR 是一开始创建它的。

在情况 #3 和 #4 中，原生线程在创建托管线程之前就已经存在，并且由 CLR 外部的代码拥有。CLR 不负责原生线程的生命周期。CLR 在这些线程第一次尝试调用托管代码时意识到它们。

当原生线程死亡时，CLR 会通过其 DllMain 函数收到通知。这发生在 OS “加载器锁”内部，因此在处理此通知时几乎无法（安全地）做任何事情。因此，与其销毁与托管线程关联的数据结构，不如简单地将线程标记为“死亡”并通知终结器线程运行。终结器线程随后扫描 ThreadStore 中的线程，并销毁任何既已死亡_且_无法通过托管代码访问的线程。

> ### 1. 为什么 #1 和 #2 CLR 负责生命周期？
>
> **场景：CLR 是“雇主”。**
>
> - **过程：** 当你在 C# 里写 `new Thread().Start()` 时，你是在向 CLR 申请一个新线程。CLR 收到申请后，会向操作系统（Windows/Linux）申请创建一个真正的原生线程。
> - 生命周期管理：
>   - **出生：** CLR 亲自调用操作系统的 API（如 `CreateThread`）来创建它。
>   - **死亡：** 当托管代码执行完毕，CLR 会通知操作系统：“这个线程的任务完成了，你可以销毁它了。”
> - **结论：** 因为线程是 CLR 亲手从系统那里要来的，所以它对这个线程的生老病死负全责。
>
> ### 2. 为什么 #3 和 #4 CLR 不负责生命周期？
>
> **场景：CLR 是“接待厅”，原生线程是“访客”。**
>
> 这里的核心逻辑是：**这个原生线程在进入 CLR 的领地之前，就已经在操作系统里跑着了。**
>
> #### 情况 #4：进程启动（Main 方法）
>
> 当你双击一个 `.exe` 程序时：
>
> 1. **操作系统**首先创建进程，并为该进程创建一个**初始线程**（主线程）。
> 2. 这个主线程开始运行，它会先加载 CLR 虚拟机。
> 3. 然后主线程才进入你的 `Main` 方法。
>
> - **为什么不负责？** 因为这个主线程是**操作系统**创建的，不是 CLR 创建的。CLR 只是“借用”了这个线程来跑托管代码。当 `Main` 方法结束，CLR 关闭，这个线程的最终销毁是由操作系统完成的。
>
> #### 情况 #3：反向 P/Invoke（C++ 调用 C#）
>
> 想象你有一个现成的 C++ 编写的游戏引擎（原生代码）：
>
> 1. 游戏引擎自己创建了一个线程在处理物理计算。
> 2. 运行到一半，它突然通过某种机制调用了一个 C# 编写的插件（托管代码）。
> 3. **瞬间发生的事：** 这个原本属于 C++ 的原生线程“闯入”了 CLR 的世界。
> 4. **CLR 的反应：** CLR 一看，“咦？有个我不认识的线程进来了，我得给它补办个登记，发个‘工牌’（创建一个托管线程对象关联上）。”
>
> - **为什么不负责？** 当 C# 插件的代码运行完，这个线程会**离开** CLR 回到 C++ 的世界继续跑。CLR 不能杀掉这个线程，因为它不属于 CLR。它什么时候死，由 C++ 代码或操作系统说了算。

# 挂起

CLR 必须能够找到对托管对象的所有引用才能执行 GC。托管代码不断访问 GC 堆，并操作存储在栈和寄存器中的引用。CLR 必须确保所有托管线程都停止（这样它们就不会修改堆），以便安全可靠地找到所有托管对象。它只会在_安全点_停止，此时可以检查寄存器和栈位置的活动引用。

换一种说法是，GC 堆以及每个线程的栈和寄存器状态都是“共享状态”，由多个线程访问。与大多数共享状态一样，需要某种“锁”来保护它。托管代码在访问堆时必须持有此锁，并且只能在安全点释放锁。

CLR 将此“锁”称为线程的“GC 模式”。处于“协作模式”的线程持有其锁；它必须与 GC “协作”（通过释放锁）以便 GC 进行。处于“抢占”模式的线程不持有其锁——GC 可以“抢占式”进行，因为已知该线程没有访问 GC 堆。

只有当所有托管线程都处于“抢占”模式（未持有锁）时，GC 才能进行。将所有托管线程移动到抢占模式的过程称为“GC 挂起”或“挂起执行引擎 (EE)”。

此“锁”的一个朴素实现是让每个托管线程在每次访问 GC 堆前后实际获取和释放真正的锁。然后 GC 只需尝试获取每个线程上的锁；一旦它获取了所有线程的锁，就可以安全地执行 GC。

然而，这种朴素的方法由于两个原因不能令人满意。首先，这将要求托管代码花费大量时间来获取和释放锁（或者至少检查 GC 是否试图获取锁——称为“GC 轮询”）。其次，这将要求 JIT 发出描述 JIT 代码中每个点的栈和寄存器布局的“GC 信息”；此信息将消耗大量内存。

我们通过将 JIT 的托管代码分为“部分可中断”和“完全可中断”代码来改进这种朴素的方法。在部分可中断代码中，唯一的安全点是对其他方法的调用，以及 JIT 发出代码以检查 GC 是否挂起的显式“GC 轮询”位置。只需要为这些位置发出 GC 信息。在完全可中断代码中，每条指令都是安全点，JIT 为每条指令发出 GC 信息——但它不发出 GC 轮询。相反，完全可中断代码可以通过劫持线程（本文档稍后将讨论的过程）被“中断”。JIT 根据启发式方法选择发出完全可中断还是部分可中断代码，以在代码质量、GC 信息大小和 GC 挂起延迟之间找到最佳折衷。

鉴于上述情况，有三个基本操作需要定义：进入协作模式、离开协作模式和挂起 EE。

## 进入协作模式

线程通过调用 Thread::DisablePreemptiveGC 进入协作模式。这将为当前线程获取“锁”，如下所示：

1. 如果 GC 正在进行中（GC 持有锁），则阻塞直到 GC 完成。
2. 将线程标记为处于协作模式。在线程重新进入抢占模式之前，GC 无法进行。

这两个步骤就像原子操作一样进行。

## 进入抢占模式

线程通过调用 Thread::EnablePreemptiveGC 进入抢占模式（释放锁）。这只是简单地将线程标记为不再处于协作模式，并通知 GC 线程它可以进行。

## 挂起 EE

当需要发生 GC 时，第一步是挂起 EE。这是通过 GCHeap::SuspendEE 完成的，其过程如下：

1. 设置全局标志 (g\_fTrapReturningThreads) 以指示 GC 正在进行中。任何试图进入协作模式的线程都将阻塞，直到 GC 完成。
2. 查找当前在协作模式下执行的所有线程。对于每个这样的线程，尝试劫持该线程并强制其离开协作模式。
3. 重复直到没有线程在协作模式下运行。

## 劫持

GC 挂起的劫持由 Thread::SysSuspendForGC 完成。此方法尝试强制当前在协作模式下运行的任何托管线程在“安全点”离开协作模式。它通过枚举所有托管线程（遍历 ThreadStore），并针对当前在协作模式下运行的每个托管线程来做到这一点。

1. 挂起底层原生线程。这是使用 Win32 SuspendThread API 完成的。此 API 强制停止线程运行，在其执行的某个随机点（不一定是安全点）。
2. 通过 GetThreadContext 获取线程的当前 CONTEXT。这是一个操作系统概念；CONTEXT 表示线程的当前寄存器状态。这允许我们检查其指令指针，从而确定它当前正在执行的代码类型。
3. 再次检查线程是否处于协作模式，因为它可能在被挂起之前已经离开了协作模式。如果是，该线程处于危险区域：该线程可能正在执行任意原生代码，并且必须立即恢复以避免死锁。
4. 检查线程是否正在运行托管代码。它可能正在协作模式下执行原生 VM 代码（见下文同步），在这种情况下，必须像上一步一样立即恢复该线程。
5. 现在线程在托管代码中被挂起。根据该代码是完全可中断还是部分可中断，执行以下操作之一：
  * 如果是完全可中断的，在任何点执行 GC 都是安全的，因为根据定义，线程处于安全点。将线程留在此时被挂起是合理的（因为它是安全的），但各种历史操作系统错误阻止了这种做法，因为之前检索到的 CONTEXT 可能已损坏。相反，线程的指令指针被覆盖，将其重定向到一个存根，该存根将捕获更完整的 CONTEXT，离开协作模式，等待 GC 完成，重新进入协作模式，并将线程恢复到之前的状态。
  * 如果是部分可中断的，根据定义，线程不处于安全点。然而，调用者将处于安全点（方法转换）。利用这一知识，CLR “劫持”最顶层栈帧的返回地址（物理覆盖栈上的那个位置），使用类似于完全可中断代码所用的存根。当方法返回时，它不再返回其实际调用者，而是返回存根（方法也可能在该点之前执行 JIT 插入的 GC 轮询，这将导致它离开协作模式并撤消劫持）。

> ### 1. 重新梳理这两个模式
>
> - **协作模式 (Cooperative Mode)：正在操作托管堆。**
>   - **含义：** “我正在动托管堆里的对象（比如读写变量）。GC 你**必须**等我，直到我走到一个安全点并把锁‘还给’你，你才能开始干活。”
>   - **为什么叫协作？** 因为 GC 不能蛮力停掉这个线程，必须靠这个线程“自觉协作”走到安全点停下来。
>   - **状态：** 线程持有“堆操作权”。
> - **抢占模式 (Preemptive Mode)：没在操作托管堆。**
>   - **含义：** “我现在可能在睡觉、在等 IO，或者在执行不属于 CLR 管辖的原生 C++ 代码。GC 你想什么时候运行都行，**不用问我**，直接‘抢占’执行权吧。”
>   - **为什么叫抢占？** 因为 GC 认为这个线程反正没在动托管对象，所以 GC 运行与否对该线程无影响，GC 可以直接进行。
>   - **状态：** 线程释放了“堆操作权”。
>
> ### 2. 核心逻辑：GC 什么时候能运行？
>
> **只有当所有托管线程都处于“抢占模式”时，GC 才能开始运行。**
>
> 你可以把“托管堆”想象成一个**更衣室**：
>
> 1. **协作模式的线程**：正在更衣室里换衣服的人。GC 如果这时候冲进去扫地（移动内存对象），大家都会尴尬（程序崩溃）。所以 GC 必须在门口等，直到里面的人出来。
> 2. **抢占模式的线程**：在更衣室外面操场上跑步的人。GC 进去扫地跟这些人没关系，这些人也不会突然冲进更衣室（因为进入协作模式需要检查 GC 标志）。
>
> ### 3.什么是劫持？
>
> - **完全可中断代码：** GC 直接改写该线程的 IP（指令指针），强行让它跳转到一个 CLR 的函数里去。这个函数会把线程变为抢占模式并停下来。
> - **部分可中断代码：** GC 修改栈上的**返回地址**。当这个方法执行完 `return` 时，它不会回到调用者，而是跳到了 GC 预设的“陷阱”里，乖乖变更为抢占模式并停下来。



# ThreadAbort / AppDomain-Unload

为了卸载 AppDomain，CLR 必须确保没有线程在该 AppDomain 中运行。为此，枚举所有托管线程，并“中止”任何具有属于正在卸载的 AppDomain 的栈帧的线程。ThreadAbortException 被“注入”到正在运行的线程中，这会导致线程展开（沿途执行回退代码），直到它不再在该 AppDomain 中执行，此时 ThreadAbortException 被转换为 AppDomainUnloaded 异常。

ThreadAbortException 是一种特殊类型的异常。它可以被用户代码捕获，但 CLR 确保在执行用户的异常处理程序后重新抛出异常。因此，ThreadAbortException 有时被称为“不可捕获”，尽管这并不完全正确。

ThreadAbortException 通常通过简单地在托管线程上设置一个位将其标记为“中止中”来‘抛出’。CLR 的各个部分（最明显的是每次从 p/invoke 返回时）都会检查此位，通常设置此位就是及时中止线程所需的全部操作。

但是，如果线程正在执行长时间运行的托管循环，它可能永远不会检查此位。为了让这样的线程更快中止，线程被“劫持”并被迫引发 ThreadAbortException。这种劫持与 GC 挂起的方式相同，除了线程被重定向到的存根将导致引发 ThreadAbortException，而不是等待 GC 完成。

这种劫持意味着 ThreadAbortException 可以在托管代码中的几乎任何任意点引发。这使得托管代码极其难以成功处理 ThreadAbortException。因此，除了 AppDomain-Unload 之外，将其用于任何其他目的是不明智的，AppDomain-Unload 确保任何被 ThreadAbort 损坏的状态将与 AppDomain 一起被清理。

# 同步：托管

托管代码可以访问许多同步原语，收集在 System.Threading 命名空间中。这些包括原生 OS 原语（如 Mutex、Event 和 Semaphore 对象）的包装器，以及一些抽象（如 Barriers 和 SpinLocks）。然而，大多数托管代码使用的主要同步机制是 System.Threading.Monitor，它在_任何托管对象_上提供高性能锁定设施，并额外提供“条件变量”语义用于通知锁保护的状态更改。

Monitor 被实现为一种“混合锁”（hybrid lock）；它同时具备自旋锁（spin-lock）和基于内核的锁（如 Mutex）的特性。其思想是，大多数锁只会被短暂持有，因此与其调用内核去阻塞线程，不如简单地自旋等待锁被释放更省时间。但也不能浪费 CPU 周期一直自旋，因此如果在短暂自旋之后仍未获得锁，实现就会退回到在内核中阻塞。

由于任何对象都可能被用作锁/条件变量，每个对象都必须有一个位置来存储锁信息。这通过“对象头”（object headers）和“同步块”（sync blocks）来实现。

对象头是一个机器字大小的字段，位于每个托管对象之前。它有多种用途，例如存储对象的哈希码。其中一种用途就是保存对象的锁状态。如果每对象所需的数据多于对象头所能容纳，我们就会通过创建一个“同步块”来将对象“膨胀”（inflate）。

同步块存放在同步块表（Sync Block Table）中，并通过同步块索引（sync block indexes）来寻址。每个有关联同步块的对象，会在其对象头中保存该同步块的索引。

对象头和同步块的详细信息定义在 [syncblk.h][https://github.com/dotnet/runtime/blob/main/src/coreclr/vm/syncblk.h]/[.cpp][https://github.com/dotnet/runtime/blob/main/src/coreclr/vm/syncblk.cpp] 中。

如果对象头里有空间，Monitor 会存储当前持有该对象锁的线程的托管线程 ID（若没有线程持有锁则为零（0））。在这种情况下，获取锁很简单：自旋等待直到对象头中的线程 ID 为零，然后以原子方式将其设置为当前线程的托管线程 ID。

如果经过一定次数的自旋仍无法以这种方式获取锁，或者对象头已经被用于其他目的，那么就必须为该对象创建一个同步块。同步块包含额外数据，其中包括一个可用于阻塞当前线程的事件（event），这样我们就能停止自旋并高效地等待锁被释放。

用作条件变量的对象（通过 Monitor.Wait 和 Monitor.Pulse）必须始终被膨胀，因为对象头中没有足够空间保存所需状态。

# 同步：原生

CLR 的原生部分也必须了解线程，因为它会在多个线程上被托管代码调用。这就需要原生同步机制，例如锁、事件等。

ITaskHost API 允许宿主（host）覆盖托管线程的许多方面，包括线程创建、销毁与同步。宿主能够覆盖原生同步这一点，意味着 VM 代码通常不能直接使用原生同步原语（Critical Sections、Mutexes、Events 等），而必须使用 VM 对这些原语的封装。

此外，如上所述，GC 挂起是一种影响 CLR 几乎各个方面的特殊“锁”。VM 中的原生代码如果必须操作 GC 堆对象，就可能进入“协作模式”（cooperative mode），因此“GC 挂起锁”就成为原生 VM 代码（以及托管代码）中最重要的同步机制之一。

原生 VM 代码中主要使用的同步机制是 GC 模式和 Crst。

## GC 模式

如上所述，所有托管代码都在协作模式下运行，因为它可能会操作 GC 堆。通常，原生代码不接触托管对象，因此在抢占模式下运行。但是 VM 中的一些原生代码必须访问 GC 堆，因此必须在协作模式下运行。

原生代码通常不直接操作 GC 模式，而是使用两个宏：GCX\_COOP 和 GCX\_PREEMP。这些进入所需的模式，并建立“持有者”以在退出作用域时使线程恢复到先前的模式。

重要的是要理解 GCX\_COOP 实际上获取了 GC 堆上的锁。当线程处于协作模式时，GC 无法进行。并且原生代码不能像托管代码那样被“劫持”，因此线程将保持在协作模式，直到它显式切换回抢占模式。

因此，不鼓励在原生代码中进入协作模式。在必须进入协作模式的情况下，应尽可能缩短时间。线程不应在此模式下被阻塞，特别是一般不能安全地获取锁。

同样，GCX\_PREEMP 可能会_释放_线程持有的锁。在进入抢占模式之前，必须非常小心地确所有 GC 引用都得到适当保护。

[代码规则](https://github.com/dotnet/runtime/blob/main/docs/coding-guidelines/clr-code-guide.md)文档描述了确保 GC 模式切换安全的必要纪律。

## Crst

正如 Monitor 是托管代码的首选锁定机制一样，Crst 是 VM 代码的首选机制。像 Monitor 一样，Crst 是一种混合锁，它知道主机和 GC 模式。Crst 还通过“锁分级”实现死锁避免，在 [BotR 的 Crst 分级章节](https://github.com/dotnet/runtime/blob/main/docs/coding-guidelines/clr-code-guide.md#2.6.4)中进行了描述。

在协作模式下获取 Crst 通常是非法的，但在绝对必要的情况下会有例外。

# 特殊线程

除了管理由托管代码创建的线程外，CLR 还会为自己的使用创建几个“特殊”线程。

## 终结器线程

此线程在每个运行托管代码的进程中创建。当 GC 确定可终结对象不再可达时，它将该对象放入终结队列。在 GC 结束时，终结器线程收到信号处理当前在此队列中的所有终结器。然后每个对象被逐个出队，并执行其终结器。

此线程还用于执行各种 CLR 内部清理任务，并等待某些外部事件的通知（例如低内存条件，这向 GC 发出信号以更积极地收集）。有关详细信息，请参阅 GCHeap::FinalizerThreadStart。

## GC 线程

当在“并发”或“服务器”模式下运行时，GC 创建一个或多个后台线程以并行执行垃圾回收的各个阶段。这些线程完全由 GC 拥有和管理，并且从不运行托管代码。

## 调试器线程

CLR 在每个托管进程中维护一个原生线程，该线程代表附加的托管调试器执行各种任务。

## AppDomain-Unload 线程

该线程负责卸载 AppDomain。卸载是在一个独立的、CLR 内部线程上完成的，而不是在请求卸载的线程上完成，原因是：a）为卸载逻辑提供有保证的栈空间；b）如果需要，允许发起卸载请求的线程从该 AppDomain 中被回退（unwind）出来。

## ThreadPool 线程

CLR 的 ThreadPool 维护一组托管线程，用于执行用户的“工作项”（work items）。这些托管线程绑定到由 ThreadPool 拥有的原生线程上。ThreadPool 还维护少量原生线程，用于处理诸如“线程注入”（thread injection）、计时器以及“已注册等待”（registered waits）等功能。
