# 公共语言运行时 (CLR) 简介

作者：Vance Morrison ([@vancem](https://github.com/vancem)) - 2007

什么是公共语言运行时 (CLR)？简而言之：

> 公共语言运行时 (CLR) 是一个完整的、高级的虚拟机，旨在支持广泛的编程语言以及它们之间的互操作。

呼，这就有点拗口了。而且这句话本身并没有太多启发性。不过，上面的陈述_确实_很有用，因为它是将被称为 [CLR][http://msdn.microsoft.com/library/8bs2ecf4.aspx] 的庞大而复杂的软件及其功能以一种可理解的方式进行分组的第一步。它为我们提供了一个关于运行时的“万米高空”视角，从中我们可以了解运行时的广泛目标和用途。在从这个高层次理解了 CLR 之后，就更容易深入研究子组件，而不太可能迷失在细节中。

# CLR：一个（非常罕见的）完整的编程平台

每个程序对其运行环境都有惊人数量的依赖。最明显的是，程序是用特定的编程语言编写的，但这只是程序员编织进程序中的众多假设中的第一个。所有有趣的程序都需要某种_运行时库_，允许它们与机器的其他资源（如用户输入、磁盘文件、网络通信等）进行交互。程序还需要以某种方式（通过解释或编译）转换为原生硬件可以直接执行的形式。程序的这些依赖关系如此众多、相互依赖且多样化，以至于编程语言的实现者几乎总是推迟到其他标准来指定它们。例如，C++ 语言并没有指定 C++ 可执行文件的格式。相反，每个 C++ 编译器都绑定到一个特定的硬件架构（例如 X86）和一个操作系统环境（例如 Windows、Linux 或 Mac OS），该环境描述了可执行文件的格式并指定了它是如何被加载的。因此，程序员制作的不是“C++ 可执行文件”，而是“Windows X86 可执行文件”或“Power PC Mac OS 可执行文件”。

虽然利用现有的硬件和操作系统标准通常是一件好事，但它的缺点是将规范绑定到了现有标准的抽象级别。例如，今天没有任何通用的操作系统具有垃圾回收堆的概念。因此，无法使用现有的标准来描述一个利用垃圾回收的接口（例如，来回传递字符串，而不必担心谁负责删除它们）。同样，典型的可执行文件格式只提供了足够运行程序的信息，但没有足够的信息让编译器将其他二进制文件绑定到该可执行文件。例如，C++ 程序通常使用标准库（在 Windows 上称为 msvcrt.dll），其中包含大部分通用功能（如 printf），但仅有该库的存在是不够的。如果没有与之配套的头文件（如 stdio.h），程序员就无法使用该库。因此，现有的可执行文件格式标准不能同时用于描述可以运行的文件格式和指定使程序完整所需的其他信息或二进制文件。

CLR 通过定义一个包含程序完整生命周期所需细节的[非常完整的规范][https://github.com/dotnet/runtime/blob/main/docs/project/dotnet-standards.md]（由 ECMA 标准化）解决了这些问题，从构建和绑定到部署和执行。因此，除此之外，CLR 还指定了：

- 一个具有自己指令集（称为公共中间语言 (CIL)）的感知 GC 的虚拟机，用于指定程序执行的基本操作。这意味着 CLR 不依赖于特定类型的 CPU。
- 用于程序声明（例如类型、字段、方法等）的丰富元数据表示，以便生成其他可执行文件的编译器拥有从“外部”调用功能所需的信息。
- 一个指定如何在文件中准确放置比特位的文件格式，以便你可以正确地谈论不绑定到特定操作系统或计算机硬件的 CLR EXE。
- 已加载程序的生命周期语义，一个 CLR EXE 文件引用另一个 CLR EXE 的机制，以及运行时在执行时如何找到被引用文件的规则。
- 一个利用 CLR 提供的功能（例如垃圾回收、异常或泛型类型）的类库，既提供对基本功能（例如整数、字符串、数组、列表或字典）的访问，也提供对操作系统服务（例如文件、网络或用户交互）的访问。

多语言支持
----------------------

定义、指定和实现所有这些细节是一项巨大的工程，这就是为什么像 CLR 这样完整的抽象非常罕见的原因。事实上，绝大多数这种相当完整的抽象都是为单一语言构建的。例如，Java 运行时、Perl 解释器或早期版本的 Visual Basic 运行时都提供了类似的完整抽象边界。CLR 与这些早期努力的区别在于其多语言性质。除了 Visual Basic（因为它利用了 COM 对象模型）之外，语言内的体验通常非常好，但与其他语言编写的程序进行互操作充其量是非常困难的。互操作之所以困难，是因为这些语言只能通过使用操作系统提供的原语与“外部”语言进行通信。由于操作系统抽象级别如此之低（例如，操作系统没有垃圾回收堆的概念），因此需要不必要的复杂技术。通过提供一个公共语言运行时，CLR 允许语言使用高级构造（例如 GC 收集的结构）相互通信，从而极大地减轻了互操作的负担。

因为运行时是在_许多_语言之间共享的，这意味着可以投入更多资源来更好地支持它。为一种语言构建好的调试器和分析器是一项大量的工作，因此它们只以功能齐全的形式存在于最重要的编程语言中。然而，因为在 CLR 上实现的语言可以重用此基础设施，所以任何特定语言的负担都大大减轻了。也许更重要的是，任何基于 CLR 构建的语言都可以立即访问构建在 CLR 之上的_所有_类库。这个庞大（且不断增长）的（经过调试和支持的）功能体是 CLR 如此成功的巨大原因。

简而言之，运行时是一个完整的规范，规定了必须在文件中放入的确切比特位以创建和运行程序。运行这些文件的虚拟机处于一个适合实现广泛类别的编程语言的高级水平。这个虚拟机，连同在这个虚拟机上运行的不断增长的类库体，就是我们所说的公共语言运行时 (CLR)。

# CLR 的主要目标

现在我们对 CLR 是什么有了基本的了解，稍微回退一点并理解运行时旨在解决的问题是很有用的。在一个非常高的层次上，运行时只有一个目标：

> CLR 的目标是让编程变得容易。

这句话之所以有用，有两个原因。首先，随着运行时的演进，它是一个_非常_有用的指导原则。例如，从根本上说，只有简单的事情才能变得容易，因此向运行时添加**用户可见**的复杂性应该始终受到怀疑。比一个特性的成本/收益比更重要的是它的_增加的暴露复杂性/所有场景的加权收益_比。理想情况下，这个比率是负的（即，新特性通过消除限制或概括现有的特殊情况来降低复杂性）；然而，更典型的情况是，通过最小化暴露的复杂性并最大化该特性增加价值的场景数量，将该比率保持在较低水平。

这个目标如此重要的第二个原因是，**易用性是 CLR 成功的根本原因**。CLR 的成功并不是因为它比编写原生代码更快或更小（事实上，编写良好的原生代码通常会胜出）。CLR 的成功也不是因为它支持的任何特定特性（如垃圾回收、平台独立性、面向对象编程或版本控制支持）。CLR 之所以成功，是因为所有这些特性以及许多其他特性结合在一起，使编程比其他方式容易得多。一些重要但经常被忽视的易用性特性包括：

1. 简化的语言（例如，C# 和 Visual Basic 比 C++ 简单得多）
2. 致力于类库的简单性（例如，我们只有一种字符串类型，它是不可变的；这极大地简化了任何使用字符串的 API）
3. 类库命名的一致性强（例如，要求 API 使用完整的单词和一致的命名约定）
4. 创建应用程序所需的工具链的强大支持（例如，Visual Studio 使构建 CLR 应用程序非常简单，Intellisense 使查找正确的类型和方法来创建应用程序非常容易）。

正是这种对易用性的执着（这与用户模型的简单性密切相关）成为了 CLR 成功的原因。奇怪的是，一些最重要的易用性特性也是最“无聊”的。例如，任何编程环境都可以应用一致的命名约定，但在一个大型类库中实际做到这一点是一项大量的工作。通常，这些努力与其他目标（如保持与现有接口的兼容性）相冲突，或者它们会遇到重大的后勤问题（如在_非常_大的代码库中重命名一个方法的成本）。正是在这种时候，我们必须提醒自己运行时的首要总体目标，并确保我们要优先考虑实现该目标。

# CLR 的基本特性

运行时有许多特性，因此将它们分类如下是有用的：

1. **基本特性** – 对其他特性的设计有广泛影响的特性。这些包括：
    1. 垃圾回收
    2. 内存安全和类型安全
    3. 对编程语言的高级支持。
2. **次要特性** – 由基本特性启用的特性，可能不是许多有用的程序所必需的：
    1. 使用 AppDomain 的程序隔离
    2. 程序安全和沙盒
3. **其他特性** – 所有运行时环境都需要但不需要利用 CLR 基本特性的特性。相反，它们是希望创建一个完整编程环境的结果。其中包括：
    1. 版本控制
    2. 调试/分析
    3. 互操作

## CLR 垃圾回收器 (GC)

在 CLR 提供的所有特性中，垃圾回收器值得特别注意。垃圾回收 (GC) 是自动内存回收的通用术语。在垃圾回收系统中，用户程序不再需要调用特殊的运算符来删除内存。相反，运行时会自动跟踪垃圾回收堆中对内存的所有引用，并不时地遍历这些引用以找出程序仍然可以访问哪些内存。所有其他内存都是_垃圾_，可以重新用于新的分配。

垃圾回收是一个很棒的用户特性，因为它简化了编程。最明显的简化是大多数显式删除操作不再是必需的。虽然移除删除操作很重要，但对程序员的真正价值要微妙得多：

1. 垃圾回收简化了接口设计，因为你不再需要仔细指定接口的哪一侧负责删除跨接口传递的对象。例如，CLR 接口只是返回字符串；它们不接受字符串缓冲区和长度。这意味着它们不必处理缓冲区太小时会发生什么的复杂性。因此，垃圾回收允许运行时中的所有接口比其他方式更简单。
2. 垃圾回收消除了整整一类常见的用户错误。关于特定对象的生命周期犯错是非常容易的，要么删除得太早（导致内存损坏），要么太晚（无法访问的内存泄漏）。由于典型的程序字面上使用数百万个对象，出错的概率相当高。此外，追踪生命周期错误非常困难，特别是如果对象被许多其他对象引用。使这类错误成为不可能避免了很多痛苦。

尽管如此，并不是垃圾回收的有用性使得它在这里值得特别注意。更重要的是它对运行时本身提出的简单要求：

> 垃圾回收要求必须跟踪对 GC 堆的所有引用。

虽然这是一个非常简单的要求，但它实际上对运行时有着深远的影响。你可以想象，知道任何时刻指向对象的每个指针在哪里是相当困难的。不过，我们要考虑一个缓解因素。从技术上讲，这个要求只适用于 GC 实际需要发生的时候（因此，理论上我们不需要一直知道所有 GC 引用在哪里，只需要在 GC 的时候知道）。然而，实际上，由于 CLR 的另一个特性，这种缓解并不完全适用：

> CLR 支持单个进程内的多个并发执行线程。

在任何时候，其他执行线程可能会执行需要垃圾回收的分配。并发执行线程之间的确切操作顺序是不确定的。我们无法确切知道当另一个线程请求触发 GC 的分配时，一个线程正在做什么。因此，GC 实际上可能随时发生。现在 CLR 不需要_立即_响应另一个线程做 GC 的愿望，所以 CLR 有一点“回旋余地”，不需要在_所有_执行点跟踪 GC 引用，但它_确实_需要在足够多的地方这样做，以便它可以保证“及时”响应由另一个线程上的分配引起的做 GC 的需求。

这意味着 CLR 需要_几乎_一直在跟踪对 GC 堆的_所有_引用。由于 GC 引用可能驻留在机器寄存器、局部变量、静态变量或其他字段中，因此有相当多的内容需要跟踪。这些位置中最麻烦的是机器寄存器和局部变量，因为它们与用户代码的实际执行密切相关。实际上，这意味着操作 GC 引用的_机器码_还有另一个要求：它必须跟踪它使用的所有 GC 引用。这意味着编译器需要做一些额外的工作来发出指令来跟踪这些引用。

要了解更多信息，请查看 [垃圾回收器设计文档](garbage-collection.md)。

## “托管代码”的概念

做额外的记账工作以便它可以“几乎所有时间”报告其所有活动 GC 引用的代码称为_托管代码_（因为它由 CLR “管理”）。不这样做代码称为_非托管代码_。因此，CLR 之前存在的所有代码都是非托管代码，特别是，所有操作系统代码都是非托管的。

### 栈展开问题

显然，因为托管代码需要操作系统的服务，所以有时托管代码会调用非托管代码。同样，因为操作系统最初启动了托管代码，所以也有非托管代码调用托管代码的时候。因此，一般来说，如果你在任意位置停止托管程序，调用栈将混合有托管代码创建的帧和非托管代码创建的帧。

非托管代码的栈帧除了运行程序之外没有任何要求。特别是，不要求它们可以在运行时被_展开_以找到它们的调用者。这意味着如果你在任意位置停止程序，而它碰巧在非托管方法中，通常没有办法<sup>[1]</sup>找到调用者是谁。你只能在调试器中这样做，因为符号信息（PDB 文件）中存储了额外的信息。此信息不保证可用（这就是为什么你有时在调试器中得不到好的堆栈跟踪）。这对于托管代码来说是非常成问题的，因为任何无法展开的栈实际上可能包含托管代码帧（其中包含需要报告的 GC 引用）。

托管代码对其有额外的要求：它不仅必须跟踪它在执行期间使用的所有 GC 引用，而且还必须能够展开到它的调用者。此外，每当从托管代码过渡到非托管代码（或反之）时，托管代码还必须做额外的记账工作，以弥补非托管代码不知道如何展开其栈帧的事实。实际上，托管代码将包含托管帧的栈部分链接在一起。因此，虽然如果不使用额外信息可能仍然无法展开非托管栈帧，但总是可以找到对应于托管代码的栈块并枚举这些块中的托管帧。

[1] 最近的平台 ABI（应用二进制接口）定义了编码此信息的约定，但是通常没有严格要求所有代码都遵循它们。

### 托管代码的“世界”

结果是，在进出托管代码的每个转换处都需要特殊的记账。托管代码实际上生活在自己的“世界”中，除非 CLR 知道，否则执行无法进入或离开。这两个世界在非常真实的意义上彼此不同（在任何时间点，代码都在_托管世界_或_非托管世界_中）。此外，由于托管代码的执行是以 CLR 格式（及其[公共中间语言][cil-spec_cn.md] (CIL)）指定的，并且是 CLR 将其转换为在原生硬件上运行，因此 CLR 对该执行的具体行为有_多得多的_控制权。例如，CLR 可以改变从对象获取字段或调用函数的含义。事实上，CLR 正是这样做的，以支持创建 MarshalByReference 对象的能力。这些看起来是普通的本地对象，但实际上可能存在于另一台机器上。简而言之，CLR 的托管世界有大量的_执行钩子_，它可以用来支持将在接下来的部分中更详细解释的强大功能。

此外，托管代码还有一个可能不那么明显的含义。在非托管世界中，不允许 GC 指针（因为它们无法被跟踪），并且从托管代码转换到非托管代码有记账成本。这意味着虽然你_可以_从托管代码调用任意非托管函数，但这通常并不令人愉快。非托管方法不在其参数和返回类型中使用 GC 对象，这意味着这些非托管函数创建和使用的任何“对象”或“对象句柄”都需要显式释放。这很不幸。因为这些 API 不能利用 CLR 功能（如异常或继承），所以与在托管代码中设计接口的方式相比，它们的用户体验往往“不匹配”。

其结果是，在向托管代码开发人员公开之前，非托管接口几乎总是被_包装_。例如，访问文件时，你不使用操作系统提供的 Win32 CreateFile 函数，而是使用包装此功能的托管 System.IO.File 类。实际上，非托管功能极少直接暴露给用户。

虽然这种包装在某种程度上似乎是“坏的”（更多的代码似乎没有做太多事情），但实际上它是好的，因为它实际上增加了相当多的价值。记住，直接公开非托管接口总是_可能的_；我们_选择_包装该功能。为什么？因为运行时的首要目标是**让编程变得容易**，通常非托管函数不够容易。大多数情况下，非托管接口在设计时并没有考虑到易用性，而是为了完整性而调整。任何查看 CreateFile 或 CreateProcess 参数的人都很难将它们描述为“容易”。幸运的是，当功能进入托管世界时，它得到了“整容”，虽然这种改造通常是非常“低科技”的（不需要比重命名、简化和组织功能更复杂的东西），但它也非常有用。为 CLR 创建的非常重要的文档之一是 [框架设计指南][fx-design-guidelines_cn.md]。这份 800 多页的文档详细介绍了制作新的托管类库的最佳实践。

因此，我们现在已经看到，托管代码（与 CLR 密切相关）在两个重要方面不同于非托管代码：

1. 高科技：代码生活在一个独特的世界中，CLR 在非常精细的级别（可能到单个指令）控制程序执行的大多数方面，并且 CLR 检测执行何时进入和退出托管代码。这使得各种有用的功能成为可能。
2. 低科技：从托管代码到非托管代码存在转换成本的事实，以及非托管代码不能使用 GC 对象的事实，鼓励了将大多数非托管代码包装在托管外观中的做法。这意味着接口可以进行“整容”以简化它们，并符合一套统一的命名和设计指南，从而产生一定程度的一致性和可发现性，这在非托管世界中本可能存在，但实际上并不存在。

这些特征中的**两者**对于托管代码的成功都非常重要。

## 内存和类型安全

垃圾回收器启用的一个不太明显但影响深远的特性是内存安全。内存安全的不变性非常简单：如果程序只访问已分配（且未释放）的内存，则它是内存安全的。这简单地意味着你没有“野生”（悬空）指针指向随机位置（更准确地说，指向过早释放的内存）。显然，内存安全是我们希望所有程序都具备的属性。悬空指针总是错误，追踪它们通常非常困难。

> GC _是_提供内存安全保证所必需的

人们很快就能明白垃圾回收器如何帮助确保内存安全，因为它消除了用户过早释放内存（从而访问未正确分配的内存）的可能性。可能不那么明显的是，如果你想保证内存安全（即使程序员_不可能_创建内存不安全的程序），实际上你无法避免拥有垃圾回收器。其原因是，非平凡的程序需要_堆样式_（动态）内存分配，其中对象的生命周期基本上受任意程序控制（不像栈分配或静态分配的内存，它们有高度受限的分配协议）。在这样一个不受约束的环境中，通过程序分析来确定特定的显式删除语句是否正确是不可能的。实际上，确定删除是否正确的唯一方法是在运行时检查它。这正是 GC 所做的（检查内存是否仍然存活）。因此，对于任何需要堆样式内存分配的程序，如果你想保证内存安全，你需要一个 GC。

虽然 GC 对于确保内存安全是必要的，但它是不够的。GC 不会阻止程序索引超出数组末尾或访问对象末尾之外的字段（如果你使用基址和偏移量计算字段的地址，这是可能的）。然而，如果我们确实阻止了这些情况，那么我们确实可以使程序员不可能创建内存不安全的程序。

虽然 [公共中间语言][cil-spec_cn.md] (CIL) _确实_ 有可以获取和设置任意内存（从而违反内存安全）的运算符，但它也有以下内存安全运算符，并且 CLR 强烈鼓励在大多数编程中使用它们：

1. 字段获取运算符（LDFLD, STFLD, LDFLDA），按名称获取（读取）、设置和获取字段的地址。
2. 数组获取运算符（LDELEM, STELEM, LDELEMA），按索引获取、设置和获取数组元素的地址。所有数组都包含一个指定其长度的标签。这有助于在每次访问之前进行自动边界检查。

通过在用户代码中使用这些运算符而不是较低级别的（和不安全的）_内存获取_运算符，以及避免其他不安全的 [CIL][cil-spec_cn.md] 运算符（例如，那些允许你跳转到任意，因此可能是坏位置的运算符），人们可以想象构建一个内存安全但仅此而已的系统。然而，CLR 并不这样做。相反，CLR 强制执行更强的不变性：类型安全。

为了实现类型安全，从概念上讲，每次内存分配都与特定类型相关联。所有作用于内存位置的操作符在概念上也标记着其有效的类型。类型安全要求标记为特定类型的内存只能执行该类型允许的操作。这不仅确保了内存安全（无悬空指针），还为每种具体类型提供了额外保障。

其中最重要的类型特异性保证之一，是确保类型（尤其是字段）关联的可见性属性得到强制执行。因此，若某个字段被声明为私有（仅限该类型的方法访问），则所有其他类型安全的代码都将严格遵守该隐私性。例如，某个类型可能声明一个计数字段，用于表示表中项的数量。假设计数字段和表字段均为私有，且仅有特定代码会同时更新二者，此时便能获得强有力的保证（覆盖所有类型安全代码）：计数值与表中项目数量始终保持同步。程序员在分析程序时，无论是否意识到，始终都在运用类型安全这一概念。CLR将类型安全从单纯的编程语言/编译器约定，提升为可在运行时严格执行的机制。

### 可验证代码 - 强制执行内存和类型安全

从概念上讲，为确保类型安全，程序执行的每项操作都必须经过检查，以确保其操作的内存类型与该操作兼容。虽然系统可以在运行时完成所有检查，但这会导致速度极慢。因此，CLR引入了[CIL](http://download.microsoft.com/download/7/3/3/733AD403-90B2-4064-A81E-01035A7FE13C/MS%20Partition%20III.pdf)验证机制：在代码运行前对[CIL](http://download.microsoft.com/download/7/3/3/733AD403-90B2-4064-A81E-01035A7FE13C/MS%20Partition%20III.pdf)进行静态分析，以确认大多数操作确实符合类型安全要求。仅当静态分析无法完成全部工作时，才需要运行时检查。实际中，所需的运行时检查数量非常有限，主要包括以下操作：

1. 将指向基类型的指针转换为指向派生类型的指针（相反方向可以静态检查）
2. 数组边界检查（就像我们在内存安全中看到的那样）
3. 将指针数组中的元素赋值为新的（指针）值。仅因为 CLR 数组具有宽松的转换规则才需要这种特殊检查（稍后会详细介绍...）

请注意，这些检查的需求对运行时环境提出了要求。具体而言：

1. GC堆中的所有内存都必须标记其类型（以便实现强制转换运算符）。该类型信息必须在运行时可用，且必须足够丰富以判断强制转换是否有效（例如，运行时需要了解继承层次结构）。事实上，GC堆中每个对象的首字段都指向表示其类型的运行时数据结构。
2. 所有数组必须记录其大小（用于边界检查）。
3. 数组必须完整记录其元素类型的信息。

幸运的是，最昂贵的要求（为堆中的每个项目打标记）本来就是支持垃圾回收所必需的（GC 需要知道每个对象中哪些字段包含需要扫描的引用），因此为提供类型安全而增加的额外成本很低。

因此，通过验证代码的 CIL，并进行少量运行时检查，CLR 就能确保类型安全（以及内存安全）。然而，这种额外的安全性也会在编程灵活性上付出代价。虽然 CLR 的确提供了通用的内存读取运算符，但为了让代码可验证，这些运算符只能以非常受限的方式使用。尤其是，所有指针算术运算在今天都会无法通过验证。因此，许多经典的 C 或 C++ 约定都不能用于可验证代码；你必须改用数组。虽然这在一定程度上限制了编程，但其实并不糟（数组相当强大），而且收益（“恶性”漏洞大幅减少）也非常真实。

CLR 强烈鼓励使用可验证的、类型安全的代码。即使这样，有时（主要是处理非托管代码时）也需要不可验证的编程。CLR 允许这样做，但这里的最佳实践是尽可能限制这种不安全的代码。典型的程序只有极小一部分代码需要是不安全的，其余部分可以是类型安全的。

## 高级特性

支持垃圾回收对运行时产生了深远的影响，因为它要求所有代码都必须支持额外的记账。对类型安全的渴望也产生了深远的影响，要求程序的描述（[CIL][http://download.microsoft.com/download/7/3/3/733AD403-90B2-4064-A81E-01035A7FE13C/MS%20Partition%20III.pdf]）处于高级水平，其中字段和方法具有详细的类型信息。对类型安全的渴望还迫使 [CIL][http://download.microsoft.com/download/7/3/3/733AD403-90B2-4064-A81E-01035A7FE13C/MS%20Partition%20III.pdf] 支持其他类型安全的高级编程构造。以类型安全的方式表达这些构造也需要运行时支持。这些高级特性中最重要的两个用于支持面向对象编程的两个基本元素：继承和虚调用分派。

### 面向对象编程

从机械意义上讲，继承相对简单。基本思想是，如果类型 `derived` 的字段是类型 `base` 字段的超集，并且 `derived` 对其字段进行布局使得 `base` 的字段排在前面，那么任何期望指向 `base` 实例的指针的代码都可以被赋予一个指向 `derived` 实例的指针，并且代码将“正常工作”。因此，类型 `derived` 被称为继承自 `base`，这意味着它可以在任何可以使用 `base` 的地方使用。代码变得_多态_，因为相同的代码可以用于许多不同的类型。因为运行时需要知道哪些类型强制转换是可能的，所以运行时必须形式化指定继承的方式，以便它可以验证类型安全。

虚调用分派将继承的多态性推广开来。它允许基类型声明将被派生类型重写的方法。使用 `base` 类型变量的代码可以期望：对虚方法的调用会在运行时依据对象的实际类型，被分派到正确的重写方法上。尽管这种运行时分派逻辑本可以在没有运行时直接支持的情况下，仅用原始的 [CIL](http://download.microsoft.com/download/7/3/3/733AD403-90B2-4064-A81E-01035A7FE13C/MS%20Partition%20III.pdf) 指令来实现，但它会遭遇两个重要缺点

1. 它将不是类型安全的（分派表中的错误会造成灾难性错误）
2. 每个面向对象语言可能会实现略有不同的虚分派逻辑实现方式。结果，语言之间的互操作性将受到影响（一种语言无法继承用另一种语言实现的基类型）。

出于这个原因，CLR 直接支持基本的面向对象特性。在某种程度上，CLR 试图使其继承模型“语言中立”，即不同的语言可能仍然共享相同的继承层次结构。不幸的是，这并不总是可能的。特别是，多重继承可以用许多不同的方式实现。CLR 选择不支持带字段类型的多重继承，但确实支持从特殊类型（称为接口）的多重继承，这些类型被限制为没有字段。

重要的是要记住，虽然运行时支持这些面向对象的概念，但并不强制使用它们。没有继承概念的语言（例如，函数式语言）根本不使用这些设施。

### 值类型（和装箱）

面向对象编程的一个深刻而微妙的方面是对象标识的概念：即对象（通过单独的分配调用分配）即使所有字段值都相同，也可以区分的概念。对象标识与对象是通过引用（指针）而不是通过值访问的事实密切相关。如果两个变量持有相同的对象（它们的指针指向相同的内存），那么对其中一个变量的更新将影响另一个变量。

不幸的是，对象标识这一概念并不适用于所有类型的语义。尤其是，程序员通常不会把整数当作对象来思考。如果数字 `1` 在两个不同地方被分配出来，程序员一般希望认为这两个东西是相等的，当然也不希望对其中一个实例的更新会影响另一个。事实上，有一大类称为 `functional languages` 的编程语言完全避免对象标识和引用语义。

虽然可以构建一个“纯”的面向对象系统，使得一切（包括整数）都是对象（Smalltalk-80 就是这样做的），但要想获得高效实现，就需要做相当多的实现层面的“体操”，以打破这种统一性。其他语言（Perl、Java、JavaScript）采取更务实的观点：把某些类型（如整数）按值处理，把另一些类型按引用处理。CLR 也选择了混合模型，但与其他语言不同的是，它允许用户自定义值类型。

值类型的关键特征是：

1. 每个值类型的局部变量、字段或数组元素，都拥有该值数据的一份独立拷贝。
2. 当一个变量、字段或数组元素被赋值给另一个时，会复制其值。
3. 相等性始终只根据变量中的数据来定义（而不是根据其位置）。
4.  每个值类型还对应一个引用类型，它只有一个隐式的、未命名的字段。这称为它的装箱值（boxed value）。装箱后的值类型可以参与继承并具有对象标识（尽管强烈不建议使用装箱值类型的对象标识）。

值类型非常接近地模拟了 C（和 C++）中 struct（或 C++ class）的概念。像 C 一样，你可以拥有指向值类型的指针，但指针是一种不同于 struct 类型的类型。

### 异常

CLR 直接支持的另一个高级编程构造是异常。异常是一种语言特性，它允许程序员在发生故障的位置抛出一个任意对象。当一个对象被抛出时，运行时会在调用栈中搜索声明自己能够捕获该异常的方法。如果找到了这样的 catch 声明，执行就会从那个位置继续。异常的价值在于，它避免了一个非常常见的错误：没有检查被调用的方法是否失败。既然异常有助于避免程序员犯错（从而让编程更容易），CLR 支持它也就不足为奇了。

顺带一提，异常避免了一类常见错误（不检查失败），但并不能防止另一类错误（在发生失败时把数据结构恢复到一致状态）。这意味着在捕获异常之后，一般很难知道继续执行是否会引发额外的错误（由第一次失败导致）。这是 CLR 未来很可能会增加价值的一个领域。不过，即便以目前的实现方式来看，异常也是一个巨大的进步（只是我们还需要走得更远）。

### 参数化类型（泛型）

在 CLR 2.0 版本之前，唯一的参数化类型是数组。其他所有容器（例如哈希表、列表、队列等）都只能在通用的 `Object` 类型上运作。无法创建 `List` 或 `Dictionary<KeyT, ValueT>` 的确会对性能产生负面影响，因为值类型在进入集合时需要被装箱，而在取出元素时需要显式强制转换。尽管如此，这并不是向 CLR 添加参数化类型的首要原因。主要原因是：参数化类型让编程更容易。

其中原因比较微妙。最容易看出其影响的方法，是想象一下：如果把所有类型都替换成通用的 `Object` 类型，一个类库会变成什么样。这种效果有点类似于在 JavaScript 这类动态类型语言中发生的事情。在那样的世界里，程序员更容易写出错误（但仍然类型安全）的程序。那个方法的参数到底应该是一个列表？一个字符串？一个整数？还是以上任意一种？仅从方法签名已经不再显而易见。更糟的是，当一个方法返回 `Object` 时，其他哪些方法可以把它作为参数来接受？典型框架里有成百上千个方法；如果它们的参数全都是 `Object`，就会变得非常难以判断：某个 `Object` 实例对于方法将要执行的操作来说是否有效。简而言之，强类型帮助程序员更清晰地表达意图，并允许工具（例如编译器）去强制执行这些意图，从而带来巨大的生产力提升。

这些好处不会因为类型被放进 `List` 或 `Dictionary` 里就消失，因此参数化类型显然是有价值的。真正的问题只在于：参数化类型更适合被视为一种语言特性，在生成 CIL 时就被“编译消去”；还是应该在运行时获得一等公民式的支持。两种实现当然都可行。CLR 团队选择了一等支持，因为如果没有它，不同语言会用不同方式来实现参数化类型，这意味着互操作性即便能做到，也会非常笨拙。此外，对于参数化类型来说，表达程序员意图在类库接口处最有价值。如果 CLR 不正式支持参数化类型，那么类库也无法使用它们，一个重要的易用性特性就会丢失。

### 程序即数据（反射 API）

CLR 的基础是垃圾回收、类型安全以及高级语言特性。这些基本特性迫使对程序（CIL）的规格描述必须相当高层。一旦这些数据在运行时存在（这在 C 或 C++ 程序中并不成立），显然把这些丰富的数据暴露给最终程序员同样很有价值。这个想法促成了 `System.Reflection` 接口的创建（之所以这样命名，是因为它们允许程序“看见”（反观）自己）。该接口允许你探索程序几乎所有方面（有哪些类型、继承关系是什么、有哪些方法和字段）。事实上，信息丢失得如此之少，以至于可以对托管代码实现非常优秀的“反编译器”（例如 [*NET Reflector*](http://www.red-gate.com/products/reflector/)）。虽然关心知识产权保护的人会对这种能力感到震惊（这可以通过一种称为混淆程序的操作，刻意破坏信息来缓解），但这种反编译之所以可能，本身就是托管代码在运行时可获得信息之丰富的明证。

除了在运行时检查程序之外，也可以对程序执行操作（例如调用方法、设置字段等），并且更强大的是，可以在运行时从零开始生成代码（`System.Reflection.Emit`）。事实上，运行时类库就利用这种能力来创建用于字符串匹配的专用代码（`System.Text.RegularExpressions`），以及生成用于将对象“序列化”以存入文件或通过网络发送的代码。这样的能力在过去几乎不可行（你得自己写一个编译器！），但借助运行时，对于更多编程问题来说都触手可及。

虽然反射能力确实强大，但使用时应当谨慎。反射通常比其静态编译对应方式慢得多。更重要的是，自指系统在本质上更难理解。这意味着像 `Reflection` 或 `Reflection.Emit` 这样强大的特性，只有在其价值清晰且显著时才应使用。

# 其他特性

运行时特性的最后一组，是那些与 CLR 的基础架构（GC、类型安全、高层规格描述）无关，但仍然满足任何完整运行时系统重要需求的能力。

## 与非托管代码的互操作

托管代码需要能够使用由非托管代码实现的功能。互操作主要有两种“风格”。第一种是直接调用非托管函数的能力（称为 Platform Invoke 或 PINVOKE）。非托管代码还具有一种更结构化的面向对象互操作模型，称为 COM（组件对象模型），它比临时拼凑的方法调用更有结构。由于 COM 和 CLR 都各自有对象模型以及其他约定（例如错误如何处理、对象生命周期如何管理等），如果 CLR 具备专门支持，就能更好地与 COM 代码互操作。

## 提前编译 (AOT)

在 CLR 模型中，托管代码以 CIL 形式分发，而不是以本机代码分发。翻译为本机代码发生在运行时。作为一种优化，由 CIL 生成的本机代码可以通过一个名为 `crossgen` 的工具保存到文件中（类似于 .NET Framework 的 NGEN 工具）。这避免了运行时的大量编译时间，并且非常重要，因为类库规模非常庞大。

## 线程

CLR 从一开始就充分预见到：托管代码需要支持多线程程序。最初，CLR 类库就包含 `System.Threading.Thread` 类，它是对操作系统“执行线程”概念的 1 对 1 封装。然而，由于它只是对操作系统线程的包装，创建一个 `System.Threading.Thread` 的成本相对较高（启动需要毫秒级时间）。这对许多操作来说没问题，但有一种编程风格会创建非常小的工作项（只需几十毫秒）。这在服务器代码中非常常见（例如每个任务只服务一个网页），或在试图利用多处理器的代码中很常见（例如多核排序算法）。为支持这种场景，CLR 引入了 ThreadPool 的概念，使得可以把 WorkItems 入队。在这种方案中，CLR 负责创建执行工作所需的线程。虽然 CLR 确实以 `System.Threading.Threadpool` 类的形式直接暴露了 ThreadPool，但更推荐的机制是使用[任务并行库（Task Parallel Library）](https://msdn.microsoft.com/en-us/library/dd460717(v=vs.110).aspx)，它为常见的并发控制形式提供了额外支持。

从实现角度看，ThreadPool 的重要创新在于：它负责确保使用最优数量的线程来分派工作。CLR 通过一个反馈系统来做到这一点：它监控吞吐率和线程数量，并调整线程数以最大化吞吐量。这非常好，因为程序员现在主要可以从“暴露并行性”的角度思考（即创建工作项），而不必去处理更微妙的问题：确定合适的并行度（这取决于工作负载以及程序运行的硬件）。

# 总结和资源

呼！运行时做了很多事！仅仅描述运行时的一些特性就已经用了很多页，更不用说内部细节了。不过，希望这篇介绍能为更深入理解这些内部细节提供一个有用的框架。这个框架的基本提纲是：

- 运行时是支持编程语言的完整框架
- 运行时的目标是让编程变得容易。
- 运行时的基本特性是：
  - 垃圾回收
  - 内存和类型安全
  - 对高级语言特性的支持

## 有用的链接

- [MSDN CLR 条目][clr]
- [维基百科 CLR 条目](http://en.wikipedia.org/wiki/Common_Language_Runtime)
- [ECMA 公共语言基础设施 (CLI) 标准][ecma-spec]
- [.NET 框架设计指南](http://msdn.microsoft.com/en-us/library/ms229042.aspx)
- [CoreCLR 仓库文档](README.md)

[clr]: http://msdn.microsoft.com/library/8bs2ecf4.aspx
[ecma-spec]: ../../../project/dotnet-standards.md
[cil-spec]: http://download.microsoft.com/download/7/3/3/733AD403-90B2-4064-A81E-01035A7FE13C/MS%20Partition%20III.pdf
[fx-design-guidelines]: http://msdn.microsoft.com/en-us/library/ms229042.aspx
