# 公共语言运行时 (CLR) 简介

作者：Vance Morrison ([@vancem](https://github.com/vancem)) - 2007

什么是公共语言运行时 (CLR)？简而言之：

> 公共语言运行时 (CLR) 是一个完整的、高级的虚拟机，旨在支持广泛的编程语言以及它们之间的互操作。

呼，这就有点拗口了。而且这句话本身并没有太多启发性。不过，上面的陈述_确实_很有用，因为它是将被称为 [CLR][http://msdn.microsoft.com/library/8bs2ecf4.aspx] 的庞大而复杂的软件及其功能以一种可理解的方式进行分组的第一步。它为我们提供了一个关于运行时的“万米高空”视角，从中我们可以了解运行时的广泛目标和用途。在从这个高层次理解了 CLR 之后，就更容易深入研究子组件，而不太可能迷失在细节中。

# CLR：一个（非常罕见的）完整的编程平台

每个程序对其运行环境都有惊人数量的依赖。最明显的是，程序是用特定的编程语言编写的，但这只是程序员编织进程序中的众多假设中的第一个。所有有趣的程序都需要某种_运行时库_，允许它们与机器的其他资源（如用户输入、磁盘文件、网络通信等）进行交互。程序还需要以某种方式（通过解释或编译）转换为原生硬件可以直接执行的形式。程序的这些依赖关系如此众多、相互依赖且多样化，以至于编程语言的实现者几乎总是推迟到其他标准来指定它们。例如，C++ 语言并没有指定 C++ 可执行文件的格式。相反，每个 C++ 编译器都绑定到一个特定的硬件架构（例如 X86）和一个操作系统环境（例如 Windows、Linux 或 Mac OS），该环境描述了可执行文件的格式并指定了它是如何被加载的。因此，程序员制作的不是“C++ 可执行文件”，而是“Windows X86 可执行文件”或“Power PC Mac OS 可执行文件”。

虽然利用现有的硬件和操作系统标准通常是一件好事，但它的缺点是将规范绑定到了现有标准的抽象级别。例如，今天没有任何通用的操作系统具有垃圾回收堆的概念。因此，无法使用现有的标准来描述一个利用垃圾回收的接口（例如，来回传递字符串，而不必担心谁负责删除它们）。同样，典型的可执行文件格式只提供了足够运行程序的信息，但没有足够的信息让编译器将其他二进制文件绑定到该可执行文件。例如，C++ 程序通常使用标准库（在 Windows 上称为 msvcrt.dll），其中包含大部分通用功能（如 printf），但仅有该库的存在是不够的。如果没有与之配套的头文件（如 stdio.h），程序员就无法使用该库。因此，现有的可执行文件格式标准不能同时用于描述可以运行的文件格式和指定使程序完整所需的其他信息或二进制文件。

CLR 通过定义一个包含程序完整生命周期所需细节的[非常完整的规范][https://github.com/dotnet/runtime/blob/main/docs/project/dotnet-standards.md]（由 ECMA 标准化）解决了这些问题，从构建和绑定到部署和执行。因此，除此之外，CLR 还指定了：

- 一个具有自己指令集（称为公共中间语言 (CIL)）的感知 GC 的虚拟机，用于指定程序执行的基本操作。这意味着 CLR 不依赖于特定类型的 CPU。
- 用于程序声明（例如类型、字段、方法等）的丰富元数据表示，以便生成其他可执行文件的编译器拥有从“外部”调用功能所需的信息。
- 一个指定如何在文件中准确放置比特位的文件格式，以便你可以正确地谈论不绑定到特定操作系统或计算机硬件的 CLR EXE。
- 已加载程序的生命周期语义，一个 CLR EXE 文件引用另一个 CLR EXE 的机制，以及运行时在执行时如何找到被引用文件的规则。
- 一个利用 CLR 提供的功能（例如垃圾回收、异常或泛型类型）的类库，既提供对基本功能（例如整数、字符串、数组、列表或字典）的访问，也提供对操作系统服务（例如文件、网络或用户交互）的访问。

多语言支持
----------------------

定义、指定和实现所有这些细节是一项巨大的工程，这就是为什么像 CLR 这样完整的抽象非常罕见的原因。事实上，绝大多数这种相当完整的抽象都是为单一语言构建的。例如，Java 运行时、Perl 解释器或早期版本的 Visual Basic 运行时都提供了类似的完整抽象边界。CLR 与这些早期努力的区别在于其多语言性质。除了 Visual Basic（因为它利用了 COM 对象模型）之外，语言内的体验通常非常好，但与其他语言编写的程序进行互操作充其量是非常困难的。互操作之所以困难，是因为这些语言只能通过使用操作系统提供的原语与“外部”语言进行通信。由于操作系统抽象级别如此之低（例如，操作系统没有垃圾回收堆的概念），因此需要不必要的复杂技术。通过提供一个公共语言运行时，CLR 允许语言使用高级构造（例如 GC 收集的结构）相互通信，从而极大地减轻了互操作的负担。

因为运行时是在_许多_语言之间共享的，这意味着可以投入更多资源来更好地支持它。为一种语言构建好的调试器和分析器是一项大量的工作，因此它们只以功能齐全的形式存在于最重要的编程语言中。然而，因为在 CLR 上实现的语言可以重用此基础设施，所以任何特定语言的负担都大大减轻了。也许更重要的是，任何基于 CLR 构建的语言都可以立即访问构建在 CLR 之上的_所有_类库。这个庞大（且不断增长）的（经过调试和支持的）功能体是 CLR 如此成功的巨大原因。

简而言之，运行时是一个完整的规范，规定了必须在文件中放入的确切比特位以创建和运行程序。运行这些文件的虚拟机处于一个适合实现广泛类别的编程语言的高级水平。这个虚拟机，连同在这个虚拟机上运行的不断增长的类库体，就是我们所说的公共语言运行时 (CLR)。

# CLR 的主要目标

现在我们对 CLR 是什么有了基本的了解，稍微回退一点并理解运行时旨在解决的问题是很有用的。在一个非常高的层次上，运行时只有一个目标：

> CLR 的目标是让编程变得容易。

这句话之所以有用，有两个原因。首先，随着运行时的演进，它是一个_非常_有用的指导原则。例如，从根本上说，只有简单的事情才能变得容易，因此向运行时添加**用户可见**的复杂性应该始终受到怀疑。比一个特性的成本/收益比更重要的是它的_增加的暴露复杂性/所有场景的加权收益_比。理想情况下，这个比率是负的（即，新特性通过消除限制或概括现有的特殊情况来降低复杂性）；然而，更典型的情况是，通过最小化暴露的复杂性并最大化该特性增加价值的场景数量，将该比率保持在较低水平。

这个目标如此重要的第二个原因是，**易用性是 CLR 成功的根本原因**。CLR 的成功并不是因为它比编写原生代码更快或更小（事实上，编写良好的原生代码通常会胜出）。CLR 的成功也不是因为它支持的任何特定特性（如垃圾回收、平台独立性、面向对象编程或版本控制支持）。CLR 之所以成功，是因为所有这些特性以及许多其他特性结合在一起，使编程比其他方式容易得多。一些重要但经常被忽视的易用性特性包括：

1. 简化的语言（例如，C# 和 Visual Basic 比 C++ 简单得多）
2. 致力于类库的简单性（例如，我们只有一种字符串类型，它是不可变的；这极大地简化了任何使用字符串的 API）
3. 类库命名的一致性强（例如，要求 API 使用完整的单词和一致的命名约定）
4. 创建应用程序所需的工具链的强大支持（例如，Visual Studio 使构建 CLR 应用程序非常简单，Intellisense 使查找正确的类型和方法来创建应用程序非常容易）。

正是这种对易用性的执着（这与用户模型的简单性密切相关）成为了 CLR 成功的原因。奇怪的是，一些最重要的易用性特性也是最“无聊”的。例如，任何编程环境都可以应用一致的命名约定，但在一个大型类库中实际做到这一点是一项大量的工作。通常，这些努力与其他目标（如保持与现有接口的兼容性）相冲突，或者它们会遇到重大的后勤问题（如在_非常_大的代码库中重命名一个方法的成本）。正是在这种时候，我们必须提醒自己运行时的首要总体目标，并确保我们要优先考虑实现该目标。

# CLR 的基本特性

运行时有许多特性，因此将它们分类如下是有用的：

1. **基本特性** – 对其他特性的设计有广泛影响的特性。这些包括：
    1. 垃圾回收
    2. 内存安全和类型安全
    3. 对编程语言的高级支持。
2. **次要特性** – 由基本特性启用的特性，可能不是许多有用的程序所必需的：
    1. 使用 AppDomain 的程序隔离
    2. 程序安全和沙盒
3. **其他特性** – 所有运行时环境都需要但不需要利用 CLR 基本特性的特性。相反，它们是希望创建一个完整编程环境的结果。其中包括：
    1. 版本控制
    2. 调试/分析
    3. 互操作

## CLR 垃圾回收器 (GC)

在 CLR 提供的所有特性中，垃圾回收器值得特别注意。垃圾回收 (GC) 是自动内存回收的通用术语。在垃圾回收系统中，用户程序不再需要调用特殊的运算符来删除内存。相反，运行时会自动跟踪垃圾回收堆中对内存的所有引用，并不时地遍历这些引用以找出程序仍然可以访问哪些内存。所有其他内存都是_垃圾_，可以重新用于新的分配。

垃圾回收是一个很棒的用户特性，因为它简化了编程。最明显的简化是大多数显式删除操作不再是必需的。虽然移除删除操作很重要，但对程序员的真正价值要微妙得多：

1. 垃圾回收简化了接口设计，因为你不再需要仔细指定接口的哪一侧负责删除跨接口传递的对象。例如，CLR 接口只是返回字符串；它们不接受字符串缓冲区和长度。这意味着它们不必处理缓冲区太小时会发生什么的复杂性。因此，垃圾回收允许运行时中的所有接口比其他方式更简单。
2. 垃圾回收消除了整整一类常见的用户错误。关于特定对象的生命周期犯错是非常容易的，要么删除得太早（导致内存损坏），要么太晚（无法访问的内存泄漏）。由于典型的程序字面上使用数百万个对象，出错的概率相当高。此外，追踪生命周期错误非常困难，特别是如果对象被许多其他对象引用。使这类错误成为不可能避免了很多痛苦。

尽管如此，并不是垃圾回收的有用性使得它在这里值得特别注意。更重要的是它对运行时本身提出的简单要求：

> 垃圾回收要求必须跟踪对 GC 堆的所有引用。

虽然这是一个非常简单的要求，但它实际上对运行时有着深远的影响。你可以想象，知道任何时刻指向对象的每个指针在哪里是相当困难的。不过，我们要考虑一个缓解因素。从技术上讲，这个要求只适用于 GC 实际需要发生的时候（因此，理论上我们不需要一直知道所有 GC 引用在哪里，只需要在 GC 的时候知道）。然而，实际上，由于 CLR 的另一个特性，这种缓解并不完全适用：

> CLR 支持单个进程内的多个并发执行线程。

在任何时候，其他执行线程可能会执行需要垃圾回收的分配。并发执行线程之间的确切操作顺序是不确定的。我们无法确切知道当另一个线程请求触发 GC 的分配时，一个线程正在做什么。因此，GC 实际上可能随时发生。现在 CLR 不需要_立即_响应另一个线程做 GC 的愿望，所以 CLR 有一点“回旋余地”，不需要在_所有_执行点跟踪 GC 引用，但它_确实_需要在足够多的地方这样做，以便它可以保证“及时”响应由另一个线程上的分配引起的做 GC 的需求。

这意味着 CLR 需要_几乎_一直在跟踪对 GC 堆的_所有_引用。由于 GC 引用可能驻留在机器寄存器、局部变量、静态变量或其他字段中，因此有相当多的内容需要跟踪。这些位置中最麻烦的是机器寄存器和局部变量，因为它们与用户代码的实际执行密切相关。实际上，这意味着操作 GC 引用的_机器码_还有另一个要求：它必须跟踪它使用的所有 GC 引用。这意味着编译器需要做一些额外的工作来发出指令来跟踪这些引用。

要了解更多信息，请查看 [垃圾回收器设计文档](garbage-collection.md)。

## “托管代码”的概念

做额外的记账工作以便它可以“几乎所有时间”报告其所有活动 GC 引用的代码称为_托管代码_（因为它由 CLR “管理”）。不这样做代码称为_非托管代码_。因此，CLR 之前存在的所有代码都是非托管代码，特别是，所有操作系统代码都是非托管的。

### 栈展开问题

显然，因为托管代码需要操作系统的服务，所以有时托管代码会调用非托管代码。同样，因为操作系统最初启动了托管代码，所以也有非托管代码调用托管代码的时候。因此，一般来说，如果你在任意位置停止托管程序，调用栈将混合有托管代码创建的帧和非托管代码创建的帧。

非托管代码的栈帧除了运行程序之外没有任何要求。特别是，不要求它们可以在运行时被_展开_以找到它们的调用者。这意味着如果你在任意位置停止程序，而它碰巧在非托管方法中，通常没有办法<sup>[1]</sup>找到调用者是谁。你只能在调试器中这样做，因为符号信息（PDB 文件）中存储了额外的信息。此信息不保证可用（这就是为什么你有时在调试器中得不到好的堆栈跟踪）。这对于托管代码来说是非常成问题的，因为任何无法展开的栈实际上可能包含托管代码帧（其中包含需要报告的 GC 引用）。

托管代码对其有额外的要求：它不仅必须跟踪它在执行期间使用的所有 GC 引用，而且还必须能够展开到它的调用者。此外，每当从托管代码过渡到非托管代码（或反之）时，托管代码还必须做额外的记账工作，以弥补非托管代码不知道如何展开其栈帧的事实。实际上，托管代码将包含托管帧的栈部分链接在一起。因此，虽然如果不使用额外信息可能仍然无法展开非托管栈帧，但总是可以找到对应于托管代码的栈块并枚举这些块中的托管帧。

[1] 最近的平台 ABI（应用二进制接口）定义了编码此信息的约定，但是通常没有严格要求所有代码都遵循它们。

### 托管代码的“世界”

结果是，在进出托管代码的每个转换处都需要特殊的记账。托管代码实际上生活在自己的“世界”中，除非 CLR 知道，否则执行无法进入或离开。这两个世界在非常真实的意义上彼此不同（在任何时间点，代码都在_托管世界_或_非托管世界_中）。此外，由于托管代码的执行是以 CLR 格式（及其[公共中间语言][cil-spec] (CIL)）指定的，并且是 CLR 将其转换为在原生硬件上运行，因此 CLR 对该执行的具体行为有_多得多的_控制权。例如，CLR 可以改变从对象获取字段或调用函数的含义。事实上，CLR 正是这样做的，以支持创建 MarshalByReference 对象的能力。这些看起来是普通的本地对象，但实际上可能存在于另一台机器上。简而言之，CLR 的托管世界有大量的_执行钩子_，它可以用来支持将在接下来的部分中更详细解释的强大功能。

此外，托管代码还有一个可能不那么明显的含义。在非托管世界中，不允许 GC 指针（因为它们无法被跟踪），并且从托管代码转换到非托管代码有记账成本。这意味着虽然你_可以_从托管代码调用任意非托管函数，但这通常并不令人愉快。非托管方法不在其参数和返回类型中使用 GC 对象，这意味着这些非托管函数创建和使用的任何“对象”或“对象句柄”都需要显式释放。这很不幸。因为这些 API 不能利用 CLR 功能（如异常或继承），所以与在托管代码中设计接口的方式相比，它们的用户体验往往“不匹配”。

其结果是，在向托管代码开发人员公开之前，非托管接口几乎总是被_包装_。例如，访问文件时，你不使用操作系统提供的 Win32 CreateFile 函数，而是使用包装此功能的托管 System.IO.File 类。实际上，非托管功能极少直接暴露给用户。

虽然这种包装在某种程度上似乎是“坏的”（更多的代码似乎没有做太多事情），但实际上它是好的，因为它实际上增加了相当多的价值。记住，直接公开非托管接口总是_可能的_；我们_选择_包装该功能。为什么？因为运行时的首要目标是**让编程变得容易**，通常非托管函数不够容易。大多数情况下，非托管接口在设计时并没有考虑到易用性，而是为了完整性而调整。任何查看 CreateFile 或 CreateProcess 参数的人都很难将它们描述为“容易”。幸运的是，当功能进入托管世界时，它得到了“整容”，虽然这种改造通常是非常“低科技”的（不需要比重命名、简化和组织功能更复杂的东西），但它也非常有用。为 CLR 创建的非常重要的文档之一是 [框架设计指南][fx-design-guidelines]。这份 800 多页的文档详细介绍了制作新的托管类库的最佳实践。

因此，我们现在已经看到，托管代码（与 CLR 密切相关）在两个重要方面不同于非托管代码：

1. 高科技：代码生活在一个独特的世界中，CLR 在非常精细的级别（可能到单个指令）控制程序执行的大多数方面，并且 CLR 检测执行何时进入和退出托管代码。这使得各种有用的功能成为可能。
2. 低科技：从托管代码到非托管代码存在转换成本的事实，以及非托管代码不能使用 GC 对象的事实，鼓励了将大多数非托管代码包装在托管外观中的做法。这意味着接口可以进行“整容”以简化它们，并符合一套统一的命名和设计指南，从而产生一定程度的一致性和可发现性，这在非托管世界中本可能存在，但实际上并不存在。

这些特征中的**两者**对于托管代码的成功都非常重要。

## 内存和类型安全

垃圾回收器启用的一个不太明显但影响深远的特性是内存安全。内存安全的不变性非常简单：如果程序只访问已分配（且未释放）的内存，则它是内存安全的。这简单地意味着你没有“野生”（悬空）指针指向随机位置（更准确地说，指向过早释放的内存）。显然，内存安全是我们希望所有程序都具备的属性。悬空指针总是错误，追踪它们通常非常困难。

> GC _是_提供内存安全保证所必需的

人们很快就能明白垃圾回收器如何帮助确保内存安全，因为它消除了用户过早释放内存（从而访问未正确分配的内存）的可能性。可能不那么明显的是，如果你想保证内存安全（即使程序员_不可能_创建内存不安全的程序），实际上你无法避免拥有垃圾回收器。其原因是，非平凡的程序需要_堆样式_（动态）内存分配，其中对象的生命周期基本上受任意程序控制（不像栈分配或静态分配的内存，它们有高度受限的分配协议）。在这样一个不受约束的环境中，通过程序分析来确定特定的显式删除语句是否正确是不可能的。实际上，确定删除是否正确的唯一方法是在运行时检查它。这正是 GC 所做的（检查内存是否仍然存活）。因此，对于任何需要堆样式内存分配的程序，如果你想保证内存安全，你需要一个 GC。

虽然 GC 对于确保内存安全是必要的，但它是不够的。GC 不会阻止程序索引超出数组末尾或访问对象末尾之外的字段（如果你使用基址和偏移量计算字段的地址，这是可能的）。然而，如果我们确实阻止了这些情况，那么我们确实可以使程序员不可能创建内存不安全的程序。

虽然 [公共中间语言][cil-spec] (CIL) _确实_ 有可以获取和设置任意内存（从而违反内存安全）的运算符，但它也有以下内存安全运算符，并且 CLR 强烈鼓励在大多数编程中使用它们：

1. 字段获取运算符（LDFLD, STFLD, LDFLDA），按名称获取（读取）、设置和获取字段的地址。
2. 数组获取运算符（LDELEM, STELEM, LDELEMA），按索引获取、设置和获取数组元素的地址。所有数组都包含一个指定其长度的标签。这有助于在每次访问之前进行自动边界检查。

通过在用户代码中使用这些运算符而不是较低级别的（和不安全的）_内存获取_运算符，以及避免其他不安全的 [CIL][cil-spec] 运算符（例如，那些允许你跳转到任意，因此可能是坏位置的运算符），人们可以想象构建一个内存安全但仅此而已的系统。然而，CLR 并不这样做。相反，CLR 强制执行更强的不变性：类型安全。

对于类型安全，从概念上讲，每个内存分配都与一个类型相关联。所有作用于内存位置的运算符也在概念上标记为它们有效的类型。然后，类型安全要求标记为特定类型的内存只能经历该类型允许的操作。这不仅确保了内存安全（没有悬空指针），还允许每个单独类型的额外保证。

这些特定于类型的保证中最重要的一个是可以强制执行与类型（特别是与字段）相关联的可见性属性。因此，如果一个字段被声明为私有（只能由类型的方法访问），那么所有其他类型安全代码都会确实遵守该隐私。例如，特定类型可能声明一个计数字段，表示表中的项目计数。假设计数和表的字段是私有的，并且假设只有更新它们的代码才将它们一起更新，那么现在有一个强有力的保证（跨越所有类型安全代码），即计数和表中的项目数确实是同步的。在推理程序时，程序员一直在使用类型安全的概念，无论他们是否知道。CLR 将类型安全从简单的编程语言/编译器约定提升为可以在运行时严格执行的东西。

### 可验证代码 - 强制执行内存和类型安全

从概念上讲，为了强制执行类型安全，程序执行的每个操作都必须经过检查，以确保它正在操作以与操作兼容的方式键入的内存。虽然系统可以在运行时全部执行此操作，但这将非常慢。相反，CLR 具有 [CIL][cil-spec] 验证的概念，其中对 [CIL][cil-spec] 进行静态分析（在代码运行之前）以确认大多数操作确实是类型安全的。只有当这种静态分析无法完成完整的工作时，才需要运行时检查。实际上，所需的运行时检查数量非常少。它们包括以下操作：

1. 将指向基类型的指针转换为指向派生类型的指针（相反方向可以静态检查）
2. 数组边界检查（就像我们在内存安全中看到的那样）
3. 将指针数组中的元素赋值为新的（指针）值。仅因为 CLR 数组具有宽松的转换规则才需要这种特殊检查（稍后会详细介绍...）

请注意，执行这些检查的需要在运行时提出了要求。特别是：

1. GC 堆中的所有内存都必须标记其类型（以便可以实现转换运算符）。此类型信息必须在运行时可用，并且必须足够丰富以确定转换是否有效（例如，运行时需要知道继承层次结构）。实际上，GC 堆上每个对象的第一个字段都指向表示其类型的运行时数据结构。
2. 所有数组也必须有它们的大小（用于边界检查）。
3. 数组必须有关于其元素类型的完整类型信息。

幸运的是，最昂贵的要求（标记每个堆项目）是支持垃圾回收已经需要的（GC 需要知道每个对象中的哪些字段包含需要扫描的引用），因此提供类型安全的额外成本很低。

因此，通过验证代码的 [CIL][cil-spec] 并进行一些运行时检查，CLR 可以确保类型安全（以及内存安全）。尽管如此，这种额外的安全性在编程灵活性方面付出了代价。虽然 CLR 确实具有通用的内存获取运算符，但这些运算符只能以非常受限的方式使用，以使代码可验证。特别是，所有指针算术今天都将无法通过验证。因此，许多经典的 C 或 C++ 约定不能在可验证代码中使用；你必须改用数组。虽然这在一定程度上限制了编程，但其实并不算坏（数组非常强大），而且好处（更少的“令人讨厌的”错误）是非常真实的。

CLR 强烈鼓励使用可验证的、类型安全的代码。即使这样，有时（主要是处理非托管代码时）也需要不可验证的编程。CLR 允许这样做，但这里的最佳实践是尽可能限制这种不安全的代码。典型的程序只有极小一部分代码需要是不安全的，其余部分可以是类型安全的。

## 高级特性

支持垃圾回收对运行时产生了深远的影响，因为它要求所有代码都必须支持额外的记账。对类型安全的渴望也产生了深远的影响，要求程序的描述（[CIL][cil-spec]）处于高级水平，其中字段和方法具有详细的类型信息。对类型安全的渴望还迫使 [CIL][cil-spec] 支持其他类型安全的高级编程构造。以类型安全的方式表达这些构造也需要运行时支持。这些高级特性中最重要的两个用于支持面向对象编程的两个基本元素：继承和虚调用分派。

### 面向对象编程

从机械意义上讲，继承相对简单。基本思想是，如果类型 `derived` 的字段是类型 `base` 字段的超集，并且 `derived` 对其字段进行布局使得 `base` 的字段排在前面，那么任何期望指向 `base` 实例的指针的代码都可以被赋予一个指向 `derived` 实例的指针，并且代码将“正常工作”。因此，类型 `derived` 被称为继承自 `base`，这意味着它可以在任何可以使用 `base` 的地方使用。代码变得_多态_，因为相同的代码可以用于许多不同的类型。因为运行时需要知道哪些类型强制转换是可能的，所以运行时必须形式化指定继承的方式，以便它可以验证类型安全。

虚调用分派概括了继承多态性。它允许基类型声明将被派生类型_重写_的方法。使用 `base` 类型变量的代码可以预期，对虚方法的调用将根据运行时对象的实际类型分派到正确的重写方法。虽然这种_运行时分派逻辑_本可以使用原始 [CIL][cil-spec] 指令实现而无需运行时直接支持，但它会有两个重要的缺点

1. 它不是类型安全的（分派表中的错误是灾难性错误）
2. 每个面向对象语言可能会实现略有不同的虚分派逻辑实现方式。结果，语言之间的互操作性将受到影响（一种语言无法继承用另一种语言实现的基类型）。

出于这个原因，CLR 直接支持基本的面向对象特性。在某种程度上，CLR 试图使其继承模型“语言中立”，即不同的语言可能仍然共享相同的继承层次结构。不幸的是，这并不总是可能的。特别是，多重继承可以用许多不同的方式实现。CLR 选择不支持带字段类型的多重继承，但确实支持从特殊类型（称为接口）的多重继承，这些类型被限制为没有字段。

重要的是要记住，虽然运行时支持这些面向对象的概念，但并不强制使用它们。没有继承概念的语言（例如，函数式语言）根本不使用这些设施。

### 值类型（和装箱）

面向对象编程的一个深刻而微妙的方面是对象标识的概念：即对象（通过单独的分配调用分配）即使所有字段值都相同，也可以区分的概念。对象标识与对象是通过引用（指针）而不是通过值访问的事实密切相关。如果两个变量持有相同的对象（它们的指针指向相同的内存），那么对其中一个变量的更新将影响另一个变量。

不幸的是，对象标识的概念并不适合所有类型的语义匹配。特别是，程序员通常不认为整数是对象。如果在两个不同的地方分配了数字 '1'，程序员通常希望认为这两个项目相等，并且当然不希望对其中一个实例的更新影响另一个。实际上，一大类称为“函数式语言”的编程语言完全避免了对象标识和引用语义。

虽然拥有一个“纯”面向对象系统是可能的，其中一切（包括整数）都是对象（Smalltalk-80 就是这样做的），但需要一定量的实现“体操”来撤销这种统一性以获得高效的实现。其他语言（Perl, Java, JavaScript）采取务实的观点，按值处理某些类型（如整数），按引用处理其他类型。CLR 也选择了混合模型，但与其他语言不同的是，允许用户定义的值类型。

值类型的关键特征是：

1. 值类型的每个局部变量、字段或数组元素都有该值中数据的不同副本。
2. 当一个变量、字段或数组元素赋值给另一个时，值被复制。
3. 相等性总是仅根据变量中的数据（而不是其位置）定义。
4. 每个值类型还有一个对应的引用类型，该引用类型只有一个隐式的、未命名的字段。这被称为其装箱值。装箱的值类型可以参与继承并具有对象标识（尽管强烈不建议使用装箱值类型的对象标识）。

值类型非常接近地模拟了 C（和 C++）中 struct（或 C++ class）的概念。像 C 一样，你可以拥有指向值类型的指针，但指针是一种不同于 struct 类型的类型。

### 异常

CLR 直接支持的另一个高级编程构造是异常。异常是一种语言特性，允许程序员在发生故障时_抛出_任意对象。当抛出对象时，运行时在调用栈中搜索声明它可以_捕获_异常的方法。如果找到这样的捕获声明，则从该点继续执行。异常的有用之处在于它们避免了不检查调用方法是否失败这一非常常见的错误。鉴于异常有助于避免程序员错误（从而使编程更容易），CLR 支持它们也就不足为奇了。

顺便说一句，虽然异常避免了一种常见错误（不检查故障），但它们并不能防止另一种错误（在故障发生时将数据结构恢复到一致状态）。这意味着在捕获异常之后，通常很难知道继续执行是否会导致额外的错误（由第一次故障引起）。这是 CLR 将来可能会增加价值的一个领域。然而，即使按目前实施的情况来看，异常也是向前迈出的重要一步（我们只需要走得更远）。

### 参数化类型（泛型）

在 CLR 2.0 版本之前，唯一的参数化类型是数组。所有其他容器（如哈希表、列表、队列等）都在通用的 Object 类型上操作。无法创建 List<ElemT> 或 Dictionary<KeyT, ValueT> 肯定会对性能产生负面影响，因为值类型在进入集合时需要装箱，并且在元素获取时需要显式转换。尽管如此，这并不是向 CLR 添加参数化类型的首要原因。主要原因是**参数化类型使编程更容易**。

这其中的原因很微妙。看到这种效果的最简单方法是想象如果所有类型都被替换为通用的 Object 类型，类库会是什么样子。这种效果与 JavaScript 等动态类型语言中发生的情况没有什么不同。在这个世界里，程序员有更多的方法来编写不正确（但类型安全）的程序。该方法的参数应该是列表吗？字符串？整数？以上任何一种？从方法的签名来看，这不再明显。更糟糕的是，当一个方法返回一个 Object 时，还有哪些方法可以接受它作为参数？典型的框架有数百个方法；如果它们都接受 Object 类型的参数，那么确定哪些 Object 实例对于方法将执行的操作有效就会变得非常困难。简而言之，强类型有助于程序员更清楚地表达他们的意图，并允许工具（例如编译器）强制执行他们的意图。这极大地提高了生产力。

这些好处不会仅仅因为类型被放入 List 或 Dictionary 就消失，所以显然参数化类型有价值。唯一真正的问题是，参数化类型最好被认为是语言特定的特性，在生成 CIL 时被“编译掉”，还是该特性应该在运行时拥有一等公民的支持。任何一种实现当然都是可能的。CLR 团队选择了一等公民支持，因为如果没有它，不同的语言将以不同的方式实现参数化类型。这将意味着互操作性充其量是繁琐的。此外，表达参数化类型的程序员意图在类库的_接口处_最有价值。如果 CLR 不正式支持参数化类型，那么类库就不能使用它们，一个重要的可用性特性将会丢失。

### 程序即数据（反射 API）

CLR 的基础是垃圾回收、类型安全和高级语言特性。这些基本特征迫使程序的规范 (CIL) 相当高级。一旦这些数据在运行时存在（这对于 C 或 C++ 程序来说不是真的），显而易见的是，向最终程序员公开这些丰富的数据也将是有价值的。这个想法导致了 System.Reflection 接口的创建（之所以这么叫，是因为它们允许程序查看（反射）自身）。此接口允许你探索程序的几乎所有方面（它有什么类型，继承关系，以及存在哪些方法和字段）。事实上，丢失的信息如此之少，以至于托管代码的非常好的“反编译器”是可能的（例如，[NET Reflector](http://www.red-gate.com/products/reflector/)）。虽然那些关心知识产权保护的人对这种能力感到震惊（可以通过一种称为_混淆_程序的操作故意破坏信息来修复），但它是可能的这一事实证明了托管代码运行时可用信息的丰富性。

除了简单地在运行时检查程序之外，还可以对它们执行操作（例如，调用方法、设置字段等），也许最强大的是，可以在运行时从头生成代码 (System.Reflection.Emit)。事实上，运行时库使用此功能来创建用于匹配字符串的专用代码 (System.Text.RegularExpressions)，并生成用于“序列化”对象以存储在文件中或通过网络发送的代码。像这样的能力以前简直是不可行的（你必须编写一个编译器！），但多亏了运行时，这在许多编程问题中都触手可及。

虽然反射能力确实很强大，但应谨慎使用这种能力。反射通常比静态编译的对应物慢得多。更重要的是，自引用系统本来就更难理解。这意味着只有在价值明显且巨大的时候，才应使用诸如 Reflection 或 Reflection.Emit 之类的强大功能。

# 其他特性

最后一组运行时特性是那些与 CLR 的基本架构（GC、类型安全、高级规范）无关，但通过满足任何完整运行时系统的重要需求的特性。

## 与非托管代码的互操作

托管代码需要能够使用在非托管代码中实现的功能。互操作主要有两种“风味”。首先是简单地调用非托管函数的能力（这称为平台调用或 PINVOKE）。非托管代码还有一个面向对象的互操作模型，称为 COM（组件对象模型），它比临时的函数调用有更多的结构。由于 COM 和 CLR 都有对象模型和其他约定（如何处理错误、对象的生命周期等），如果 CLR 有特殊支持，它可以更好地与 COM 代码进行互操作。

## 提前编译 (AOT)

在 CLR 模型中，托管代码作为 CIL 分发，而不是原生代码。转换为原生代码发生在运行时。作为一种优化，从 CIL 生成的原生代码可以使用名为 crossgen 的工具（类似于 .NET Framework NGEN 工具）保存在文件中。这避免了运行时大量的编译时间，并且非常重要，因为类库非常大。

## 线程

CLR 充分预见到了在托管代码中支持多线程程序的需求。从一开始，CLR 库就包含了 System.Threading.Thread 类，它是操作系统执行线程概念的一对一包装器。然而，因为它只是操作系统线程的包装器，所以创建 System.Threading.Thread 相对昂贵（启动需要毫秒级时间）。虽然这对于许多操作来说很好，但一种编程风格会创建非常小的工作项（只需要几十毫秒）。这在服务器代码（例如，每个任务只服务一个网页）或试图利用多处理器的代码（例如，多核排序算法）中非常常见。为了支持这一点，CLR 拥有 ThreadPool 的概念，允许工作项排队。在这个方案中，CLR 负责创建必要的线程来完成工作。虽然 CLR 确实将 ThreadPool 直接公开为 System.Threading.Threadpool 类，但首选机制是使用 [任务并行库](https://msdn.microsoft.com/en-us/library/dd460717(v=vs.110).aspx)，它为非常常见的并发控制形式添加了额外的支持。

从实现的角度来看，ThreadPool 的重要创新在于它负责确保使用最佳数量的线程来分派工作。CLR 使用反馈系统来做到这一点，它监控吞吐率和线程数，并调整线程数以最大化吞吐量。这非常好，因为现在程序员可以主要从“暴露并行性”（即创建工作项）的角度来思考，而不是确定正确并行量的更微妙问题（这取决于工作负载和运行程序的硬件）。

# 总结和资源

呼！运行时做了很多事情！仅仅描述运行时的_一些_特性就花了很多页，甚至还没开始谈论内部细节。然而，希望这篇介绍能为更深入地理解这些内部细节提供一个有用的框架。该框架的基本轮廓是：

- 运行时是支持编程语言的完整框架
- 运行时的目标是让编程变得容易。
- 运行时的基本特性是：
  - 垃圾回收
  - 内存和类型安全
  - 对高级语言特性的支持

## 有用的链接

- [MSDN CLR 条目][clr]
- [维基百科 CLR 条目](http://en.wikipedia.org/wiki/Common_Language_Runtime)
- [ECMA 公共语言基础设施 (CLI) 标准][ecma-spec]
- [.NET 框架设计指南](http://msdn.microsoft.com/en-us/library/ms229042.aspx)
- [CoreCLR 仓库文档](README.md)

[clr]: http://msdn.microsoft.com/library/8bs2ecf4.aspx
[ecma-spec]: ../../../project/dotnet-standards.md
[cil-spec]: http://download.microsoft.com/download/7/3/3/733AD403-90B2-4064-A81E-01035A7FE13C/MS%20Partition%20III.pdf
[fx-design-guidelines]: http://msdn.microsoft.com/en-us/library/ms229042.aspx
