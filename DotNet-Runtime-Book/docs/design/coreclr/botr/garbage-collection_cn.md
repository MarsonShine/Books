# 垃圾回收设计

作者：Maoni Stephens ([@maoni0](https://github.com/maoni0)) - 2015

注意：请参阅 _The Garbage Collection Handbook_ 以了解有关垃圾回收的一般主题；有关 CLR GC 的特定知识，请参阅 _Pro .NET Memory Management_ 一书。两者都在本文档末尾的参考资料部分中引用。

# 组件架构

属于 GC 的 2 个组件是分配器和收集器。分配器负责获取更多内存并在适当时触发收集器。收集器回收垃圾，即程序不再使用的对象的内存。

收集器还可以通过其他方式被调用，例如手动调用 GC.Collect 或终结器线程接收到低内存的异步通知（这会触发收集器）。

# 分配器设计

分配器由执行引擎 (EE) 中的分配帮助程序调用，并提供以下信息：

- 请求的大小
- 线程分配上下文
- 用于指示诸如该对象是否可终结（finalizable）之类事项的标志

GC 不会对不同类型的对象做特殊处理。它会向 EE 查询以获取对象的大小。

根据大小，GC 将对象分为 2 类：小对象（< 85,000 字节）和大对象（>= 85,000 字节）。原则上，小对象和大对象可以用相同的方式处理，但由于压缩大对象更昂贵，因此 GC 进行了这种区分。

当 GC 向分配器提供内存时，是以分配上下文（allocation contexts）的形式提供的。分配上下文的大小由分配量子（allocation quantum）定义。

- 分配上下文是在给定堆段（heap segment）中更小的区域，每个区域专供某个线程使用。在单处理器（即 1 个逻辑处理器）机器上，只使用一个上下文，也就是第 0 代（generation 0）的分配上下文。
- 分配量子是分配器每次需要更多内存时所分配的内存大小，用于在一个分配上下文内执行对象分配。该分配通常为 8k，而托管对象的平均大小约为 35 字节，使得一个分配量子可以用于许多对象分配。

大对象不使用分配上下文和量子。单个大对象本身就可能大于这些更小的内存区域。此外，这些区域的收益（如下所述）是针对小对象的。大对象会直接分配到某个堆段上。

分配器旨在实现以下目标：

- **在适当时触发 GC：** 当超出分配预算（收集器设置的阈值）或分配器无法再在给定段上分配时，分配器会触发 GC。稍后将更详细地讨论分配预算和托管段。
- **保留对象局部性：**在同一堆段上一起分配的对象将存储在彼此靠近的虚拟地址处。
- **高效的缓存使用：**分配器以_分配量_为单位分配内存，而不是逐个对象地分配。它将那么多内存清零以预热 CPU 缓存，因为将立即在该内存中分配对象。分配量通常为 8k。
- **高效的锁定：**分配上下文和分配量的线程亲和性保证始终只有单个线程写入给定的分配量。因此，只要当前分配上下文未耗尽，就不需要为对象分配进行锁定。
- **内存完整性：**GC 总会把新分配对象的内存清零，以防对象引用指向随机内存。
- **保持堆可遍历（crawlable）：**分配器会确保把每个分配量子中剩余的内存做成一个 free 对象。例如，如果某个分配量子还剩 30 字节，而下一个对象是 40 字节，分配器就会把这 30 字节做成一个 free 对象，并获取一个新的分配量子。

## 分配 API

     Object* GCHeap::Alloc(size_t size, DWORD flags);
     Object* GCHeap::Alloc(alloc_context* acontext, size_t size, DWORD flags);

上述函数可用于分配小对象和大对象。还有一个函数直接在 LOH 上分配：

     Object* GCHeap::AllocLHeap(size_t size, DWORD flags);

# 收集器设计

## GC 的目标

GC 致力于极其高效地管理内存，并要求编写“托管代码”的人员付出极少的努力。高效意味着：

- GC 应该足够频繁，以避免托管堆里存在大量（按比例或绝对数量）已分配但未使用的对象（垃圾），从而不必要地占用内存。
- GC 也应尽可能不频繁，以避免消耗本可用于其他用途的 CPU 时间，即便更频繁的 GC 会带来更低的内存使用。
- 一次 GC 应当“有产出”。如果 GC 只回收了很少的内存，那么这次 GC（包括相关 CPU 周期）就是浪费。
- 每次 GC 都应当很快。许多工作负载对低延迟有要求。
- 托管代码开发者不应需要对 GC 了解太多就能获得良好的内存利用率（相对于其工作负载）。——GC 应当能自我调优以满足不同的内存使用模式。

## 托管堆的逻辑表示

CLR GC 是分代收集器，这意味着对象在逻辑上被划分到不同的代。当收集第 N 代时，存活对象会被标记为属于第 N+1 代。这个过程称为提升（promotion）。在我们决定降级（demote）或不提升时，会有例外。

对于小对象，堆分为 3 代：gen0、gen1 和 gen2。对于大对象，只有一代——gen3。gen0 和 gen1 被称为短命（ephemeral，存活时间短）代。

对于小对象堆，代号代表“年龄”——gen0 是最年轻的一代。这并不意味着 gen0 里的所有对象都比 gen1 或 gen2 里的任何对象年轻。存在一些例外，会在下文解释。收集某一代意味着收集该代以及所有比它更年轻的代中的对象。

原则上，大对象可以像小对象一样处理，但由于压缩大对象代价很高，因此它们被区别对待。大对象只有一代，并且出于性能原因，它们总是与 gen2 收集一起被收集。gen2 与 gen3 都可能很大，而收集短命代（gen0 和 gen1）需要有可控的成本上界。

分配发生在最年轻的一代——对小对象来说永远是 gen0；对大对象来说是 gen3（因为只有一代）。

## 托管堆的物理表示

托管堆由一组托管堆段（managed heap segments）构成。堆段是 GC 从操作系统获取的一块连续内存。堆段可以是小段、大段或固定对象段（pinned object segments），取决于其包含的内容。在每个堆上，堆段会串成链。至少会有一个小对象段和一个大对象段——它们会在 CLR 加载时预留。还有一个 NonGC 堆，包含 ro（只读）段。

在每个小对象堆中始终只有一个短命段（ephemeral segment），gen0 和 gen1 就位于其中。该段可能包含 gen2 对象，也可能不包含。除短命段外，还可能有 0 个、1 个或多个附加段，它们都是 gen2 段，因为其中只包含 gen2 对象。

大对象堆上有 1 个或多个段。

堆段从较低地址到较高地址被消耗，这意味着段上较低地址的对象比较高地址的对象更旧。同样，下面将描述例外情况。

堆段可以按需获取。当它们不包含任何活动对象时，它们会被删除，但堆上的初始段将始终存在。对于每个堆，一次获取一个段，这对于小对象是在 GC 期间完成的，对于大对象是在分配期间完成的。这种设计提供了更好的性能，因为大对象仅随 gen2 收集（相对昂贵）一起收集。

堆段按获取顺序链接在一起。链中的最后一个段始终是临时段。已收集的段（没有活动对象）可以被重用而不是删除，并成为新的临时段。段重用仅针对小对象堆实现。每次分配大对象时，都会考虑整个大对象堆。小对象分配仅考虑临时段。

## 分配预算

分配预算是与每一代相关联的逻辑概念。它是一个大小上限，当超过时会触发对该代的 GC。

预算大多依据该代的存活率来设置。如果存活率高，预算会被设置得更大，期望下次对该代进行 GC 时会有更好的“死亡对象/存活对象”比例。

## 决定收集哪一代

当一次 GC 被触发时，GC 必须先决定要收集哪一代。除了分配预算之外，还必须考虑其他因素：

- 某一代的碎片化程度——如果碎片化很高，收集该代很可能是有产出的。
-  如果机器上的内存负载过高，GC 可能会更激进地收集，只要这可能带来可用空间。这一点对防止不必要的分页（跨机器范围）很重要。
- 如果短命段快没有空间了，GC 可能会更激进地进行短命代收集（意味着做更多的 gen1），以避免获取新的堆段。

## GC 流程

### 标记阶段

标记阶段的目标是找到所有活动对象。

分代收集器的好处在于能够只收集堆的一部分，而不必总是查看所有对象。当收集短命代时，GC 需要找出这些代中的哪些对象是存活的，这些信息由 EE 报告。除了 EE 保持存活的对象之外，老年代中的对象也可能通过引用年轻代对象而使其保持存活。

GC 使用卡表（cards）来进行老年代的标记。卡表由 JIT 辅助函数在赋值操作期间设置。如果 JIT 辅助函数看到一个位于短命区间内的对象，它就会设置包含“代表源位置的卡项”的那个字节。在短命代收集中，GC 可以查看堆其余部分中被设置的卡项，只检查这些卡项所对应的对象。

### 计划阶段

计划阶段模拟压缩以确定有效结果。如果压缩富有成效，GC 将开始实际压缩；否则它会清扫。

### 重定位阶段

如果 GC 决定压缩，这将导致移动对象，那么必须更新对这些对象的引用。重定位阶段需要找到指向正在收集的代中的对象的所有引用。相比之下，标记阶段只咨询活动对象，因此不需要考虑弱引用。

### 压缩阶段

此阶段非常简单，因为计划阶段已经计算了对象应移动到的新地址。压缩阶段将把对象复制到那里。

### 清扫阶段

清扫阶段会寻找存活对象之间的死亡空间，并在这些死亡空间位置创建 free 对象。相邻的死亡对象会合并成一个 free 对象。它会把这些 free 对象全部放到空闲列表（freelist）上。

# 代码流程

术语：

- **WKS GC:** 工作站 GC
- **SVR GC:** 服务器 GC

## 功能行为

### WKS GC 关闭并发 GC

1. 用户线程耗尽分配预算并触发 GC。
2. GC 调用 SuspendEE 挂起托管线程。
3. GC 决定要谴责（condemn）哪一代。
4. 运行标记阶段。
5. 运行计划阶段并决定是否应进行压缩 GC。
6. 如果是，则运行重定位和压缩阶段。否则，运行清扫阶段。
7. GC 调用 RestartEE 恢复托管线程。
8. 用户线程恢复运行。

### WKS GC 开启并发 GC

这说明了如何进行后台 GC。

1. 用户线程耗尽分配预算并触发 GC。
2. GC 调用 SuspendEE 挂起托管线程。
3. GC 决定是否应运行后台 GC。
4. 如果是，则唤醒后台 GC 线程以进行后台 GC。后台 GC 线程调用 RestartEE 恢复托管线程。
5. 托管线程在后台 GC 工作的同时继续分配。
6. 用户线程可能耗尽分配预算并触发一次短命代 GC（我们称之为前台 GC）。其方式与“并发 GC 关闭的 WKS GC”相同。
7. 后台 GC 再次调用 SuspendEE 以完成标记，然后调用 RestartEE 以在用户线程运行时启动并发清扫阶段。
8. 后台 GC 完成。

### SVR GC 关闭并发 GC

1. 用户线程耗尽分配预算并触发 GC。
2. 服务器 GC 线程被唤醒并调用 SuspendEE 挂起托管线程。
3. 服务器 GC 线程执行 GC 工作（阶段与无并发的工作站 GC 相同）。
4. 服务器 GC 线程调用 RestartEE 恢复托管线程。
5. 用户线程恢复运行。

### SVR GC 开启并发 GC

此方案与开启并发 GC 的 WKS GC 相同，除了非后台 GC 是在 SVR GC 线程上完成的。

# 物理架构

本节旨在帮助您跟踪代码流程。

用户线程在分配上下文中耗尽空间，并通过 try_allocate_more_space 获取一个新的。

当 try_allocate_more_space 需要触发 GC 时，它会调用 GarbageCollectGeneration。

在并发 GC 关闭的 WKS GC 下，GarbageCollectGeneration 完全由触发 GC 的用户线程执行。代码流程为：

```cpp
 GarbageCollectGeneration()
 {
     SuspendEE();
     garbage_collect();
     RestartEE();
 }

 garbage_collect()
 {
     generation_to_condemn();
     gc1();
 }

 gc1()
 {
     mark_phase();
     plan_phase();
 }

 plan_phase()
 {
     // 实际计划阶段工作以决定是否
     // 压缩
     if (compact)
     {
         relocate_phase();
         compact_phase();
     }
     else
         make_free_lists();
 }
```

鉴于开启并发 GC 的 WKS GC（默认情况），后台 GC 的代码流程为

```cpp
 GarbageCollectGeneration()
 {
     SuspendEE();
     garbage_collect();
     RestartEE();
 }

 garbage_collect()
 {
     generation_to_condemn();
     // 决定进行后台 GC
     // 唤醒后台 GC 线程进行工作
     do_background_gc();
 }

 do_background_gc()
 {
     init_background_gc();
     start_c_gc ();

     //等待直到被 BGC 重启。
     wait_to_proceed();
 }

 bgc_thread_function()
 {
     while (1)
     {
         // 等待事件
         // 唤醒
         gc1();
     }
 }

 gc1()
 {
     background_mark_phase();
     background_sweep();
 }
```

# 资源

- [.NET CLR GC 实现](https://raw.githubusercontent.com/dotnet/runtime/main/src/coreclr/gc/gc.cpp)
- [垃圾回收手册：自动内存管理的艺术](http://www.amazon.com/Garbage-Collection-Handbook-Management-Algorithms/dp/1420082795)
- [垃圾回收 (维基百科)](http://en.wikipedia.org/wiki/Garbage_collection_(computer_science))
- [Pro .NET Memory Management](https://prodotnetmemory.com/)
- [.NET GC 内部机制视频系列](https://www.youtube.com/playlist?list=PLpUkQYy-K8Y-wYcDgDXKhfs6OT8fFQtVm)
