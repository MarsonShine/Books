# 垃圾回收设计

作者：Maoni Stephens ([@maoni0](https://github.com/maoni0)) - 2015

注意：请参阅 _The Garbage Collection Handbook_ 以了解有关垃圾回收的一般主题；有关 CLR GC 的特定知识，请参阅 _Pro .NET Memory Management_ 一书。两者都在本文档末尾的参考资料部分中引用。

# 组件架构

属于 GC 的 2 个组件是分配器和收集器。分配器负责获取更多内存并在适当时触发收集器。收集器回收垃圾，即程序不再使用的对象的内存。

收集器还可以通过其他方式被调用，例如手动调用 GC.Collect 或终结器线程接收到低内存的异步通知（这会触发收集器）。

# 分配器设计

分配器由执行引擎 (EE) 中的分配帮助程序调用，并提供以下信息：

- 请求的大小
- 线程分配上下文
- 指示诸如这是否为可终结对象之类的标志

GC 对不同类型的对象类型没有特殊处理。它咨询 EE 以获取对象的大小。

根据大小，GC 将对象分为 2 类：小对象（< 85,000 字节）和大对象（>= 85,000 字节）。原则上，小对象和大对象可以用相同的方式处理，但由于压缩大对象更昂贵，因此 GC 进行了这种区分。

当 GC 将内存分发给分配器时，它是按照分配上下文进行的。分配上下文的大小由分配量定义。

- **分配上下文**是给定堆段的较小区域，每个区域专用于给定线程使用。在单处理器（指 1 个逻辑处理器）机器上，使用单个上下文，即第 0 代分配上下文。
- **分配量**是分配器每次需要更多内存时分配的内存大小，以便在分配上下文中执行对象分配。分配通常为 8k，托管对象的平均大小约为 35 字节，从而使得单个分配量可用于许多对象分配。

大对象不使用分配上下文和分配量。单个大对象本身可能比这些较小的内存区域大。此外，这些区域的好处（在下面讨论）是针对较小对象的。大对象直接分配给堆段。

分配器旨在实现以下目标：

- **在适当时触发 GC：** 当超出分配预算（收集器设置的阈值）或分配器无法再在给定段上分配时，分配器会触发 GC。稍后将更详细地讨论分配预算和托管段。
- **保留对象局部性：** 在同一堆段上一起分配的对象将存储在彼此靠近的虚拟地址处。
- **高效的缓存使用：** 分配器以_分配量_为单位分配内存，而不是逐个对象地分配。它将那么多内存清零以预热 CPU 缓存，因为将立即在该内存中分配对象。分配量通常为 8k。
- **高效的锁定：** 分配上下文和分配量的线程亲和性保证始终只有单个线程写入给定的分配量。因此，只要当前分配上下文未耗尽，就不需要为对象分配进行锁定。
- **内存完整性：** GC 总是将新分配对象的内存清零，以防止对象引用指向随机内存。
- **保持堆可爬取：** 分配器确保将每个分配量中剩余的内存变成一个空闲对象。例如，如果在分配量中还剩 30 个字节，而下一个对象是 40 个字节，则分配器将使 30 个字节成为一个空闲对象并获取一个新的分配量。

## 分配 API

     Object* GCHeap::Alloc(size_t size, DWORD flags);
     Object* GCHeap::Alloc(alloc_context* acontext, size_t size, DWORD flags);

上述函数可用于分配小对象和大对象。还有一个函数直接在 LOH 上分配：

     Object* GCHeap::AllocLHeap(size_t size, DWORD flags);

# 收集器设计

## GC 的目标

GC 致力于极其高效地管理内存，并要求编写“托管代码”的人员付出极少的努力。高效意味着：

- GC 应该经常发生，以避免托管堆包含大量（按比例或绝对计数）未使用的但已分配的对象（垃圾），从而不必要地使用内存。
- GC 应该尽可能不频繁地发生，以避免使用原本有用的 CPU 时间，即使频繁的 GC 会导致较低的内存使用率。
- GC 应该是富有成效的。如果 GC 回收了少量内存，那么 GC（包括相关的 CPU 周期）就被浪费了。
- 每个 GC 都应该很快。许多工作负载都有低延迟要求。
- 托管代码开发人员不需要了解太多关于 GC 的知识即可实现良好的内存利用率（相对于他们的工作负载）。
- GC 应该自我调整以满足不同的内存使用模式。

## 托管堆的逻辑表示

CLR GC 是一个分代收集器，这意味着对象在逻辑上分为几代。当第 _N_ 代被收集时，幸存的对象现在被标记为属于第 _N+1_ 代。这个过程称为晋升。当我们决定降级或不晋升时，会有例外。

对于小对象，堆分为 3 代：gen0、gen1 和 gen2。对于大对象，有一代——gen3。Gen0 和 gen1 被称为临时（持续时间短的对象）代。

对于小对象堆，代数表示年龄——gen0 是最年轻的一代。这并不意味着 gen0 中的所有对象都比 gen1 或 gen2 中的任何对象年轻。下面将解释例外情况。收集一代意味着收集该代及其所有更年轻代中的对象。

原则上，大对象可以像小对象一样处理，但由于压缩大对象非常昂贵，因此对它们进行了不同的处理。大对象只有一代，出于性能原因，它们总是与 gen2 收集一起收集。Gen2 和 gen3 都可能很大，收集临时代（gen0 和 gen1）需要有有限的成本。

分配是在最年轻的一代中进行的——对于小对象，这意味着总是 gen0，对于大对象，这意味着 gen3，因为只有一代。

## 托管堆的物理表示

托管堆是一组托管堆段。堆段是 GC 从操作系统获取的连续内存块。堆段可以是小的、大的或固定的对象段，具体取决于它们包含的内容。在每个堆上，堆段链接在一起。至少有一个小对象段和一个大段——它们在加载 CLR 时被保留。还有一个包含 ro（只读）段的 NonGC 堆。

每个小对象堆中始终只有一个临时段，gen0 和 gen1 就在这里。此段可能包含也可能不包含 gen2 对象。除了临时段之外，还可以有零个、一个或多个额外的段，这些将是 gen2 段，因为它们只包含 gen2 对象。

大对象堆上有 1 个或多个段。

堆段从较低地址到较高地址被消耗，这意味着段上较低地址的对象比较高地址的对象更旧。同样，下面将描述例外情况。

堆段可以按需获取。当它们不包含任何活动对象时，它们会被删除，但堆上的初始段将始终存在。对于每个堆，一次获取一个段，这对于小对象是在 GC 期间完成的，对于大对象是在分配期间完成的。这种设计提供了更好的性能，因为大对象仅随 gen2 收集（相对昂贵）一起收集。

堆段按获取顺序链接在一起。链中的最后一个段始终是临时段。已收集的段（没有活动对象）可以被重用而不是删除，并成为新的临时段。段重用仅针对小对象堆实现。每次分配大对象时，都会考虑整个大对象堆。小对象分配仅考虑临时段。

## 分配预算

分配预算是与每一代相关联的逻辑概念。它是一个大小限制，当超过该限制时，会触发该代的 GC。

预算是根据该代的存活率在代上设置的属性。如果存活率很高，预算就会变大，期望下次该代进行 GC 时死对象与活对象的比例会更好。

## 确定要收集哪一代

当触发 GC 时，GC 必须首先确定要收集哪一代。除了分配预算外，还必须考虑其他因素：

- 一代的碎片化——如果一代具有高碎片化，收集该代可能会富有成效。
- 如果机器上的内存负载过高，如果可能产生可用空间，GC 可能会更积极地收集。这对于防止（跨机器）不必要的页面调度很重要。
- 如果临时段空间不足，GC 可能会进行更积极的临时收集（意味着做更多的 gen1），以避免获取新的堆段。

## GC 流程

### 标记阶段

标记阶段的目标是找到所有活动对象。

分代收集器的好处是能够只收集堆的一部分，而不必一直查看所有对象。在收集临时代时，GC 需要找出这些代中哪些对象是活动的，这是 EE 报告的信息。除了 EE 保持活动的对象外，老一代中的对象也可以通过引用它们来保持年轻一代中的对象活动。

GC 使用卡片进行老一代标记。卡片由 JIT 帮助程序在赋值操作期间设置。如果 JIT 帮助程序看到临时范围内的对象，它将设置包含表示源位置的卡片的字节。在临时收集期间，GC 可以查看设置的卡片以获取堆的其余部分，并仅查看这些卡片对应的对象。

### 计划阶段

计划阶段模拟压缩以确定有效结果。如果压缩富有成效，GC 将开始实际压缩；否则它会清扫。

### 重定位阶段

如果 GC 决定压缩，这将导致移动对象，那么必须更新对这些对象的引用。重定位阶段需要找到指向正在收集的代中的对象的所有引用。相比之下，标记阶段只咨询活动对象，因此不需要考虑弱引用。

### 压缩阶段

此阶段非常简单，因为计划阶段已经计算了对象应移动到的新地址。压缩阶段将把对象复制到那里。

### 清扫阶段

清扫阶段寻找活动对象之间的死空间。它用这些死空间创建空闲对象。相邻的死对象被合并成一个空闲对象。它将所有这些空闲对象放在 _freelist_ 上。

# 代码流程

术语：

- **WKS GC:** 工作站 GC
- **SVR GC:** 服务器 GC

## 功能行为

### WKS GC 关闭并发 GC

1. 用户线程耗尽分配预算并触发 GC。
2. GC 调用 SuspendEE 挂起托管线程。
3. GC 决定谴责哪一代。
4. 运行标记阶段。
5. 运行计划阶段并决定是否应进行压缩 GC。
6. 如果是，则运行重定位和压缩阶段。否则，运行清扫阶段。
7. GC 调用 RestartEE 恢复托管线程。
8. 用户线程恢复运行。

### WKS GC 开启并发 GC

这说明了如何进行后台 GC。

1. 用户线程耗尽分配预算并触发 GC。
2. GC 调用 SuspendEE 挂起托管线程。
3. GC 决定是否应运行后台 GC。
4. 如果是，则唤醒后台 GC 线程以进行后台 GC。后台 GC 线程调用 RestartEE 恢复托管线程。
5. 托管线程在后台 GC 工作的同时继续分配。
6. 用户线程可能会耗尽分配预算并触发临时 GC（我们称为前台 GC）。这以与“WKS GC 关闭并发 GC”风味相同的方式完成。
7. 后台 GC 再次调用 SuspendEE 以完成标记，然后调用 RestartEE 以在用户线程运行时启动并发清扫阶段。
8. 后台 GC 完成。

### SVR GC 关闭并发 GC

1. 用户线程耗尽分配预算并触发 GC。
2. 服务器 GC 线程被唤醒并调用 SuspendEE 挂起托管线程。
3. 服务器 GC 线程执行 GC 工作（与没有并发 GC 的工作站 GC 中的阶段相同）。
4. 服务器 GC 线程调用 RestartEE 恢复托管线程。
5. 用户线程恢复运行。

### SVR GC 开启并发 GC

此方案与开启并发 GC 的 WKS GC 相同，除了非后台 GC 是在 SVR GC 线程上完成的。

# 物理架构

本节旨在帮助您跟踪代码流程。

用户线程在分配上下文中耗尽空间，并通过 try_allocate_more_space 获取一个新的。

当 try_allocate_more_space 需要触发 GC 时，它会调用 GarbageCollectGeneration。

鉴于关闭并发 GC 的 WKS GC，GarbageCollectGeneration 全部在触发 GC 的用户线程上完成。代码流程为：

     GarbageCollectGeneration()
     {
         SuspendEE();
         garbage_collect();
         RestartEE();
     }

     garbage_collect()
     {
         generation_to_condemn();
         gc1();
     }

     gc1()
     {
         mark_phase();
         plan_phase();
     }

     plan_phase()
     {
         // 实际计划阶段工作以决定是否
         // 压缩
         if (compact)
         {
             relocate_phase();
             compact_phase();
         }
         else
             make_free_lists();
     }

鉴于开启并发 GC 的 WKS GC（默认情况），后台 GC 的代码流程为

     GarbageCollectGeneration()
     {
         SuspendEE();
         garbage_collect();
         RestartEE();
     }

     garbage_collect()
     {
         generation_to_condemn();
         // 决定进行后台 GC
         // 唤醒后台 GC 线程进行工作
         do_background_gc();
     }

     do_background_gc()
     {
         init_background_gc();
         start_c_gc ();

         //等待直到被 BGC 重启。
         wait_to_proceed();
     }

     bgc_thread_function()
     {
         while (1)
         {
             // 等待事件
             // 唤醒
             gc1();
         }
     }

     gc1()
     {
         background_mark_phase();
         background_sweep();
     }

# 资源

- [.NET CLR GC 实现](https://raw.githubusercontent.com/dotnet/runtime/main/src/coreclr/gc/gc.cpp)
- [垃圾回收手册：自动内存管理的艺术](http://www.amazon.com/Garbage-Collection-Handbook-Management-Algorithms/dp/1420082795)
- [垃圾回收 (维基百科)](http://en.wikipedia.org/wiki/Garbage_collection_(computer_science))
- [Pro .NET Memory Management](https://prodotnetmemory.com/)
- [.NET GC 内部机制视频系列](https://www.youtube.com/playlist?list=PLpUkQYy-K8Y-wYcDgDXKhfs6OT8fFQtVm)
