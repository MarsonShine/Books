带有本机代码的托管可执行文件
===

# 动机

自 .NET Runtime 发布以来的 10 多年里，用于分发与部署托管代码组件的文件格式一直只有一种：CLI 文件格式。该格式将所有执行表达为机器无关的中间语言（IL），必须在代码运行之前的某个时间点对其进行解释或编译为本机代码。缺乏一种高效、可直接执行的文件格式，是非托管与托管代码之间一个非常显著的差异，而且随着时间推移变得越来越成问题。问题包括：

- 生成本机代码需要相对较长时间并消耗电量。
- 出于安全/防篡改考虑，人们强烈希望验证任何即将执行的本机代码（例如对代码进行签名）。
- 现有本机代码生成策略会产出较为脆弱（brittle）的代码：当运行时或底层框架更新时，所有本机代码都会失效，迫使必须重新编译所有这些代码。

上述问题与复杂性都是非托管代码可以轻松避免的——因为非托管代码拥有一种具备如下特征的格式：

- 可执行格式可以被高效地直接执行。运行时只需要更新很少部分内容（绑定 _某些_ 外部引用）即可为执行做好准备。必须更新的内容也可以延迟完成。
- 只要遵循一组已知的版本规则，一个可执行文件中的版本兼容变更不会影响任何其他可执行文件（你可以彼此独立地更新可执行文件）。
- 格式定义清晰，因此多种编译器都可以生成该格式。

本提案正面解决托管与非托管代码之间的这种差异：为托管代码提供一种具有上述非托管特征的文件格式。有了这样的格式，托管代码在部署特性上至少与非托管代码达到同等水平。这是一个巨大的收益！


## 问题约束

.NET Runtime 很早就有了本机代码故事（NGEN）。然而本文提出的方案在架构上与 NGEN 不同。NGEN 本质上是一个缓存（可选，只影响应用性能），因此映像的脆弱性并不成为问题：只要有任何变化，NGEN 映像就会被丢弃并重新生成。另一方面：

**一种本机文件格式携带着强保证：即便运行时或框架不断更新改进，该文件仍将继续可运行。**

本文的大部分内容都是在尽量少牺牲性能的前提下实现这一保证的细节。

这个兼容性保证意味着：与 NGEN 不同，你放入文件格式的任何东西都是一种 _负担（liability）_，因为你必须在所有未来运行时中支持它。这会驱动我们倾向于“极简主义（minimalist）”，只把真正必要的内容放入格式中。对我们放入格式的每一项内容，我们都必须相信下列至少一项：

1. 它很不可能发生变化（尤其是：在 CLR 的现有生命周期内我们从未改变过它）
2. 我们有一种方案，能够让未来运行时同时高效支持旧格式与新格式（无论是运行时效率还是工程复杂度）。

文件格式的每个特性都需要回答“它如何做版本演进”这个问题，而我们会尽量保持“极简主义”。


## 解决方案概要

如前所述，虽然 NGEN 是一种本机文件格式，但它太脆弱，并不适合作为本提案的起点。

仔细观察 CLI 文件格式会发现，它作为起点其实“没那么糟”。CLI 的核心是一组类似数据库的表（类型、方法、字段等各一张），表项指向可变长数据（例如方法名、签名、方法体）。因此 CLI 是一种“按需付费（pay for play）”的结构；而且它已经是公开的并且具备版本韧性，把它纳入格式几乎没有坏处。将它纳入后，我们还能获得以下有用特性：

- 立即支持运行时的 _所有_ 特性（至少对那些在文件中包含完整 CLI 的情况）
- 可以只添加“最重要”的、支持快速直接执行所需的数据；其他一切仍可保持 CLI 形式并沿用 CLI 的代码路径。考虑到我们希望在增强格式时保持极简，这一点非常有价值。

此外，扩展 CIL 文件以包含所需附加数据有一种“显而易见”的方式：CLI 文件具有一个定义良好的头结构，该头结构已经包含一个字段，可指向“附加信息”。这个机制今天就被 NGEN 映像使用。我们会用同样的技术，让现有 CLI 格式包含一个新的 “Native Header”，它再指向支持快速直接执行所需的任何附加信息。

这些附加信息最重要的部分包括：

1. 方法的本机代码（以及引用模块外部内容的方式）
2. 每个方法的垃圾回收（GC）信息：在允许 GC 的任意位置，能够知道寄存器与栈上的哪些值是指向 GC 堆的指针
3. 异常处理（EH）表：当抛出异常时用于定位异常处理器
4. 一张表：仅根据当前指令指针（IP）在代码中的位置，就能找到 GC 与 EH 信息（IP map）
5. 一张表：将元数据中的信息与对应的本机结构链接起来

也就是说，我们需要一种机制把“元数据世界”与“本机世界”连接起来。我们不能完全消除元数据，因为我们希望支持现有功能。尤其是，我们需要支持：其他 CLI 映像引用本映像中的类型、方法与字段。它们会通过元数据来引用这些信息；但一旦在元数据中找到目标条目，我们就需要找到与该元数据条目对应的实际本机代码或类型信息。这个附加表的目的就是充当托管引用的“导出（export）”机制。

其中一些信息可以省略或以更高效的形式存储，例如：

- 对于使用保守 GC 的环境（如 IL2CPP），可以省略 GC 信息。
- 对于“私有”的方法或类型，完整元数据并非严格必要，因此可以从 CLI 映像中裁剪掉。
- 元数据可以以更高效的形式存储，例如 .NET Native 的元数据格式。
- 截至 .NET 10，所有平台都使用 PE 格式。一个 [未来的改进](#platform-native-envelope-support) 是支持平台原生可执行格式（ELF、Mach-O），以利用平台 OS loader。


## 本机代码的版本兼容性定义

即便是 IL 或非托管本机代码，也存在能做的兼容变更的边界。例如，删除一个 public 方法对任何使用该方法的外部代码而言都必然是不兼容变更。

由于 CIL 已经有一套 [兼容性规则](https://github.com/dotnet/runtime/blob/main/docs/coding-guidelines/breaking-changes.md)，理想情况下，本机格式也应遵循与 CIL 相同的兼容规则。不幸的是，在所有情况下高效做到这一点很困难。在这些困难场景里，我们有多种选择：

1. 修改兼容性规则，直接禁止某些变更
2. 对有问题的场景永远不生成本机结构（回退到 CIL 技术）
3. 为有问题的场景生成本机结构，但仅当未发生不兼容变更时才使用它们
4. 生成更低效但更具韧性的本机代码

通常最难的版本问题围绕着：

- 值类型（struct）
- 针对值类型（struct）的泛型方法

这些之所以棘手，是因为值类型之所以有价值，正是由于它们比引用类型有更低开销；而这种价值通常通过“内联（inlined）”使用方式获得。这使得值类型的代码生成对值类型布局的任何变化都非常脆弱，这对韧性（resilience）不利。对 struct 的泛型也有类似问题。

因此，本提案 _不_建议尝试解决“在值类型布局变化的情况下仍保持版本韧性”的问题。相反，我们建议引入一条新的兼容性规则：

**对 public 值类型（struct）而言，改变其任何（包括 private）字段的数量或类型，都是破坏性变更（breaking change）。但如果该 struct 不是 public（即 internal），并且从任何 public 值类型中通过任意层级的值类型字段嵌套都不可达，则不受此限制。**

这是一条 CIL 目前并不存在的兼容性限制。除此之外，CIL 允许的其他变更都可以在不过分付出代价的情况下被本机代码所允许。尤其是以下变更是允许的：

1. 为引用类型添加实例字段与静态字段
2. 为值类型添加静态字段
3. 为引用类型或值类型添加虚方法、实例方法或静态方法
4. 修改已有方法（前提是语义兼容）
5. 添加新类型


## 版本气泡（Version Bubbles）

当托管代码发生变化时，我们必须确保：本机代码映像里的所有产物只依赖于其他模块中那些在不破坏兼容规则的前提下不可能变化的信息。这个问题的有趣之处在于：这些约束只会在你 _跨_ 模块边界时生效。

例如，考虑方法体内联。如果模块 A 内联了模块 B 中的方法，那么就会破坏我们期望的版本特性：当模块 B 中该方法发生变化时，模块 A 中就存在需要更新的代码（而我们并不希望这样做）。因此，跨模块内联是不允许的。但模块内部的内联仍然完全没问题。

总体而言，随着模块尺寸增大，版本约束带来的性能影响会降低，因为跨模块引用减少。我们可以利用这一观察，引入所谓的版本气泡（version bubble）。**版本气泡是一组我们愿意作为整体一起更新的 DLL 集合。** 从版本角度看，这组 DLL 相当于一个单一模块。在版本气泡内允许内联等跨模块优化。

值得再次强调本节中的一般原则：

**不跨版本气泡的方法与类型，其代码不需要付出性能代价。**

这条原则很重要，因为它意味着：我们后文讨论的性能代价只会落在全部代码的一部分（对多数应用而言是很小的一部分）上。

极端情况是：整个应用就是一个版本气泡。在这种配置中，为遵守版本规则不需要付出任何性能代价；但它仍然能从清晰定义的文件格式与运行时契约中受益——而这正是本提案的核心。

## 运行时版本演进

运行时版本演进使用不同技术解决，因为运行时负责解释二进制格式。

为了允许运行时变化，我们只要求新运行时既能处理所有旧格式，也能处理新格式。文件格式设计的“主要防线”是：对重要结构带上版本号，使得运行时可以通过检查版本号明确地区分并支持结构的新旧版本。

从根本上说，我们是在迫使运行时开发者意识到这一约束，并据此编写与测试代码。

### 对运行时演进的限制

如前所述，在设计版本兼容性时，我们可以选择通过修改破坏性变更规则来禁止某些变化，或确保格式足够灵活以允许演进。例如，对托管代码我们选择禁止值类型（struct）布局变化，以换取对 struct 的高效代码生成。

此外，该设计还包含少量影响运行时自身演进灵活性的限制：

- `System.Object` 的字段布局不能改变。（先是一个指针大小的类型信息字段，然后是其他字段。）
- 数组的字段布局不能改变。（先是一个指针大小的类型信息字段，然后是一个指针大小的 length 字段；之后是按现有对齐规则打包的数组数据。）
- `System.String` 的字段布局不能改变。（先是一个指针大小的类型信息字段，然后是一个 int32 大小的 length 字段；之后是以 UTF16 编码的、以 0 结尾的字符串数据。）

做出这些限制是因为：未来想要改变这些布局的可能性很低，而若 _不_做这些假设，性能代价很高。如果我们不假设 `System.Object` 的布局永远不变，那么框架之外 _每一个_ 字段读取都会跨版本气泡并付出代价。类似地，如果不假设数组或字符串布局，每次访问都会付出版本代价。

## 选择性使用 JIT

最后一点值得强调：在允许 JIT 的环境中，“选择性使用 JIT 编译器”是避免版本韧性导致代码质量下降的另一种工具。

例如，假设某个热路径用户方法跨版本气泡调用了一个很适合内联的方法，但由于版本约束无法内联。对此我们可以提供一个特性（例如某个 attribute），用于指示某个方法应当在运行时编译。由于 JIT 可以自由生成脆弱代码，它就可以执行该内联，从而提升程序稳态性能。确实会付出启动时间成本，但若这类“热方法”数量不多，则 JIT 编译量（及其代价）也不会太大。关键在于：应用开发者可以逐例做出这种权衡；而运行时支持该能力也很容易。


# 具备版本韧性的本机代码生成

由于我们的新本机格式以现有 CLI 格式为起点，我们可以在任何时候选择回退到它。因此我们可以分块地向格式中添加新部分。本节讨论“本机代码”这一块：为“普通”方法体发出本机代码所需的格式部分。包含这些附加信息的本机映像将不需要调用 JIT 编译器，但仍需要调用类型加载器来创建类型。

将版本韧性的本机代码生成按 CIL 指令拆分讨论会很有帮助。许多 CIL 指令（如 `ADD`、`MUL`、`LDLOC` 等）天然可以以版本韧性的方式翻译为本机代码。

但涉及对象模型的 CIL（如 `NEWOBJ`、`LDFLD` 等）则需要特别处理，如下所述。下面的描述大致按典型应用的性能优先级排序。通常每节会先描述当所有信息都在同一版本气泡内时的代码生成方式，再描述跨版本气泡时的方式。

我们以 x64 作为目标指令集，其他处理器架构采用同样策略也很直接。我们用如下简单示例来说明概念：

```
    interface Intf
    {
        void intfMethod();
    }

    class BaseClass
    {
        static int sField;
        int iField;

        public void iMethod()
        {
        }

        public virtual void vMethod(BaseClass aC)
        {
        }
    }

    class SubClass : BaseClass, Intf
    {
        int subField;

        public override void vMethod(BaseClass aC)
        {
        }

        virtual void intfMethod()
        {
        }
    }
```

## 实例字段访问 - LDFLD / STFLD

CLR 以“标准”方式存储字段，因此如果 RCX 持有一个 BaseClass，那么

```
    MOV RAX, [RCX + iField_Offset]
```

会从该对象取出 `iField`。`iField_Offset` 是在生成本机代码时就已知的常量。之所以能在编译期知道它，是因为我们规定 `System.Object` 的字段布局固定，从而 `BaseClass` 的整个继承链都在版本气泡内。即便 `BaseClass` 的字段里包含来自版本气泡外的 struct，这也仍然成立，因为我们将修改任何 public 值类型的字段布局视为破坏性变更。因此，对继承层次不跨版本气泡的类型而言，字段读取与以往一样。

考虑跨气泡场景：假设 `SubClass` 定义在与 BaseClass 不同的版本气泡中，我们要读取 `subField`。常规类布局规则要求 `subField` 位于 `BaseClass` 的所有字段之后。但 `BaseClass` 可能随时间变化，因此我们不能再把一个字面常量硬编码进代码中。取而代之，我们要求生成如下代码：

```
	    MOV TMP, [SIZE_OF_BASECLASS]
	    MOV EAX, [RCX + TMP + subfield_OffsetInSubClass]

	 .data // In the data section
     SIZE_OF_BASECLASS: UINT32 // One per EXTERN CLASS that is subclassed
```

这要求在模块中预留一个 uint32 大小的数据位置 `SIZE_OF_BASECLASS`，并在代码执行之前把 `BaseClass` 的大小填进去。字段读取因此多了一条指令：先读取大小，再用该动态值计算字段地址。若同一方法访问同一个类的多个字段，这个序列非常适合做 CSE（common sub-expression elimination，共同子表达式消除）优化。

还需要特别关注 `SubClass` 的对齐需求。

### GC 写屏障（GC Write Barrier）

.NET GC 是分代的：多数 GC 并不会收集整个堆，而是只收集“新生代”部分（它更可能包含垃圾）。为做到这一点，GC 必须知道哪些根指向新生代，这就是写屏障的作用。

每当 GC 堆中的某个对象引用被更新时，都必须调用额外的记账代码来记录这一事实。任何被更新的字段都将作为潜在根用于这些部分 GC。这里关键点是：对任何 GC 引用的字段更新都必须做额外记账。

写屏障由运行时的一组 helper 函数实现。这些函数有特殊调用约定（不会破坏任何寄存器），因此它们更像指令而不是普通调用。写屏障逻辑不需要为支持版本化做改动（它今天的工作方式就已经足够）。


### 初始化字段大小信息

一个关键观察是：只有在每个“跨版本气泡继承”的不同基类上才需要这一开销。因此类似 `SIZE_OF_BASECLASS` 的槽位数量通常不会很多。由于它们数量很少，编译器可以选择在模块加载时一次性初始化它们。

注意：如果你访问的是定义在另一个模块中的类的实例字段，你需要的不是类大小，而是某个具体字段的偏移。生成的代码会是同样模式（甚至更简单，因为第二条指令不需要额外 displacement）。我们的编码指南强烈不鼓励 public 实例字段，因此这种场景在实践中不太常见（通常会变成 property 调用），但我们仍可自然处理。

即便继承层次跨越多个版本气泡也不是问题：最终你只需要基类型的最终大小。一次性初始化时可能计算更久一点，但额外成本也仅此而已。

### 性能影响

显然我们多加了一条指令，使代码更大且运行更贵。但额外成本很小。最“糟糕”的场景是：该字段读取出现在一个紧密循环里。我们用一个跨版本气泡继承的链表节点做过测试：链表很长（1K），但足够小以至于能放进 L1 cache。即便在这个极端例子中（顺便说一句这很刻意：链表节点通常不会以这种方式跨气泡继承），额外成本也很小（< 1%）。

### Null 检查

托管运行时要求：对 null 实例指针进行字段访问必须产生 null reference exception。为避免插入显式 null 检查，代码生成器假设：访问小于某个阈值的地址（Windows NT 上是 64k）会产生 null reference exception。

如果我们允许跨模块继承层次的基类大小无限增长，该优化将不再可行。

为保持该优化，我们会限制跨模块继承层次中基类大小的增长。这是一条 IL 今天不存在的新版本限制。


## 非虚方法调用 - CALL

### 模块内调用

如果 RCX 持有一个 `BaseClass`，并且 `iMethod` 的调用方与 BaseClass 在同一模块内，那么方法调用就是一条简单的机器 call 指令：

```
        CALL ENTRY_IMETHOD
```

### 模块间调用

但若调用方在 BaseClass 的模块之外（即便仍在同一版本气泡中），我们就需要通过一次间接寻址来调用：

```
	    CALL [PTR_IMETHOD]

	.data // In the data section
    PTR_IMETHOD: PTR = RUNTIME_ENTRY_FIXUP_METHOD // One per call TARGET.
```

与字段场景一样，指针大小的数据槽 `PTR_IMETHOD` 必须在运行时被修补为指向 `BaseClass.iMethod` 的入口点。但与字段不同的是：因为这是在修补一个 call（而不是 MOV），我们可以让该 call 通过标准延迟加载机制在运行时“懒修补”。延迟加载机制通常使用底层技巧以追求最高效率。只要把 call 目标的解析留给运行时，任何底层延迟加载实现都可以使用。

### 为运行时创新保留灵活性

你可能会觉得：我们在代码生成与运行时 helper 中“烧死”了 slot fixup 的细节，从而永远失去了在该机制上创新的可能性。但事实并非如此。

我们所做的是：要求继续支持 _当前_ 的 fixup 机制。因此我们必须始终支持一个 `RUNTIME_ENTRY_FIXUP_METHOD` helper。不过我们完全可以设计一个全新的方案；只需要使用一个 _新的_ helper 并且 _保留_旧 helper 即可。这样，同一进程中混合运行新旧本机代码也不会有问题。

### 调用约定

上面的示例没有参数，因此调用约定问题并不明显。但 call site 的本机代码显然严重依赖调用约定；对任意特定 caller-callee 对，caller 与 callee 必须至少对该约定达成一致。

调用约定并非托管代码特有问题，因此硬件平台通常定义一种系统上的通用调用约定（让所有语言倾向于使用同一约定，从而实现互操作）。事实上，除了 x86，CLR 在所有平台上都试图遵循平台调用约定。

我们对最合适的托管调用约定的理解也随时间演进。经验告诉我们：为简化实现，值得始终将托管 `this` 指针放在固定寄存器中，即便平台标准调用约定并非如此。

#### 托管代码特有约定

除了通常的参数传递约定与用于返回值类型的隐藏 byref 参数之外，CLR 还有一些托管代码特有的参数约定：

1. 共享泛型代码在某些情况下会有一个隐藏参数，用于表示类型参数（适用于泛型类型上的方法与泛型方法）。
2. 与隐藏返回缓冲区相关的 GC 交互：关于隐藏返回缓冲区是否可能分配在 GC 堆上、从而需要用写屏障写入的约定。

这些约定也会被编码化。

### 性能影响

因为原本就已经是：模块外方法必须用间接调用，所以只要不做内联，版本化不会给非虚方法调用引入更多额外开销。因此，使本机代码具备版本韧性的主要代价，是默认禁止跨版本气泡内联。

解决该问题的最佳方式是避免“话痨（chatty）”的库设计（不幸的是，`IEnumerable` 就是一种话痨设计：每次迭代都要调用 `MoveNext` 并读取 `Current` 属性）。另一种缓解措施是前面提到的：允许库的使用方选择性地对一些方法做运行时 JIT 编译，以提升这些话痨调用的性能。

最后，你也可以使用新的自定义 `NonVersionableAttribute`：它实际上改变了版本契约，表示库提供方放弃修改该方法体的权利，因此允许对其进行内联。

本提案的默认策略是：默认禁止跨版本气泡内联；对关键方法选择性地允许内联（通过放弃修改方法体的权利）。

在实验中，禁用跨模块内联并对关键方法选择性启用内联，未观察到 ASP.NET 吞吐量的可见回退。

## 将非虚调用作为解决其他版本问题的基线方案

重要的一点是：一旦你有一种通过“可在运行时懒修补的槽位进行一次间接 CALL”实现的、具备版本韧性的非虚方法调用机制，那么所有其他版本问题 _都_可以通过同样方式解决：回调到“定义者（definer）”模块，让操作在那里发生。

这种技术的限制包括：

1. 你需要付出真实的间接函数调用与返回成本，以及参数准备成本。在那些原本不自然包含调用的构造中（例如读取字符串字面量或其他常量），这种成本可能可见。你可能通过其他技术获得更好性能（例如实例字段访问那节我们就做到了）。
2. 它会引入大量间接调用，对禁止运行时动态生成代码的系统并不友好。在最直接的实现中，需要在运行时创建一个小 helper stub；或者需要一种预创建或复用 stub 的方案。
3. 它要求定义程序集“知道”它负责定义哪些操作。一般而言，这可以通过运行时 JIT 编译所需内容来解决（因为运行时才知道需要哪些操作），但 JIT 编译恰恰是我们想在运行时避免的昂贵操作。

尽管有这些限制，该技术在大量问题上都工作得很好，并且概念简单。在调用方一侧，它尤其简单（一次间接 call）。很难更简单。

这种简单性意味着：你在调用方中固化的假设非常少，从而最大化版本演进灵活性，这也是一个很好的属性。并且，一旦完成这次间接调用，在被调用端仍可以生成最优代码。因此这是一个非常灵活的技术，我们会反复使用。

运行时目前支持两种虚调用分发机制。一种叫虚 stub 分发（virtual stub dispatch，VSD），用于调用接口方法。另一种是传统基于 vtable 的分发变体，用于调用非接口虚方法。我们先讨论 VSD。

假设 RCX 持有一个 `Intf`，那么对 `intfMethod()` 的调用大致如下：

```
	     CALL [PTR_CALLSITE]
	.data // in the data section
    PTR_CALLSITE: INT_PTR = RUNTIME_ENTRY_FIXUP_METHOD // One per call SITE.
```

这看起来与跨模块的非虚调用相同，但存在重要差异：与非虚调用一样，它通过一个存放在模块内的指针槽进行间接调用。但与非虚调用不同的是：它每个 call site 一个槽（而非每个 target 一个槽）。该槽中的内容保证总能到达目标（此例为 `Intf.intfMethod()`），但它被期望随着时间变化：起始时指向一个“笨 stub”，该 stub 只是调用一个运行时 helper 来进行查找（很可能较慢）。不过它可以把 `PTR_CALLSITE` 更新为一个能高效分发到实际出现类型接口方法的 stub（接口分发的 stub 细节与版本化无关）。

上述描述符合当前 CLR 对接口分发的实现。更重要的是：为了实现版本韧性，代码生成不需要做任何修改——今天就“天然可用”。因此，接口分发可以在无性能损失的情况下具备版本韧性。

而且我们可以看到：VSD 本质上就是“通过可更新槽位进行一次间接调用”这一基础技术的一个变体。主要差别在于：由于目标依赖运行时才能知道的值（`this` 的类型），fixup 函数永远无法完全移除自身，必须始终检查该运行时值并据此行动（可能包括再次修补槽位）。为了尽可能让 fixup 槽位稳定，我们为每个 call site 创建一个槽（而不是每个 target 一个槽）。

### Vtable 分发

CLR 也支持通过函数表（vtable）进行虚分发。但不幸的是，vtable 与字段一样存在版本韧性问题。该问题也可以用类似方法修复；但与字段不同，方法跨气泡 fixup 的数量更可能很高。另外，与字段不同的是：我们已经有一个可用且版本韧性的机制（VSD），因此 vtable 修复必须在某些方面优于 VSD 才值得投入。

vtable 分发仅在多态 call site 上比 VSD 更好（VSD 在多态时需要退回到哈希查找）。如果我们需要提升该场景性能，可以尝试一些缓解：

1. 如果多态程度有限，增加更多 case 在退回哈希表之前进行尝试，这一原型已经实现并被证明有用。
2. 对高多态场景，可以探索“动态 vtable 槽”的思路：随着时间推移，某个 vtable 槽所承载的虚方法可以变化。在退回哈希表之前，一个虚方法可以“认领”一个 vtable 槽，从而对 _任意_ 类型该方法的分发都变快。

总之，由于 VSD 的灵活性与天然版本韧性，我们建议在投资让 vtable 具备版本韧性之前先评估能否“修好” VSD，并在所有跨版本气泡的接口分发中使用 VSD。这并不排除在版本气泡内使用 vtable，也不排除未来当我们发现 VSD 无法被修好时再添加基于 vtable 的分发支持。


## 对象创建 - NEWOBJ / NEWARR

对象分配总是通过一个 helper 调用来完成：该 helper 分配未初始化对象内存（但会初始化类型信息 `MethodTable` 指针），随后调用类构造函数。根据类型特征（是否有终结器、是否小于某个大小阈值等）会有不同的 helper。

我们将分配对象时使用哪个 helper 的选择推迟到运行时。例如，要创建 `SubClass` 的实例，代码可能是：

```
        CALL [NEWOBJ_SUBCLASS]
    	MOV RCX, RAX  // EAX holds the new object
		// If the constructor had parameters, set them
	    CALL SUBCLASS_CONSTRUCTOR

    .data // In the data section
    NEWOBJ_SUBCLASS: RUNTIME_ENTRY_FIXUP // One per type
```

其中 `NEWOBJ_SUBCLASS` 会用标准的懒修补技术完成修补。

创建新数组（NEWARR 指令）也可用同样技术。


## 类型转换 - ISINST / CASTCLASS

本提案建议使用与对象创建相同的技术。

注意：类型转换很容易成为 VSD 技术能发挥作用的地方（因为某个特定转换点可能是单态的），因此缓存上一次类型转换结果会带来性能收益。但这个优化对版本韧性而言并非必需。


## 类型的 GC 信息

垃圾回收器要做好工作，必须能够对 GC 堆中的任意对象找出其中所有 GC 引用。GC 还需要从头到尾“扫描”整个堆，这意味着它需要知道每个对象的大小。因此需要快速访问两类信息。

从版本角度看，GC 信息的根本问题在于：它通常包含来自整个继承层次的信息（与字段偏移类似），因此它不是版本韧性的。

虽然可以让 GC 信息本身具备韧性并让 GC 使用该韧性数据，但 GC 频繁发生而类型加载很少发生，所以如果可以权衡，应该牺牲类型加载速度来换取 GC 速度。

此外，GC 信息通常非常小（例如 12-32 字节），并且只会出现在跨版本气泡的类型上。因此在类型加载时动态地从版本韧性表示生成 GC 信息，是一个合理的起点。

另一个重要观察是：`MethodTable` 还包含其他非常频繁访问的数据，例如表示该 `MethodTable` 是否代表数组的 flag、指向父类型的指针等。这些数据会随着运行时演进而经常变化。因此，在运行时动态生成 method table 除了解决 GC 信息版本问题外，也能解决许多其他版本问题。

# 当前状态

截至 .NET 6，.NET SDK 可以使用 `crossgen2` 工具将应用发布为 ReadyToRun。该工具位于 `src/coreclr/aot/crossgen2`。coreclr 运行时对 ReadyToRun 的支持位于 `FEATURE_READYTORUN`。当前使用 RyuJIT 作为代码生成器来生成 ReadyToRun 映像。

## Platform-Native Envelope Support

截至 .NET 10，ReadyToRun 在所有平台上都使用 PE 格式。在 .NET 11，我们计划开始添加对其他格式的支持，首个目标是 Mach-O。更多细节请参阅 [ReadyToRun Platform-Native Envelope](./readytorun-platform-native-envelope.md)。
