1.类型int、long、long long、short 区别是什么？无符号与有符号类型的区别是什么？float 和 double 的区别是什么？

int：表示长度 16 位(bit)；long：32 bit；short：16 bit

无符号就是不带符号，只能表示大于 0 的树，二进制最高位一般表示符号位；

有符号能表示正数、负数和 0；

float：浮点数类型，表示单精度；7 位有效数字（有些是8位）；通过是用 32 bit 来表示，占据一个字（即 4 byte * 6 bit）

double：浮点数类型，表示双精度，16 位有效数字（有些是15位）；通常是用 64 bit 表示，占据双字；

针对 float 和 double 的有效位，我们可以用下面代码展示：

```c++
#include<stdio.h>

int main() {
    float f = 123456789.123456789;
    printf("%f\n",f);	// 123456792.000000 前 7 位是数字是一致的

    double l = 12345678998765.65656;
    printf("%lf\n",l);	// 12345678998765.656000 前 16 位数字一致
    return 0;
}
```

## float 和 double 的内存布局

都是由三个部分组成：

- 符号位：1 bit；0 表示正数，1 表示负数
- 指数位：用于存储科学计数法的指数部分，并且采用移位存储方式
- 尾数位：用于存储尾数部分

内存布局 float：| 1 bit |        8 bit        |        23 bit        |

尾数部分是 23 bit，并加上一个固定隐藏位，也就是 float 能存储 24 个二进制有效位。即
$$
10^7 = 10,000,000 < 2^{24} = 16,777,216 < 10^8 = 100,000,000
$$
即能存储 7 位有效数字；

内存布局 double：| 1bit |        11 bit        |        52 bit        |

同理，double 尾数部分是 52 bit，并加上一个固定隐藏位，即 double 能存储 53 个二进制有效位。即
$$
2^{15} = 1,000,000,000,000,000 < 2^{53} = 9,007,199,254,740,992 < 10^{16} = 10,000,000,000,000,000
$$
即能存储 15 位有效位数字；

## -1 对 256 取模的余数

这个问题来源于《C++ Primer》中对于将 -1 复制给无符号 char 的值。因为 -1 在计算机中是以补码的形式存储的。所以 -1 的原码是 `0x10000001`，即得知反码是 `0x11111110`；所以补码则是 `0x11111111`。

> 补码 = 反码 + 1

所以 -1 对 256 取模余数就等价于 255 % 256 取模的余数就为 255。

那么从数学角度讲：取模运算时，对于负数应该加上被除数的整数倍，使结果大于或等于 0 之后再运算，即
$$
(-1)\%256 = (-1+256)\%256 = 255\%256 = 255
$$

## 有符号数与无符号数运算

当运算表达式中既含有符号数又含有无符号数，有符号数会自动转换为无符号数参与运算。

## 注意进制数之间的隐藏转换

```c++
int month = 9, day = 7;
int month = 09, day = 07;
```

第一行是十进制。而第二行，因为带了 0，所以会自动转换成八进制。而09不是有效的八进制数，而 day 就是八进制的 07。

## 转义序列

| 名称                             | 转义符 |
| -------------------------------- | ------ |
| 换行符                           | \n     |
| 横向制表符                       | \t     |
| 纵向制表符                       | \v     |
| 退格符                           | \b     |
| 双引号                           | \\"    |
| 单引号                           | \\'    |
| 问号                             | \\?    |
| 报警（响铃）符                   | \\a    |
| 回车符                           | \\r    |
| 进纸符（跳页到上一页的尾部位置） | \\f    |
| 反斜杠                           | \\     |

```
// 进纸符
std::cout << "123123\fasda";
// 输出
123123
      asda
```

## 初始化与赋值的区别

c++初始化一个变量，并不是对变量进行赋值操作。而是先开辟一个内存空间来存储这个变量，并赋予默认的值。

而赋值的操作是把对象当前值擦除，用另一个新值来替代。

具体的初始化过程详见：https://zh.cppreference.com/w/cpp/language/list_initialization

未初始化的变量所在的位置，其默认值也会有影响：定义于函数体内的内置类型的对象如果没有初始化，则值为未定义。类的对象如果没有显式地初始化，则值由类决定。

```c++
#include<iostream>

std::string global_str;
int global_int;
int main()
{
    int local_int;
    std::string local_str;

    std::cout << "local_int = " << local_int << "global_int = " << global_int << "local_str = " << local_str << "global_str = " << global_str << std::endl;
    return 0;
}
```

## 申明与定义

申明：给一个变量的名称给多个文件引用：`extern int i`

定义：创建与名字关联的实体 `int i = 0`

> 注意：在使用申明的时候，切记不能给名称赋值，如果赋值就失去 extern 的意义，而变成了定义。

## 变量作用域

同一个变量所在的位置，那么引用同一个变量名称所指向的可能是不同的实体。这跟作用域相关。

## 复合类型

### 引用

引用其实就是给另一个对象命名为另一个名字，用前缀`&`申明。引用类型的初始值必须是一个对象，并且必须要初始化。

```c++
#include<iostream>
int main()
{
    int iVal = 1024;
    int &refVal = iVal; //变量refVal指向iVal的另一个名字而已，即都是同一个对象。

    int &refVal4 = 10;  //引用不能直接引用一个数字，而是要引用一个对象。
    double dval = 1.34;
    int &refVal5 = dval;//引用类型不正确，refValue5复制必须是一个int类型。
    return 0;
}
```

### 指针

指针与引用类似，也可以指向另一个对象，但指针本身就是对象，所以允许对指针进行赋值和拷贝。也不需要必须初始化，在未初始化时，这个指针对象的值是未确定的。用 `*` 表示。

同样，指针与指针的复制与引用，类型必须要一致。

```
void pointer()
{
    int iVal = 24;
    int *p = &iVal; //指针p存储的是指向iVal的地址，或者说是 p 指向ival的指针
}
```

那么该如何访问指针对象的值呢？可以使用解引用符来访问该对象：

```c++
void pointer()
{
    int iVal = 24;
    int *p = &iVal; //指针p存储的是指向iVal的地址，或者说是 p 指向ival的指针
    cout << *p;	// 由符号*得到指针p所指的地址的值，也就是24
}
```

```c++
void operate() 
{
    int i = 42;
    int &r = i; //与i是同一个对象，取名为r
    int *p;// 申明一个空指针
    p = &i;// 取址运算符，取i的地址复制给指针p
    *p = i;// 解引用符
    int &r2 = *p;//申明r2，初始化值为指针p的值（解引用符）
}
```

### *void

`*void`是一种特殊的指针，用于存放任意对象的地址。也仅仅只能表示有这个一个内存地址空间。所作的事情很有限：

1. 和别的指针比较
2. 作为函数的输入和输出
3. 赋值给另一个`*void`指针

## 指针与引用的区别

指针：引用的地址，指向任意对象类型。

引用：相当于给一个对象重命名，值与对象是捆绑到一起的。

引用是必须给一个**已存在的对象重新赋一个名字**。而指针是一个独立的对象。

引用一旦初始化，就必须给它赋值。指针可以重新分配和拷贝赋值。

引用总是获取最初绑定到的对象。一个指针在其生命周期内可以指向几个不同的对象。

引用定义就必须要初始化，指针在定义的时候可以不需要初始化。

## extern 关键字

如果想要暴露给其他文件使用，而不用在各自的文件夹下重复定义申明，这个时候我们可以使用 `extern` 关键字。

```c++
extern const int bufSize = 1024;
```

如果想在其它文件之间共享 const 对象，那么就必须用 extern 关键字表明。

## 引用与临时对象

首先来下面的定义

``` c++
int i = 42;
const int &r1 = i;
const int &r2 = 42;
const int &r3 = r1 * 2;
int &r4 = r1 * i;
```

运行就会发现，除了最后一行非法之外，都是合法的。那么为什么最后一种引用的写法是非法的呢？

```c++
double dval = 3.14;
const int &ri = dval;
```

像类似这种写法，其实c++编译器会改写成如下代码：

```c++
double dval = 3.14;
const int temp = dval;
const int &ri = temp;
```

就像上面所示，c++编译器其实会生成一个 temp 临时变量，常量引用 ri 被赋值的其实不是原始的 dval，而是编译器生成的对象。如果当 ri 不是常量的时候，就意味着我们肯定后续会存在对 ri 进行再赋值，并且程序员这么写极有可能是想通过 ri 修改 dval 的值，但是犹豫编译器的"操作"，这种写法就无效了，所以编译器就把这种行为归为非法操作。

## 常量指针

**指向常量的指针是申明一个指针，这个指针无法改变其所指的对象的指**。注意，常量指针并不是指向常量的指针。常量指针可以指向常量，也可以指向非常量。一旦定义就无法通过指针修改指针指向的值。那么如何限制指针指向的地址一经申明定义就无法更改呢？

这就是常量指针的作用。

**常量指针必须初始化，一旦初始化完成，其指向的地址就再也无法更改了。**

> 注意，常量指针指向的地址无法更改，没说地址的值无法更改。所以我们可以通过其它方式将这个地址的值更改。
