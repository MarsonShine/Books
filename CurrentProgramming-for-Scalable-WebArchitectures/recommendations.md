# 建议

在前三章中，我们回顾了可扩展网络架构组件的并发和并发编程的不同概念。我们将通过为每个阶段提供建议来总结我们的成果。由于我们回顾的组件细节各不相同，因此建议的范围也不尽相同。了解不同服务器架构的影响有助于深入了解预期性能。

应用逻辑是网络应用的核心。它通常是体系结构中包含由自己的开发人员实施的特定代码的部分。应用代码通常基于网络框架或应用容器。我们的指导原则仅限于该部分的并发概念。对于分布式数据库系统，我们主要关注不同一致性保证和数据模型的影响。

## 选择网络服务器架构

在[第 4 章](webserver-architectures-for-highconcurrency.md)中，我们讨论了网络服务器的 I/O 处理和连接并发机制。我们回顾了采用不同 I/O 和并发机制的流行架构。我们看到，各种模型都能达到足够的性能效果，而且大多数模型都有可靠的实现方法。在我们的架构方案中，网络服务器面临的挑战是高并发连接、极高的 I/O 并行性，但几乎没有共享状态。在这种特殊情况下，使用异步 I/O 的事件驱动架构往往能在负载情况下提供更好的可扩展性，因为它需要的内存更少，CPU 利用率更高。然而，这并不能取代一般的基于线程的服务器。当网络服务器用于通用设置时，或许也会在同一服务器实例中执行应用逻辑，基于线程的网络服务器仍然是有效的竞争者。

如果急需实现定制的网络服务器，选择正确的概念往往会受到平台和编程语言的限制。如果有条件，应考虑 I/O 多路复用策略（异步/非阻塞）和协同调度。此外，如[第 4 章](webserver-architectures-for-highconcurrency.md)评估部分所述，应审查底层框架。它们通常实现了网络服务器的基本构件，允许开发人员专注于依赖协议和特定应用的功能。

## 为应用逻辑选择正确的并发概念

[第 5 章](concurrency-concepts-for-applications-and-business-logic.md)的重点是应用逻辑编程的并发概念。为了推荐合适的概念，我们需要回顾一下网络应用程序可能隐含的不同并发需求。一方面，我们可能希望通过并行化请求的独立操作来减少请求处理的延迟。另一方面，我们可能希望协调不同的待处理请求，以便提供通知机制和支持服务器发起的事件。此外，交互式协作应用程序不能依赖于存储后端的孤立状态。相反，有些应用需要在应用服务器内共享高度波动和可变的状态。

减少请求延迟主要可以通过并行化独立操作来实现。例如，并行数据库查询和分支计算可减少整体延迟。**加速请求的一个重要特性是 CPU 相关操作和 I/O 相关操作的比例**。请注意，访问我们的平台组件是一种 I/O 绑定操作。只有在更多的内核上使用更多的线程，才能减少独立的、与 CPU 相关的操作的延迟。当额外的线程被用于重度 I/O 并行时，我们大致会遇到与之前网络服务器相同的问题。由于上下文切换开销和内存消耗，使用过多线程进行 I/O 绑定操作会导致性能下降和可扩展性问题。对于基于线程的编程模型，期货或承诺的概念有助于调度独立任务并最终收集其结果，而无需复杂的同步。代理可用于 I/O 绑定和 CPU 绑定操作，但效率取决于底层实现。**事件驱动架构可以很好地处理主要与 I/O 相关的任务**，但对于计算量大的操作，只要这些操作不外包给外部组件，它们就完全无法使用。

协调请求和同步共享应用程序状态是相互关联的。首先要区分的是这些操作的范围。有些应用允许部分隔离某些应用状态和用户组，以便进行交互。例如，一个有几十个玩家的浏览器多人游戏会话就是一个具有单一共享应用状态的概念实例。一个类似的例子是基于网络的协作软件应用程序，如实时文字处理器，与多个用户一起运行编辑会话。当使用会话亲和性时，正在运行的应用实例可以透明地映射到指定的应用服务器。因此，没有必要在应用服务器之间共享状态，因为每个会话都绑定到单个服务器（尽管一个服务器可以托管多个应用会话）。反过来，服务器可以完全隔离该会话的应用状态，并轻松协调待处理的通知请求。在这种情况下，事件驱动架构、基于 actor 的系统和 STM 都是合适的概念。由于存在死锁或竞赛条件的风险，应避免使用锁。需要注意的是，将特定状态绑定到某个服务器与我们对应用服务器的无共享设计是背道而驰的。

在其他情况下，应用程序状态是全局性的，无法分割成不同的部分。例如，大型社交网络应用程序的即时通讯功能要求任何用户都可以联系任何其他用户。在这种情况下，必须将状态外包给分布式后端组件（如支持 pub/sub 的分布式键/值存储，如 redis），或者要求应用服务器相互共享全局状态。前者适用于所有并发概念。后者只适用于使用分布式 STM 或分布式 actor 系统的情况。但请注意，这两种方法与我们偏好的无共享风格背道而驰，因为它们在应用服务器之间引入了依赖关系。

当实际不需要上述并发要求时，基于线程的传统请求执行模型概念仍然是一种有效的方法。在这种情况下，简单操作序列的概念为开发人员提供了一个非常直观的模型。如果不需要在应用程序逻辑中共享状态，那么专用的后端存储应始终是首选。如果保留基于线程的模型，并且确实需要在应用程序逻辑内部共享状态，则应优先使用 STM，以防止出现锁定问题。

如果一个 Web 应用程序的应用逻辑主要集成了其他平台组件提供的服务，并且不需要计算密集型操作，单线程事件驱动架构是一个很好的基础。当以无共享风格使用时，可以通过不断添加新实例来实现持续的扩展。

actor 模型和单线程事件驱动架构有几个共同的原则。两者都采用异步，基于消息或者事件的排队，以及隔离的状态——无论是在一个 actor 内部还是在单线程应用实例内部。实际上，我们的 Web 架构结合了这些概念中的任何一个用于应用逻辑，都在很大程度上类似于原始的 SEDA 架构[^Wel01]。与描述单个服务器内部的 SEDA 不同，我们则是使用非常相似的概念用于分布式架构。

## 选择存储后端

我们在[第 6 章](concurrent-scalable-storage-backends.md)中考虑了几种可用作大型网络应用程序存储后端的分布式数据库系统。假定单个数据库实例无法满足我们的要求，因为缺少扩展和提供高可用性的机会，我们需要为应用程序选择合适的分布式数据库系统。我们已经看到了强一致性和最终一致性之间的权衡。对非关系型数据库系统的炒作导致了无数不同的数据库系统可供选择。在实践中，寻求正确系统的过程往往被此时 SQL 阵营和 NoSQL 阵营之间的一般性争论所扭曲。以下指南就如何选择合适的系统提出了建议。

首要问题是应用程序施加的**实际数据模型**。**在考虑任何特定于数据库的模型之前，必须首先关注应用程序的内在数据模型**。确定代表应用程序中独立域的某些数据项组可能也有帮助。此外，牢记可能会改变数据模型的未来需求也很有帮助。例如，应考虑到频繁更改数据模型的敏捷开发风格。

接下来，必须**确定可扩展性要求**。使用额外的数据库实例来扩展博客应用程序，这与发展一个已经拥有多个数据中心的大型电子商务网站是不同的。此外，还应**预计规模的大小**。应用程序面临的挑战是对持久层的大规模并行访问，还是快速增长的数据存储量？读写操作的比例以及搜索操作的影响都很重要。

第三个初步考虑因素是应用程序的**一致性要求**。很明显，所有相关方通常都倾向于使用强一致性。不过，对陈旧数据在不同表现形式下的影响进行审查，可能有助于确定数据模型中可符合宽松一致性要求的部分。

由于关系数据库系统的成熟度、特性和我们的经验基础，它们仍然是网络应用程序持久层的坚实基础。当应用程序需要强大的一致性保证、事务处理行为和高性能事务处理时，情况尤其如此。此外，SQL 作为一种查询语言，其表现力是毋庸置疑的，而且可以随时执行临时查询。**为了解决关系数据库系统的可扩展性问题，必须从一开始就牢记功能和数据分区策略**。对未准备好的关系数据库进行分片是非常困难的。但是，如果在数据模型中设计了去规范化和分区，可持续扩展的机会就会大大增加。

文档存储非常有趣，因为它提供了一种非常灵活的数据建模方式，它结合了结构化数据，但并不依赖于模式定义。它允许快速发展数据模型，非常适合敏捷开发方法。结构化键值对（即文档）到领域对象的映射对于许多网络应用，尤其是围绕社交对象构建的应用来说，也是非常自然的。如果数据库操作主要涉及创建/读取/更新/删除操作，并且在开发阶段就可以定义更复杂的查询，那么文档存储就非常适合。JSON 或 XML 等面向文档的数据格式对网络开发人员非常友好。此外，许多文档存储允许在文档模型中存储图片等二进制文件，这对网络应用也很有用。由于文档的底层组织是键/值元组，因此文档存储可以通过对键空间进行分片来轻松实现横向扩展。

一般来说，当数据模型可以用具有任意值的键/值元组来表示，并且不需要复杂的查询时，键/值存储是首选。键/值存储不仅易于扩展，而且在需要进行大量并发读写操作时也非常适合。有些键/值存储使用易失性内存存储，因此能提供无与伦比的性能。这些系统是有趣的缓存解决方案，有时还辅以发布/订阅功能。其他持久化系统则根据法定人数设置提供可调整的一致性。采用最终一致性的键/值存储通常可随时接受写入操作，即使面对网络分区也不例外。由于数据模型类似于分布式哈希表，因此扩展通常非常容易。

图形数据库是一种相当特殊的存储类型，但在图形应用方面却无与伦比。最近，社交网络应用和基于位置的服务重新发现了图数据库在社交图操作或邻近搜索方面的优势。图形数据库通常提供事务支持和 ACID 合规性。在扩展时，图的分割是一个非难处理的问题。不过，此类应用的数据模型往往数据量较少。现有系统也声称可以使用商品硬件在单个实例上处理数十亿个节点、关系和属性。

在设计涉及**多个数据中心的超大型架构时，宽列存储成为首选系统**。它们支持具有宽表和极度稀疏列的数据模型。宽列存储在大规模批量写入操作和复杂的聚合查询中表现出色。从本质上讲，它们是数据仓库和分析处理的良好工具，但在事务处理方面却不那么合适。现有的系统有很多种，有的倾向于强一致性，有的倾向于最终一致性。宽列存储的设计便于扩展，并提供分片功能。

在设计大型网络应用程序时，还应该考虑到多重持久性。如果没有一种数据库类型能满足所有需求，那么可以将数据模型的不同领域分开，从而有效地使用不同的数据库系统。

举例来说，一个电子商务网站有非常不同的要求。产品库存是不可或缺的资产，客户希望获得一致的产品供应信息（=>关系型数据库系统）。客户数据很少变化，以前的订单也不会有任何变化。这两类数据都属于数据仓库存储，主要用于分析（=>宽列存储）。为计算建议而跟踪的用户操作可以异步存储到数据仓库中，以便日后进行解耦分析处理（=>宽列存储）。对购物车内容的影响则截然不同。客户希望每次操作都能成功，无论数据中心的某个节点是否发生故障。因此，为了接受每一次写入（如添加到图表）操作（=>宽列存储），最终一致性是必须的。当然，电子商务应用程序必须处理冲突操作的后果，通过合并购物车的不同版本。对于产品评级和评论，一致性也可以放宽（=>文档存储）。对于大多数其他大规模 Web 应用程序，非常类似的考虑也是可取的。

## 总结

网络服务器架构的主要标准是 I/O 操作的范围、处理状态的必要性以及连接并发所需的稳健性。我们已经看到，在我们的架构中，网络服务器最好考虑 I/O 多路复用策略和协同调度。

对于作为应用服务器一部分的并发概念，确定实际的并发需求非常重要。减少请求延迟需要请求逻辑的并行化策略。在应用服务器内部协调不同的待处理请求并共享高度波动和多变的状态，可以使用外部后端组件或应用服务器内部的高级并发抽象来处理。

选择合适的存储后端取决于实际数据模型、可扩展性要求和应用程序的一致性要求。此外，对于大型网络应用程序，应考虑使用多点持久性。

[^Wel01]: https://dl.acm.org/doi/10.1145/502059.502057