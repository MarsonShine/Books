# Unix 环境高级编程(APUE)

## 概念

**文件描述符**：非负整数，操作系统内核用以标识一个特定进程正在访问的的文件。在读写文件时，可以使用这个文件描述符。

**不带缓冲的I/O**: 函数 open、read、write、lseek 以及 close 属于不带缓冲的 I/O

**标准I/O**：标准函数提供了带缓冲的接口。性能更好，是最佳选择。

**程序**：是一个存储在磁盘上某个目录的可执行文件。**内核使用 `exec` 函数将程序读入内存并执行**。

**进程和进程ID**：程序的执行者就是进程，系统在开启一个进程时都会分配一个唯一的数字标识符，即称为进程ID。

**进程控制**：通过系统提供的三个函数控制进程；`fork`、`exec`、`waitpid`

**线程和线程ID**：通常一个进程只有一个控制线程——**某一时刻执行的一组机器指令**。一个进程内的所有线程都共享同一个地址空间、文件描述符、栈以及进程相关的属性。

**用户ID**：一个非负整数的数字，标识一个用户。ID 为 0 表示用户为根用户（root）。

**组ID**：标识用户的组，被用于将若干用户集合到项目和部门中去。这种机制允许同组的各个成员之间共享资源（文件）。

**信号**：用于通知系统发生了某种情况。如中断处理信号，用 signal 函数捕获信号

**时间**

- **时钟时间**：也叫墙上时间（wall clock time）；它标识进程运行的时间总量。
- 用户 CPU 时间：表示执行用户指令所用的时间。
- 系统 CPU 时间：表示该进程执行内核程序所经历的时间。

**系统调用**：进入操作系统内核的入口函数

## 文件I/O

### 文件描述符

在 Unix 系统中，文件描述符约定成俗：

- 文件描述符0：表示进程的标准输入
- 文件描述符1：表示标准输入
- 文件描述符2：表示标准错误

### 文件共享

UNIX 系统支持不同的进程共享打开文件。

UNIX 内核使用三种数据结构表示打开的文件信息：

- 每个进程在进程表中都有一个记录项，记录项中包含一张打开**文件描述符表**，可将其视为一个矢量，每个描述符占用一项。与每个文件描述符相关联的是：
  - 文件描述符标志（close_on_exec）
  - **指向文件表项的指针**
- 内核为所有打开文件维持一个**文件表**。每个文件表项包含：
  - 文件状态标识（读、写、追加、同步和非阻塞）
  - 当前文件偏移量
  - **指向该文件 v 节点表项的指针**
- 每个打开文件（或设备）都有一个 v 节点（v-node）结构。v 节点包含了文件类型和对此文件进行各种操作函数的指针。这些信息都是在打开文件时从磁盘上读入内存的，所以文件相关的信息都是随时可用的

关系图如下

![](./asserts/file-share-structure.jpg)

不同的进程打开同一个文件的结构图如下

![](./asserts/multi-process-open-one-file.jpg)

每个进程打开文件时都有自己的文件描述符表（即图中的进程表项）和文件表项，单只有一个 v-node 表项。这是因为对于文件表项，每个进程都要有它自己对该文件的偏移量。

> 关于文件共享，在《深入理解计算机系统》也有深入讲到
>
> 具体详见：https://github.com/MarsonShine/Books/blob/8002f0865f6f93c29677971d579a87e62dfeca29/CSAPP/docs/io.md#%E7%B3%BB%E7%BB%9F%E7%BA%A7-io

> 多个进程对同一个文件并发写入怎么办？
>
> 一般情况下，进程A 访问文件 F 时，写入内容并将偏移量（调用 `lseek` 方法）移到了 1500 处，这是发生内核切换；进程 B 访问文件 F，并将 F 文件的当前偏移量从 1500 移到了 1600。因为内容已经写入，所以内核将 v-node 表项中的文件长度更新为 1600。然后内核又进行切换回到了进程 A，当 A 调用 `write` 时，就从其当前文件偏移量（1500）处开始将数据写入到文件。这样就覆盖了进程 B 刚写入的内容了。
>
> 所以要解决这种并发问题，我们要将 “定位文件当前位置，写” 这两个动作（函数）合并为一个函数，这样就成为了一个“**原子操作**”。也就是说当内核发生切换时，在写操作之前，都将进程的当前偏移量设置到该文件的结尾处。函数 `pread`,`pwrite `就是这个作用。

#### 如何共享同一个文件表项？

![](./asserts/share-filetable-entry.jpg)

通过调用函数 `dup`、`dup2` 就可以复制一个已有的文件描述符。这些函数会返回新描述符与参数 fd **共享同一个文件表项**。

### 高速缓存一致性

UNIX 系统实现在内核中设有**缓冲区高速缓存**或**页高速缓存**，大多数磁盘 I/O 都通过缓冲区进行。当向文件写入文件时，**先将数据复制到缓冲区中，然后排入队列，稍后会写入磁盘**。这个过程称之为“**延迟写（delayed write）**”

有缓存就会带来数据一致性的问题，当内核需要重用缓冲区来存放其它磁盘的数据时，它会把所有延迟写数据块写入磁盘。为了保证磁盘上实际文件内容与缓冲区上的内容保持一致，UNIX 提供了 `sync、fsync` 和 `fdatasync` 三个函数同步数据。

## 文件和目录

文件类型分类如下：

1. 普通文件（regular file）。最常用的文件类型，这种文件包含了某种形式的数据（二进制还是文本格式）
2. 目录文件（directory file）。**这种文件包含了其它文件的名字以及指向这些文件有关信息的指针**。对一个目录文件具有读权限的任一进程都可以读该目录的内容，但只有内核可以直接写目录文件。
3. 块特殊文件（block special file）。这种类型的文件提供对设备（如磁盘）带缓冲的访问，每次访问以固定长度为单位进行。
4. 字符特殊文件（character special file）。该文件提供不带缓冲的访问，每次访问长度可变。系统中所有设备要么是字符特殊文件，要么是块特殊文件。
5. FIFO。该文件用于进程间通信，也成为命名管道（named pipe）
6. 套接字（socket）。这种文件类型用于进程间的网络通信。
7. 符号链接（symbolic link）。这种类型文件指向另一个文件。

### 文件访问权限

与进程相关的 ID 有 6 个或更多

- 实际用户ID
- 实际组ID

表示进程的所属

- 有效用户ID
- 有效组ID

用户文件访问权限检查

- 保存的设置用户ID
- 保存的设置组ID

由 exec 函数保存

------

`stat.st_mode` 表示对文件的访问权限。每个文件包含 9 个访问权限位，被分为 3 大类：

1. 用户权限
   1. S_IRUSR：用户读
   2. S_IWUSR：用户写
   3. S_IXUSR：用户执行
2. 组权限
   1. S_IRGRP：组读
   2. S_IWGRP：组写
   3. S_IXGRP：组执行
3. 其它权限
   1. S_IROTH：其它读
   2. S_IWOTH：其它写
   3. S_IXOTH：其它执行

如果进程拥有此文件（进程的有效用户 ID 等于文件的所有者 ID），则按用户访问权限批准或拒绝对该文件的访问。如果进程并不拥有该文件，但进程属于某个组，则按组访问权限进行授权和拒绝对该文件的访问。

#### 函数 access & faccessat

函数 `access` 和 `faccessat` 是按实际用户 ID 和实际组 ID 进行访问权限测试的。

## 文件系统

Unix 把磁盘分成一个或多个分区。每个分区都可以包含一个文件系统。i-node 是固定长度的记录项，包含了文件的大部分信息。

![](./asserts/disk-patition-filesystem.png)

其中 i 节点和数据块结构如下图：

![](./asserts/inode-datablock-filesystem.jpg)

上图显示有多个目录块同时指向一个 i 节点。每个 i 节点都有一个链接计数器，表示的就是指向该节点的目录块数。**只有当 i 节点的链接计数器显示为 0 时才能删除该文件。**这也就解释了为什么“解除对一个文件的链接”操作并不意味着“释放该文件所占用的磁盘块”。因此删除目录项的函数被称为 `unlink`。

> 还有一种链接是符号链接(symbolic link)。符号链接文件的实际内容（在数据块中）包含了该符号链接所指向的文件名字。

i 节点包含了文件有关的所有信息：**文件类型**、**文件访问**、**文件访问权限**、**文件长度**和**指向文件数据块的指针**等。`stat` 结构中的大多数信息都取自 i 节点。只有两项重要数据放在目录项中：文件名和 i 节点编号。

当在不更换文件系统的情况下为一个文件重命名，该文件的实际内容并为移动，只需要构造一个指向现有 i 节点的新目录块，并删除老的目录块。这样 i 节点的链接计数不用改变。

> 内核是如何删除文件的？
>
> **只有当链接计数为 0 时，该文件的内容才可以删除**。另一个条件也会阻止删除文件的内容：只要有进程打开了这个文件，其内容也不能删除。关闭一个文件时，内核首先检查打开该文件的进程个数；如果进程个数为 0，内核再去检查其链接个数；如果链接计数也为 0，那么就可以删除该文件的内容。

## 符号链接

符号链接是对一个文件的间接指针，它与硬链接有所不同，硬链接直接指向文件的 i 节点。引入符号链接的原因是为了避开硬链接的一些限制：

- 硬链接要求链接和文件位于同一个文件系统。
- 只有超级用户才能创建指向目录的硬链接（在底层文件系统支持的情况下）

对符号链接以及指向它向何种对象并无任何文件系统限制，任何用户都能创建指向目录的符号链接。

```sh
mkdir foo					# 创建一个新目录
touch foo/a					# 创建一个 0 长度的文件
ln -s ../foo foo/testdir	# 创建一个符号链接
ls -l foo
```

我们可以凭空创建一个符号链接，通过 `ls` 就能查看到具体的文件信息：

```sh
ln -s /no/such/file myfile	# 创建一个符号链接
ls myfile	# 查看一个本不存在的文件
cat myfile	# 查看文件内容
ls -l myfile	# 查看文件属性
```

ls 提示文件 myfile 存在，但是 cat 文件时却会报没有文件的错误。其原因就是因为 myfile 符号链接导致的。

## 标准I/O库

### 临时文件

使用 `tmpnam` 和 `tempnam` 都存在一个问题：在返回唯一的路径名和用该名字创建文件之间存在一个窗口期，在这个时间窗口内，可能会存在另一个进程用相同的文件名创建文件。这个时候就应该使用 `tmpfile` 和 `mkstemp` 函数创建文件就可以避免这个问题。

## 时间和日期

unix 系统内核提供的时间服务是计算自协调世界时(Coordinated Universal Time, UTC)公元 1970 年 1 月 1 日 00:00:00 这一特定时间以来经过的秒数。

## main 函数执行

c 程序总是从 main 函数执行的。

```c
int main(int argc, char *argv[]);
```

其中 argc 是命令行参数的数目，argv 是指向参数的各个指针所构成的数组。

当内核执行 c 程序时（使用的是 exec 函数），在调用 main 之前会先调用一个特殊的**启动例程**。**可执行程序文件将此启动例程指定为程序执行的起始地址**——这是由连接编辑器设置的，而连接编辑器则由 c 编译器调用。启动例程从内核取得命令行参数和环境变量值，然后为调用 main 函数做好准备。

### 进程终止

进程终止包含三个方面：

1. 正常终止：1）从 main 返回。2）调用退出函数；如（`exit`,`_exit`,`_Exit`）
2. 多线程：1）最后一个线程从启动例程返回。2）从最后一个线程调用 `pthread_exit`
3. 错误异常：1）调用 `abord`。2）接到一个信号。3）最后一个线程对取消请求做出响应

当执行一个程序时，调用 `exec` 的进程可以将命令行参数传递给新的程序。

> 当进程调用 `exec` 函数时，该进程被完全替换为新程序。
>
> 注意，调用 exec 函数并不创建新进程，所以前后进程的 ID 并没有改变。

### 环境表

每个程序都会接受一个**环境表**。与参数表一样，环境表也是一个**字符指针组**，其中每个指针包含一个以 null 结束的 C 字符串的地址。全局变量 `environ` 包含了该指针数组的地址：`extern char **environ`

![](./asserts/environ-table.jpg)

## C 程序的存储空间

C 程序一直是由以下几个部分组成：

- **正文段**。这是由 CPU 执行的机器指令部分。通常，正文段是可共享的，所以即使是频繁执行的程序在存储器中也只需要有一个副本，**并且正文段是只读的，目的是为了防止篡改**。

- **初始化数据段**。它包含了程序中明确地赋初值的变量。

- **未初始化数据段**。即 bss 段，这一名称来源于早期汇编程序一个操作符，意思是“由符号开始的块”（block started by symbol），在程序开始执行之前，内核将此段中的数据初始化为 0 或空指针。如函数外的申明：`long sum[1000]`，这种变量就存储在非初始化数据段中。

- **栈。自动变量以及每次函数调用时所需保存的信息都保存在此段中。每次函数调用时，其返回地址以及调用者的环境信息（如某些机器寄存器的值）都存放在此段中**。

  在函数调用时会在栈上自动分配临时变量。比如在调用递归函数时，每次调用自身时都会开辟新的栈帧，因此一次函数调用中的变量集不会影响另一次函数调用所用的变量集。

- **堆。**一般进行动态存储分配。

其经典的结构图如下：

![](./asserts/7-6.jpg)

## 存储空间分配

unix 系统中有三个函数用于**存储空间动态分配**。

1. `malloc`，分配指定字节数的存储区。此存储区中的初始值不确定。
2. `calloc`，为指定数量指定长度的对象分配存储空间。该空间中的每一位（bit）都初始化为 0。
3. `realloc`，增加或减少以前分配区的长度。当增加长度时，可能需要将以前分配区的内容复制到另一个足够大的分配区（扩容操作）。

函数 `free` 释放指针指向的存储空间。被释放的空间会被送入可用至**存储区池**，以方便后续在某个时候调用上述三个方法进行再分配。

## 资源限制函数

每个进程都有一组资源限制，分为软硬两种类型：

- 软限制
- 硬选址

```
struct rlimit {
	rlim_t rlim_cur;	// 软限制
	rlim_t rlim_max;	// 硬限制
}
```

在更改资源限制时，必须要求满足下面要求：

1. 任何一个进程都可以将一个软限制值更改为小于或等于硬限制值。
2. 任何一个进程都可以降低硬限制值，但它必须大于或等于软限制值。
3. 只有超级用户才可以提高硬限制值。

| 限制              | 描述                                                         |
| ----------------- | ------------------------------------------------------------ |
| RLIMIT_AS         | 进程总的可用存储空间的最大长度。（`sbrk`,`mmap`）            |
| RLIMIT_CORE       | core文件的最大字节数，如果值为0，则阻止创建文件              |
| RLIMIT_CPU        | CPU时间的最大量值（秒），当超过软限制值时，向进程发送`SIGXCPU`信号 |
| RLIMIT_DATA       | 数据段的最大字节长度（初始化数据+非初始化+堆）。             |
| RLIMIT_FSIZE      | 可以创建的文件的最大字节长度。当超过此软件时，则向该进程发送`SIGXCPU`信号。 |
| RLIMIT_MEMLOCK    | 一个进程使用`mlock(2)`能够锁定在存储空间中的最大字节长度。   |
| RLIMIT_MSGQUEUE   | 进程为POSIX消息队列可分配的最大存储字节数。                  |
| RLIMIT_NICE       | 为了影响进程的调度优先级，nice可设置为最大值。               |
| RLIMIT_NOFILE     | 每个进程能打开的最大文件数。更改此限制将影响到`sysconf`函数在参数`_SC_OPEN_MAX`返回的值 |
| RLIMIT_NPROC      | 每个实际用户ID可拥有的最大子进程数                           |
| RLIMIT_NPTS       | 用户可同时打开的伪终端的最大数量。                           |
| RLIMIT_RSS        | 最大驻内存集字节长度（resident set size in bytes）。如果可用物理存储器很少，则内核将从进程处取回超过RSS的部分 |
| RLIMIT_SBSIZE     | 在任意给定时刻，一个用户可以占用的套接字缓存区的最大长度（字节） |
| RLIMIT_SIGPENDING | 一个进程可排队的信号最大数量。这个限制时 sigqueue 函数实施的。 |
| RLIMIT_STACK      | 栈的最大字节长度。                                           |
| RLIMIT_SWAP       | 用户可消耗的交换空间的最大字节数。                           |
| RLIMIT_VMEM       | 进程总的可用存储空间的最大长度。（`sbrk`,`mmap`）            |

### 为什么不能将一个指针返回给一个自动变量？

**因为当函数返回时，原本该函数所用的存储空间将由下一个调用的函数的栈帧所使用。所以如果还存在其它部分引用这部分的地址，这就会产生冲突和混乱。所以这个时候应该使用全局存储空间为这些变量分配空间。**

## 进程部分

系统中有一些专用进程。

进程 ID 为 0 的进程通常是**调度进程**，通常也被称为交换进程（swapper）。**该进程是内核的一部分**，它不执行任何磁盘上的程序，因此也被称为系统进程。

进程 ID 为 1 的进程通常是 `init` 进程，在自举过程结束时由内核调用。init 进程通常读取与系统相关的初始化文件（`/etc/rc*`，`/etc/inittab`，`/etc/init.d`等文件）,并将系统引导到一个状态。**init 进程不会终止**。注意，init 进程是用户进程而非内核进程。

还有如进程 ID 为 2 的页守护进程（paged daemon），负责支持虚拟存储器系统的分页操作。

### fork

一个进程调用 `fork` 函数会创建一个新的进程。

fork 函数被调用一次，会返回两次。两次返回的区别是：**子进程返回的是 0，而父进程返回值则是新建子进程的进程 ID。**

子进程和父进程都继续执行 fork 调用之后的指令。子进程是父进程的副本。例如，子进程获得父进程的数据空间、堆、栈的副本。

> 注意：是子进程所拥有父进程的副本，不是共享相同的存储空间。

**当子进程要修改某些数据时，就会触发写时复制（COW），内核为该修改的区域生成一个副本（通常是虚拟存储系统的一“页”）供子进程修改。**也即就是说，在子进程对变量做出的修改是不会影响到父进程中该变量中的值。

#### fork 下的文件共享

fork 还有一个特性是：父进程打开的所有文件描述符都会被复制到子进程中，共享同一个文件的偏移量。那么当父子进程同时对该文件进行写操作该如何呢？

如果父进程的标准输出已重定向，那么子进程写到该标准输出时，它将更新与父进程共享的该文件的偏移量。假设当父进程等待子进程时，子进程写到标准输出，而在子进程终止后，父进程也会写到标准输出上，并且知道其输出会追加在子进程所写的数据之后。

> 当两个进程对同一个文件进行写操作，会发生内容覆盖。如果要拒绝这种情况发生，应该使用文件锁定机制。

![](./asserts/8-2.jpg)

如果父进程和子进程各自执行不同的程序段，那么在这种情况下，父进程和 fork 子进程会各自关闭它们不需使用的文件描述符，这样就不会干扰对方使用文件描述符了。

fork 一般有两种用法：

1. 一个父进程希望复制自己，使父进程和子进程同时执行不同的代码段。这在网络服务进程中非常常见，父进程等待客户端的服务请求。当请求到达时，父进程调用 `fork`，使子进程处理此请求。父进程则继续等待下一个服务请求。
2. 一个进程要执行不同的程序。这是对 `shell` 是常见的情况。在这种情况下，子进程从 `fork` 返回后立即调用 `exec`。

> 还有一个函数与 `fork` 相似 —— `vfork`。
>
> vfork 创建一个新进程，但是它是用于执行 `exec` 一个新程序。但是它并不将父进程的地址空间完全复制到子进程中，所以不能用它来修改数据等。
>
> 值得注意的是，**vfork 保证了子进程先运行**，在它调用了 `exec` 或 `exit` 之后父进程才有可能被调度执行。

### 进程终止

进程终止的时候如何通知其它父进程呢？

程序终止的时候，会通过将**“退出状态”**传参过去，然后内核会产生一个**“终止状态”**来说明异常终止的原因。这样其该进程的父进程就能通过 `wait/waitpid` 方法获取这个状态。

> 这种方式通过**“信号（SIGCHLD）”**实现的。信号是一种软中断，用于通知进程发生了某件事。该子进程终止时，它会向父进程发送一个 SIGCHLD 信号。然后父进程就能通过 `wait/waitpid` 等系统调用来等待子进程终止并处理 SIGCHLD 信号。

那么如果父进程在子进程之前终止会发生什么呢？

**内核会将该进程的父进程都会改为 init 进程。这是因为在 Linux 中，每个进程都必须有一个父进程，而当父进程终止时，内核需要将该进程的父进程设置为其他进程。如果没有其他进程可用，则将其设置为 init 进程。init 进程是所有进程的祖先，它是系统启动时第一个运行的用户级进程。**

> 在 Linux 中，当父进程在子进程终止之前终止时，内核会将该进程的父进程都会改为 init 进程。**这意味着子进程不会立即终止，而是由 init 进程领养**。如果子进程已经终止，则它们将成为**孤儿进程**，并由 init 进程收养。
>
> **孤儿进程：一个父进程退出，而它的一个或多个子进程还在运行，那么那些子进程将成为孤儿进程。孤儿进程将被 init 进程所领养，并由 init 进程对它们完成状态收集工作。**具体表现为：init 进程会循环调用 `wait/waitpid`。这样当知道该进程的终止状态后就会进而处理后续的清理工作。
>
> **僵死进程：一个进程使用 fork 创建子进程，如果子进程退出，而父进程并没有调用 wait 或 waitpid 获取子进程的状态信息，那么子进程的进程描述符仍然保存在系统中。这种进程称之为僵死进程。**

### waitid vs waitpid

`waitid` 和 `waitpid` 都是等待子进程的状态改变。`waitpid` 可以控制它所等待的进程，而 `waitid` 提供了更精确的控制，**可以选择等待哪个子进程的状态改变**。`waitid` 可以通过 `idtype` 和 `id` 这两个参数选择要等待的子进程。例如，`idtype == P_PID` 表示等待进程 ID 与 id 匹配的子进程。

> 关于 waitid 函数参数详解，可见：[Ubuntu Manpage: wait, waitpid, waitid - wait for process to change state](https://manpages.ubuntu.com/manpages/focal/en/man2/wait.2.html)

### 多进程竞争

如果一个进程希望等待一个子进程终止，则它必须调用 wait 函数中的一个。如果一个进程要等待其父进程终止，则可以使用如下代码：

```c++
while (gettpid() != 1)
	sleep(1)
```

很显然，这种轮询的方式非常耗费 CPU 资源。为此，UNIX 提供一种**信号**发送和接收的方法避免这种情况。

fork 在通常情况下，经常会遇到父子进程互相协作的场景。如父进程会用子进程 ID 更新日志文件中的一个记录，而子进程则可能要为父进程创建一个文件。**所以在一个进程完成操作之后要通知到对方，并且在继续运行之前，要等待另一方完成其操作**。示例代码如下：

```c
#include "apue.h"
TELL_WAIT(); // 为 TELL_XXX 和 WAIT_XXX 设置事情。
if ((pid = fork()) < 0)
    err_sys("fork error");
else if (pid == 0) { // 子进程
    // 子进程继续执行要做的事情 ...
    TELL_PARENT(getppid()); // 通知父进程
    WAIT_PARENT(); // 等待父进程
    // 子进程继续执行
    exit(0);
}
// 父进程继续执行要做的事情 ...
TELL_CHILD(pid);    // 通知子进程
WAIT_CHILD();// 等待子进程
// 父进程继续执行
exit(0);
```

通过一个例子来查看多进程发生竞争时会发生什么？以及如何通过信号修复。

一个由子进程输出，另一个由父进程输出：

```c
#include "apue.h"

static void charatatime(char *);

int main(void)
{
    pid_t pid;
    if ((pid == fork()) < 0) {
        err_sys("fork error");
    } else if (pid == 0) { // 子进程
        charatatime("output from child\n");
    } else {// 父进程
        charatatime("output from parent\n");
    }
    exit(0);
}

static void charatatime(char *str)
{
    char *ptr;
    int c;
    setbuf(stdout, NULL); // 设置无缓冲
    for (ptr = str; (c = *ptr++) != 0;)
        putc(c, stdout);
}
```

fork 之后无法控制两个进程的执行顺序，所以在执行过程会频繁的在两个进程之间切换。

下面是通过信号机制来避免竞争问题的代码段：

```CQL
#include "apue.h"

static void charatatime(char *);

int main(void)
{
    pid_t pid;
    TELL_WAIT();
    if ((pid == fork()) < 0) {
        err_sys("fork error");
    } else if (pid == 0) { // 子进程
        WAIT_PARENT(); // 等待父进程
        charatatime("output from child\n");
    } else {// 父进程
        charatatime("output from parent\n");
        TELL_CHILD(pid);    // 通知子进程
    }
    exit(0);
}

static void charatatime(char *str)
{
    char *ptr;
    int c;
    setbuf(stdout, NULL); // 设置无缓冲
    for (ptr = str; (c = *ptr++) != 0;)
        putc(c, stdout);
}
```

### 解释器

Unix 解释器是一种文本文件，其起始行的形式是：`#! pathname [optional-argument]`。其中 pathname 是绝对路径显示指定，就是解释器。所有的 UNIX 系统都支持解释器文件。最常用的就是 `#! /bin/sh`。解释器文件可以将程序隐藏起来，也就是说解释器文件本身是一个程序，可以被解释器（/bin/sh）编译的文件，在 UNIX 最常见的就是 shell 脚本。

### 切换用户ID和用户组ID

在UNIX系统中，每个进程都有一个**有效用户 ID** 和一个**有效组 ID**，用于确定该进程的权限。如果进程需要执行需要更高权限的操作，则需要更改其用户ID和组ID。例如，一个普通用户不能更改系统中的某些文件，但是如果该用户更改了自己的用户 ID和组 ID，就可以获得更高的权限并更改这些文件。

下面是一个 at 程序的示例，at 程序用于在指定的时间运行某个命令。该示例程序需要更高的权限才能创建和写入 at 作业文件，因此需要更改其用户 ID和组 ID：

```c
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>

int main(int argc, char *argv[]) {
    uid_t uid;
    gid_t gid;

    if (argc < 3) {
        fprintf(stderr, "Usage: %s time command [arg ...]\n", argv[0]);
        exit(EXIT_FAILURE);
    }

    uid = getuid();
    gid = getgid();

    seteuid(getuid());
    setegid(getgid());

    /* create and write to at job file */
    /* ... */

    seteuid(uid);
    setegid(gid);

    return 0;
}
```

在这个示例程序中，首先获取了当前进程的用户 ID 和组 ID，然后调用 `seteuid` 和 `setegid` 函数将进程的有效用户 ID 和有效组 ID 更改为当前用户 ID 和组 ID。

然后，程序创建和写入 at 作业文件，完成操作后再将进程的有效用户 ID 和有效组 ID 更改回原始值。

这样，该程序就可以在需要更高权限的情况下执行特定的操作，并在完成后恢复进程的原始权限，以确保安全性。

### 进程调度

进程调度是基于调度优先级的粗粒度机制。调度策略和调度优先级是由内核决定的。进程可以通过调整 `nice` 值选择以更低的优先级运行（调整 `nice` 值降低它对 CPU 的占用情况）。

进程可以通过调用 `nice` 函数来获取或更改值（只影响该进程的调度优先级，不影响其它进程）。

### 进程组

每个进程组有一个组长进程，组长进程的进程组 ID 就是创建进程组时进程 ID。

进程组组长可以创建一个进程组、创建该组中的进程，然后终止。只要在该组中还有任意一个进程，则该进程组就一直存在，这与创建该进程组的组长进程是否终止无关。从进程组创建开始到其中最后一个进程离开为止的时间区间就称为进程组的生命周期。某个进程组的最后一个进程可以终止也可以转移到另一个进程组。

### 控制终端

![](./asserts/9-7.jpg)

程序与控制终端交互，必须通过执行 `open("/dev/ttyN")` 函数实现交互。当然如果进程中没有一个控制终端，那么 `/dev/tty` 就不可用。

> UNIX 系统中的 `/dev/tty` 是一个特殊的文件，它表示当前进程的终端。它不一定是一个虚拟控制台设备（即 `/dev/tty n`），也可以是一个伪终端，一个串口等。如果你的进程没有一个终端，那么 /dev/tty 文件就不可用。比如守护进程就是这样的。你可以从 /dev/tty 读取和写入数据实现与终端的交互。

前台、后台作业以及终端驱动程序的作业控制流程：

<img src="./asserts/9-9.jpg"  />

### 孤儿进程组

前面已经说到什么是孤儿进程；而孤儿进程组是指一个进程组中所有进程的父进程都已经终止，而它们自己还在运行。这种情况下，内核会向该进程组中的每个进程发送一个 `SIGHUP` 信号，然后再发送 `SIGCONT` 信号，这样就能结束这些进程了。

> 为什么要结束孤儿进程？
>
> 当一个终端控制进程终止后，那么这个终端可以用来建立一个新的会话。这就会产生潜在的问题：原来旧的会话（一个或者多个进程组的集合）中的任意一个进程可以再次访问这个终端。所以为了防止这类问题的产生，就引入了孤儿进程组的概念。

> SIGHUP 是一种终止信号，它会让进程停止运行并退出。当内核向一个进程组中的每个进程发送 SIGHUP 信号时，这些进程会收到一个挂起信号，然后再收到一个 SIGCONT 信号，以此来结束这些进程。
>
> SIGCONT 是一个继续信号，它会让一个被挂起的进程继续运行。当内核向一个进程组中的每个进程发送 SIGHUP 信号时，这些进程会收一个挂起信号，然后再收到一个 SIGCONT 信号，以此来结束这些进程。

## 信号

### 中断的系统调用

当进程正在执行一个低俗系统调用而阻塞期间捕获到了一个信号，则该系统调用就会被中断而不再继续执行。该系统调用返回出错，其 errno 设置为 EINTR。系统将系统调用为两类：低速系统调用和其它系统调用；低速系统调用是指进程可能会永久阻塞的一类系统调用，包括：read、write、open、select、wait 等。对于这些函数，如果他们被中断，则可以**重启**他们。

这样会提高计算机的运行效率，它协调了外部设备速度慢和 CPU 处理速度块的矛盾，维持系统可靠正常运行。如果遇到异常情况，CPU 可以通过发起中断来维持系统稳定，满足实时处理要求，可以保证一些处理优先级高的程序优先处理。

### 可重入函数

可重入函数是指一个可以被多个任务调用的过程，任务在调用时不用担心数据是否出错。一个可重入的函数简单来说就是**可以被中断的函数**，也就是说，可以在这个函数执行的任何时刻中断它，转入 OS 调度下去执行另一段代码，而返回控制时不会出现什么错误。

而不可重入的函数由于使用了一些系统资源，如全局变量区，中断向量表等，所有它被中断的话，可能会出现问题，这类函数时不能运行在多任务环境下的。

> 通俗的讲：
>
> 可重入函数是指在多线程或信号处理程序中可以被安全地并发调用的函数。这些函数不会使用任何静态数据，也不会修改任何全局变量，因此可以被多个线程或信号处理程序同时调用，而不会出现竞争条件。
>
> 不可重入函数是指在多线程或信号处理程序中不能被安全地并发调用的函数。这些函数可能使用静态数据或全局变量，或者在执行期间修改它们，因此不能同时被多个线程或信号处理程序调用，否则可能会出现竞争条件和数据损坏。

### 信号集

每个进程都有一个信号屏蔽字（signal mask），它规定了当前要阻塞递送到该进程的信号集。对于每种可能的信号，该屏蔽字都有一位与之对应。对于某种情况，若对应其位置，则它当前是被阻塞的。进程可以调用 sigprocmask 来检测和更改其当前信号屏蔽字。

#### kill & raise

`kill` 函数的第一个参数 `pid` 可以有四种不同的情况：

1. `pid > 0`：发送信号给进程 ID 为 `pid` 的进程。
2. `pid == 0`：发送信号给与调用进程属于同一进程组的所有进程，但不包括调用进程本身。
3. `pid == -1`：发送信号给所有有权向其发送信号的进程，除了进程 ID 等于 1 的进程（init 进程）。
4. `pid < -1`：发送信号给进程组 ID 等于 `pid` 绝对值的所有进程，但不包括发送进程本身。

这些情况可以用于不同的场景，例如向指定进程发送信号、向同一进程组的所有进程发送信号、向所有进程发送信号等。

> raise(signo) 就等价于 kill(getpid(), signo)

#### sigprocmask

```c
void pr_mask(const char *str)
{
    sigset_t sigset;
    int errno_save;

    errno_save = errno; // 保存 errno
    if (sigprocmask(0, NULL, &sigset) < 0) {
        err_ret("sigprocmask error");
    } else {
        printf("%s", str);
        if (sigismember(&sigset, SIGINT)) // 检查 SIGINT 信号是否在信号屏蔽字中
            printf(" SIGINT");
        if (sigismember(&sigset, SIGQUIT)) // 检查 SIGQUIT 信号是否在信号屏蔽字中
            printf(" SIGQUIT");
        if (sigismember(&sigset, SIGUSR1)) // 检查 SIGUSR1 信号是否在信号屏蔽字中
            printf(" SIGUSR1");
        if (sigismember(&sigset, SIGALRM)) // 检查 SIGALRM 信号是否在信号屏蔽字中
            printf(" SIGALRM");

        /* remaining signals can go here  其他信号可以在这里添加 */

        printf("\n");
    }

    errno = errno_save; // 恢复 errno
}
```

`sigprocmask(0, NULL, &sigset)` 是一个系统调用，它的作用是获取或修改进程的信号屏蔽字。其中第一个参数 0 表示不修改信号屏蔽字，第二个参数为 NULL 表示不需要保存原来的信号屏蔽字，第三个参数 &sigset 表示获取当前的信号屏蔽字并保存到 sigset 变量中。

如果 `sigprocmask` 调用成功，返回值为 0，否则返回值为 -1，并且设置全局变量 errno 表示错误原因。因此，`sigprocmask(0, NULL, &sigset) < 0` 的判断就是判断 `sigprocmask` 调用是否失败。如果失败，就会执行 `err_ret("sigprocmask error")` 函数，打印错误信息并退出程序。如果成功，就会继续执行后面的代码，打印当前进程的信号屏蔽字中包含哪些信号。

#### sigsetjmp & siglongjmp

在信号处理程序中，当一个信号到达时，内核会中断当前进程的正常执行流程，转而执行信号处理程序。在信号处理程序中，如果直接使用 `longjmp` 函数进行跳转，会导致一些问题，例如跳转后的代码可能会覆盖一些寄存器的值，从而影响到原来的程序执行流程。这种跳转方式被称为“非局部转移”。

为了解决这个问题，我们可以使用 `sigsetjmp` 和 `siglongjmp` 这两个函数。它们与 `setjmp` 和 `longjmp` 函数的作用类似，**但是它们会保存和恢复信号屏蔽字，从而保证在跳转后，进程的信号屏蔽字不会被改变，从而避免了一些潜在的问题。**

因此，在信号处理程序中，如果需要进行跳转，应当使用 `sigsetjmp` 和 `siglongjmp` 这两个函数，而不是 `setjmp` 和 `longjmp` 函数。

#### abord 

`abort`函数用于异常终止程序的执行。当程序调用 `abort` 函数时，它会向进程发送一个 `SIGABRT` 信号，导致进程异常终止。在进程异常终止时，会执行一些清理工作，例如关闭打开的文件、释放分配的内存等。

`abort` 函数的主要作用是在程序出现无法恢复的错误时，快速地终止程序的执行。例如，当程序遇到一个无法处理的错误时，可以调用 `abort` 函数来终止程序的执行，以避免进一步的错误发生。

需要注意的是，`abort` 函数不会执行任何清理工作，例如关闭文件或释放内存。因此，在调用 `abort` 函数之前，应该先执行必要的清理工作，以避免资源泄漏等问题。

## 线程

### 自选锁

自旋锁在**非抢占式内核**中是非常有用的：除了提供互斥机制之外，它们会阻塞中断，这样中断处理程序就不会让系统陷入死锁状态，因为它需要获取已被加锁的自旋锁（把中断想成是另一种抢占）。在这种类型的内核中，中断处理不能休眠，因此它们能用的同步原语只能是自旋锁。

但是在用户层，自旋锁就不是很有用了。运行在分时调度类中的用户层线程在两种情况下可以取消调度：当它们的时间片到期时，或者具有更高调度优先级的线程就绪变成可运行时。在这些情况下，如果线程拥有自旋锁，它就会进入休眠状态，阻塞在锁上的其它线程自选的时间可能要比预期的时间要长。

### 条件锁

互斥量用于保护与条件变量关联的条件。在阻塞线程之前，`pthread_cond_wait` 和 `pthread_cond_timedwait` 函数释放与条件相关的互斥量。这就允许其他线程**获取互斥量、改变条件、释放互斥量以及给条件变量发信号**。

### 屏障（barrier）

屏障是用户协调多个协程并行工作的同步机制。屏蔽允许每个线程等待，直到协作所有线程都到达某一点，然后从该点继续执行。`pthread_join` 方法就是一种屏障，允许一个线程等待，直到另一个线程退出。

屏障对象的概念更广，它们允许任意数量的线程等待，直到所有线程完成处理的工作，而线程也不需要退出。所有线程到达屏障后可以继续工作。

## 线程管理

### 线程分离

**线程分离（Thread Dispatch）**如果对现有的某个线程的终止状态不感兴趣，可以使用 `pthread_detach` 函数让操作系统在线程退出时清理它所占用的资源。

### 同步对象

当多个进程可以访问同一个同步对象，会把同一个内存数据映射到他们自己的地址空间。

### 线程fork

当线程调用 fork，会将父进程的整个地址空间拷贝下来，父子进程之间还可以共享内存页的副本。如果父进程包含一个以上的线程，那么子进程在 fork 返回之后如果没有马上调用 exec，则需要清理锁的状态。

在子进程内部，只存在一个线程，它是由父进程中调用 fork 的线程的副本构成的。如果父进程占有锁，那么同样子进程就会占有这些锁。问题是子进程并不包含占有锁的这些副本。所以子进程不知道它到底占有了哪些锁，需要释放那些锁。所以为了解决这个问题，子进程在 fork 以后需要立即执行 exec 函数，这样就会清理锁的状态，从而避免这些问题。

通过调用 `pthread_atfork(void (*prepare)(void), void (*parent)(void), void (*child)(void))` 来清理锁的状态；

- prepare fork 处理程序由父进程再 fork 创建子进程前调用。目的是获取父进程定义的所有锁。
- parent fork 处理程序是在 fork 创建子进程之后、返回之前在父进程上下文中调用的。目的是 prepare fork 处理程序获取的所有锁进行解锁。
- child fork 处理程序在 fork 返回之前在子进程上下文中调用的。目的是释放 prepare fork 处理程序获取的所有锁。

该函数也有限制：

- 没有很好的办法对较复杂的同步对象（如条件变量或者屏障）进行状态的重新初始化。
- 某些错误检查的互斥量实现在 child fork 处理程序试图对被父进程的加锁的互斥量进行解锁时会产生错误。
- 递归互斥量不能在 child fork 处理程序中清理，因为它不知道该互斥量被加锁的次数。
- 如果子进程只允许调用异步信号安全的函数，child fork 处理程序就不可能清理同步对象，因为用于操作清理的函数全都不是异步信号安全的。实际的问题是同步对象在某个线程调用 fork 时可能处理中间状态，除非同步对象状态处于一致状态，否则无法清理。
- 如果应用程序在信号处理程序中调用了 fork，pthread_atfork 注册的 fork 处理程序只能调用异步信号安全的函数，否则结果将是未定义。

## 守护进程

守护进程是一种特殊的进程，它是运行在后台的一种服务程序，通常**独立于控制终端**并且周期性地执行某种任务或等待处理某些发生的事件。

守护进程不需要用户输入就能运行而且提供某种服务，不是对整个系统就是对某个用户程序提供服务。

守护进程不受控制控制，它不会随着终端的关闭而退出。

守护进程的编程规则：

1. 调用 `umask` 函数将文件模式创建屏蔽字设置为一个已知值。
2. 调用 `fork` 函数，然后使父进程 exit。
3. 调用 `setid` 创建一个新会话。
4. 将当前工作目录更改为根目录。
5. 关闭不再需要的文件描述符。
6. 某些守护进程打开 /dev/null 使其具有文件描述符 0、1 和 2,这样，任何一个试图读标准输入、写标准输出或标准错误的库例程都不会产生任何效果。

### 单实例守护进程

为什么需要单实例守护进程呢？

在任意时刻只运行该守护进程的一个副本，就叫单实例守护进程。如果一个守护进程需要访问一个设备，而该设备驱动程序有时会阻止想要多次打开 /dev 目录下相应设备节点的尝试。这就限制了在一个时刻只能运行一个守护进程的副本。

**文件和记录锁机制**提供了实现，该方法保证了一个守护进程只有一个副本在运行。如果每一个守护进程创建一个有固定名字的文件，并在该文件的整体上加一把写锁，那么只允许创建一把这样的锁。在此之后创建写锁的操作都会失败。如果该进程终止时，就会将锁自动清除。

## 高级I/O

### 记录锁

当两个人同时编辑一份文件时，会出现覆写的情况。如何进行互斥控制呢？

UNIX 提供了**记录锁（record locking）**特性：当第一个进程正在读或修改文件的某个部分时，使用记录锁就可以防止其它进程修改同一**文件区**。实际上这个记录锁又称为**字节范围锁（byte-range locking）**，因为它锁定的只是文件中的一个区域（也可能是整个文件）。

在 UNIX 系统中，当一个进程在文件上设置一把记录锁时，如果该锁与文件中已有的锁重叠，系统会将文件分裂成两个相邻的区域，其中一个区域包含被锁定的部分，另一个区域包含未被锁定的部分。这个过程可以用下面的图表来表示：

+------------------------+------------------------+------------------------+
|                        |                        |                        |
|  已有的锁区域           |  被锁定的区域           |  未被锁定的区域         |
|                        |                        |                        |
+------------------------+------------------------+------------------------+

在初始状态下，文件上没有任何锁。当设置锁时，文件上出现了一把记录锁，覆盖了整个文件。当释放锁时，文件上的记录锁被删除。为了确保锁的正确性和一致性，**系统会对相邻的区域进行分裂**，以避免锁的重叠和冲突。在分裂相邻区的过程中，系统会将文件分成多个区域，每个区域只包含一个锁。这样，当设置和释放锁时，就不会影响到其他区域中的锁。

这也是记录锁被称为“字节范围锁”的原因所在。

#### 死锁

如果两个进程相互等待对方持有且不释放的锁时，则这两个进程就处于死锁状态。如果一个进程已经控制了一个文件中的加锁区域，然后它试图对另一个进程控制的区域加锁，那么它就会休眠，在这种情况下就会发生死锁的情况。下面是死锁的例子：

```c
static void lockabyte(const char *name, int fd, off_t offset)
{
    if (writew_lock(fd, offset, SEEK_SET, 1) < 0) {
        err_sys("%s: writew_lock error", name);
    }
    printf("%s: got the lock, byte %lld\n", name, (long long)offset);
}

// 死锁
int main(void)
{
    int fd;
    pid_t pid;

    // 创建一个文件并写入数据
    if ((fd = creat("templock", FILE_MODE)) < 0) {
        err_sys("creat error");
    }
    if (write(fd, "ab", 2) != 2) {
        err_sys("write error");
    }

    TELL_WAIT(); // 创建一个文件锁

    // 创建一个子进程
    if ((pid = fork()) < 0) {
        err_sys("fork error");
    } else if (pid == 0) { // 子进程
        lockabyte("child", fd, 0); // 加锁
        TELL_PARENT(getppid()); // 通知父进程
        WAIT_PARENT(); // 等待父进程通知
        lockabyte("child", fd, 1); // 加锁
    } else { // 父进程
        lockabyte("parent", fd, 1); // 加锁
        TELL_CHILD(pid); // 通知子进程
        WAIT_CHILD(); // 等待子进程通知
        lockabyte("parent", fd, 0); // 加锁
    }

    exit(0);
}
```

当检测到死锁时，内核必须选择一个进程接收并返回错误。

### I/O多路复用

非阻塞 I/O 读取数据，其基本思想是：将两个输入描述符都设置为非阻塞的，对第一个描述符发送一个 read。如果该输入上有数据，则立即读取并处理数据。如果无数据可读，则该调用立即返回。然后对第二个描述符做同样的处理。在此之后，等待一定的时间，然后再尝试从第一个描述符读取。这种方式被称为轮训。

#### 非阻塞 I/O

这种方法的坏处就是浪费 CPU 资源。大多数时间实际上是无数据可读的，因此执行 `read` 系统调用浪费了时间。在每次循环后要等多长时间再执行下一轮循环也很难确定。虽然轮询技术在支持非阻塞 I/O 的所有系统上都可使用，但是在多任务系统中应当避免使用这种方法。

#### 异步 I/O

异步 I/O（asynchronous I/O）技术就是告诉内核：当描述符准备好可以进行 I/O 时，会触发一个**信号**通知它。这种技术有两个问题：

- 首先，不同的系统对异步 I/O 的支持不同，所以移植性是个问题。
- 这种信号对每个进程而言只有一个，如果该信号对多个文件描述符有作用，那么该信号就不知道具体是哪一个描述符准备好了。

#### I/O 多路复用

一种比较好的技术是使用 **I/O 多路复用（I/O multiplexing）**。为了使用这种技术，先构造一张我们感兴趣的描述符（通常都不止一个）的列表，然后调用一个函数，直到这些描述符中的一个已准备好进行 I/O 时，该函数才返回。`poll`、`pselect` 和 `select` 这 3 个函数使我们能够执行 I/O 多路复用。在从这些函数返回时，进程会被告知哪些描述符已准备好可以进行 I/O。

### select & pselect

```c
int select(int maxfdp1, fd_set *restrict readfds, fd_set *restrict writefds, fd_set *restrict exceptfds, struct timeval *restrict tvptr);
```

- `maxfdp1`：需要监视的文件描述符的数量，即文件描述符集合中的最大文件描述符加 1。

select 返回时，内核告诉我们：

- 已准备好的描述符的数量。
- 对于读、写、异常这三个条件中的每一个，那些描述符已经准备好。

`pselect` 是 `select` 函数的变体。`pselect` 系统调用与 `select` 系统调用的区别在于，它可以指定一个**信号屏蔽字**，当 `pselect` 调用阻塞时，只有未被信号屏蔽的信号才能唤醒它。`pselect` 系统调用的参数与 `select` 系统调用的参数基本相同，除了新增了一个 `sigmask` 参数，它是一个指向信号屏蔽字的指针，用于指定需要屏蔽的信号集合。如果 `sigmask` 参数为 `NULL`，则表示不屏蔽任何信号。`pselect` 系统调用的返回值与 `select` 系统调用的返回值相同，表示有事件发生的文件描述符的数量。返回时，会恢复以前的信号屏蔽字。

#### poll

```c
int poll(struct pollfd *fds, nfds_t nfds, int timeout);

struct pollfd {
    int fd;         // 文件描述符
    short events;   // 要监视的事件
    short revents;  // 实际发生的事件
};
```

- `fds`: 一个指向`pollfd`结构体数组的指针，每个结构体描述了一个要监视的文件描述符及其感兴趣的事件。
- `nfds`：要监视的文件描述符数量。
- `timeout`：超时时间，以毫秒为单位。如果设置为`-1`，则`poll()`函数将一直阻塞，直到有文件描述符就绪。如果设置为`0`，则`poll()`函数将立即返回，而不等待任何文件描述符就绪。

要注意的是，与 select 不同，poll 函数使用的是边缘触发（edge-triggered）方式，即**只有在状态发生变化的时候才会通知进程**。而 select 是采用水平触发（level-triggered）,即**只要描述符可读或可写就会一直轮询通知进程**。

### 存储映射I/O

**存储映射I/O（memory-mapped I/O）**能将一个磁盘文件映射到存储空间中的一个缓冲区中。当从缓冲区读取数据时，就相当于读取该文件中的内容。与此类似，将数据存入缓冲区时，相应的字节内容就会写入到文件。这样就可以在不使用 read/write 系统调用来执行 I/O。从而使得进程可以像访问内存一样访问这个文件或对象。

为了实现存储映射，首先要告诉内核将一个给定的文件映射到一个缓冲区中，这是通过 `mmap` 函数实现的。

```c
void *mmap(void *addr, size_t length, int prot, int flags, int fd, off_t offset);
```

- `addr`：映射的起始地址，通常设置为`NULL`，由内核自动分配。
- `length`：映射的长度，以字节为单位。
- `prot`：映射区域的保护方式，可以是以下值之一：
- `PROT_READ`：可读。
  - `PROT_WRITE`：可写。
  - `PROT_EXEC`：可执行。
  - `PROT_NONE`：不可访问。
- `flags`：映射区域的标志，可以是以下值之一或者它们的组合：

  - `MAP_SHARED`：共享映射，多个进程可以访问同一个映射区域。
  - `MAP_PRIVATE`：私有映射，每个进程都有自己的映射区域。
  - `MAP_FIXED`：强制指定映射的起始地址。
  - `MAP_ANONYMOUS`：匿名映射，不需要指定文件描述符。
- `fd`：要映射的文件描述符，如果是匿名映射，则设置为`-1`。
- `offset`：文件偏移量，通常设置为`0`。

`mmap()` 函数的返回值是映射区域的起始地址，如果映射失败，则返回 `MAP_FAILED`。

![](asserts/14-26.jpg)

当进程终止时，会自动解除存储映射区的映射，或者手动调用 `munmap` 函数也可以解除映射区。关闭映射存储区时使用的文件描述符并不解除映射区。

#### mmap/mmcopy vs read/write

这两者的主要区别是，read/write 是标准的文件 I/O 函数，它执行了更多的系统调用，并做了更多的复制。**read 将数据从内核缓冲区中复制到用户缓冲区，write 将数据从用户缓冲区复制到内核缓冲区。**

而 mmap/mmcopy 则是**直接将数据从映射到地址空间的一个缓冲区复制到另一个内核缓冲区**。

## 管道（pipe）

**管道（Pipe）**是一种进程间通信机制，它可以将一个进程的输出连接到另一个进程的输入，从而实现两个进程之间的数据传输。管道可以用于在不同进程之间传递数据，从而实现进程间的协作和数据共享。

通过管道可以实现父进程和子进程的同步：

```c
static int pfd1[2], pfd2[2];

// 创建一个从父进程到子进程的管道，并且父进程经由该管道向子进程传送数据
void TELL_WAIT(void)
{
    if (pipe(pfd1) < 0 || pipe(pfd2) < 0) { // 创建管道
        err_sys("pipe error");
    }
}

// 通知子进程
void TELL_CHILD(pid_t pid)
{
    if (write(pfd1[1], "p", 1) != 1) { // 向子进程写入数据
        err_sys("write error");
    }
}

// 等待子进程通知
void WAIT_CHILD(void)
{
    char c;

    if (read(pfd2[0], &c, 1) != 1) { // 从子进程读取数据
        err_sys("read error");
    }
    if (c != 'c') {
        err_quit("WAIT_CHILD: incorrect data");
    }
}

// 通知父进程
void TELL_PARENT(pid_t pid)
{
    if (write(pfd2[1], "c", 1) != 1) { // 向父进程写入数据
        err_sys("write error");
    }
}

// 等待父进程通知
void WAIT_PARENT(void)
{
    char c;

    if (read(pfd1[0], &c, 1) != 1) { // 从父进程读取数据
        err_sys("read error");
    }
    if (c != 'p') {
        err_quit("WAIT_PARENT: incorrect data");
    }
}
```

首先在调用 fork 之前创建了两个管道。父进程在调用 `TELL_CHILD` 时，会通过上一个管道写入一个字符 'p'，子进程在调用 `TELL_PARENT` 时，由下一个管道写入一个字符 'c'。相应的 WAIT_XXX 函数调用 `read` 读一个字符，没有读到字符则**阻塞（休眠等待）**。

作为 `pipe` 的封装方法，`popen` 实现的操作是：创建一个管道，fork 子进程，关闭未使用的管道端，执行一个 shell 命令，然后等待命令终止。

`pclose` 函数关闭标准 I/O 流，等待命令终止，然会返回 shell 的终止状态。

## 协同进程

**协同进程（Cooperative Process）**是一种进程间通信机制，它可以实现多个进程之间的协作和数据共享。协同进程的特点是多个进程之间可以相互通信和协作，从而实现复杂的任务和功能。

协同进程的实现方式是通过**共享内存**和**信号量**等机制来实现进程间的通信和同步。共享内存可以让多个进程访问同一块内存区域，从而实现数据共享和传输。信号量可以用于进程间的同步和互斥，避免出现数据竞争和死锁等问题。

`popen` 只提供连接到另一个进程的标准输入或标准输出的一个**单向管道**，而**协同进程**则有连接到另一个进程的**两个**单向管道：一个接到标准输入，另一个则连接到标准输出。这样我们就可以将数据写到标准输入，然后经过处理在标准输出读取数据。

## FIFO

管道其实分为两个类型：

- 匿名管道：它只能用于在父进程和子进程之间传递数据。
- 命名管道：它可以用于在不同进程之间传递数据。

FIFO 就是命名管道。

在使用 FIFO 进行进程间通信时，需要注意 FIFO 的缓冲区大小和数据传输的同步问题。由于 FIFO 是一种有名管道，可以被多个进程同时打开和使用，因此可能会出现多个进程同时向 FIFO 中写入数据的情况。如果多个进程同时向 FIFO中 写入数据，就可能会出现数据交叉和混乱的情况，从而导致数据的错误和丢失。

为了避免这种情况的发生，UNIX 系统中规定了一个常量`PIPE_BUF`，它表示 FIFO 的缓冲区大小。如果多个进程同时向 FIFO 中写入数据，就需要保证每次写入的数据量不超过`PIPE_BUF`字节，从而避免数据交叉和混乱的情况。这样就能保证多个进程之间的数据传输是同步的，不会出现数据的错误和丢失。

> 实际上，即使每个进程每次写入的数据量不超过`PIPE_BUF`字节，也可能会出现数据交叉和混乱的情况。这是因为多个进程同时向 FIFO 中写入数据时，内核并不能保证它们的写入顺序，也不能保证它们的写入操作是原子性的。
>
> 为了避免这种情况的发生，需要使用**同步机制**来保证多个进程之间的数据传输是同步的。例如，可以使用**互斥锁**或**信号量**等机制来保证每个进程在写入数据时都能够获得独占的访问权，从而避免数据交叉和混乱的情况。
>
> 此外，还可以使用其他的进程间通信机制来实现数据的同步和共享。例如，可以使用**共享内存**或**消息队列**等机制来实现多个进程之间的数据传输和同步。这些机制都可以保证多个进程之间的数据传输是同步的，避免出现数据交叉和混乱的情况。

## XSI IPC

**XSI IPC（X/Open System Interface Inter-Process Communication）**是一组用于进程间通信（IPC）的标准接口，由 X/Open 公司定义。XSI IPC 包括三种 IPC 机制：消息队列（Message Queues）、信号量（Semaphores）和共享内存（Shared Memory）。

### 消息队列

消息队列是一种进程间通信机制，允许一个进程向另一个进程发送消息。消息队列是一个消息的链表，每个消息都有一个**类型**和一个**数据部分**。发送进程可以指定消息类型，接收进程可以选择接收特定类型的消息。消息队列可以用于进程间同步和通信。

> 注意，消息队列还不完善。因为每个消息队列没有维护引用计数器（打开文件有这种计数器），所以在队列被删除后，仍在使用这一队列的进程会下一次队列操作时会出错返回。
>
> 要删除一个文件时，也要等到使用该文件的最后一个进程关闭文件描述符之后才会删除文件夹的内容。

### 信号量

信号量是一种进程间同步机制，用于控制对共享资源的访问。信号量是一个计数器，可以用于多个进程之间的同步。进程可以对信号量进行 P 操作（等待）和 V 操作（释放）。当信号量的值为 0 时，P 操作会阻塞进程，直到信号量的值变为正数。V 操作会增加信号量的值，唤醒等待的进程。

以下是使用例子：

```c
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <sys/types.h>
#include <sys/ipc.h>
#include <sys/sem.h>

#define KEY 1234

union semun {
    int val;
    struct semid_ds *buf;
    unsigned short *array;
};

int main(void)
{
    int semid, pid;
    union semun arg;
    struct sembuf sb;

    // 创建一个新的信号量集
    semid = semget(KEY, 1, IPC_CREAT | 0666);
    if (semid == -1) {
        perror("semget");
        exit(EXIT_FAILURE);
    }

    // 初始化信号量的值为 1
    arg.val = 1;
    if (semctl(semid, 0, SETVAL, arg) == -1) {
        perror("semctl");
        exit(EXIT_FAILURE);
    }

    // 创建一个子进程
    pid = fork();
    if (pid == -1) {
        perror("fork");
        exit(EXIT_FAILURE);
    }

    if (pid == 0) {
        // 子进程执行 P 操作
        sb.sem_num = 0;
        sb.sem_op = -1;
        sb.sem_flg = 0;
        if (semop(semid, &sb, 1) == -1) {
            perror("semop");
            exit(EXIT_FAILURE);
        }

        // 子进程输出一条消息
        printf("Child process\n");

        // 子进程执行 V 操作
        sb.sem_num = 0;
        sb.sem_op = 1;
        sb.sem_flg = 0;
        if (semop(semid, &sb, 1) == -1) {
            perror("semop");
            exit(EXIT_FAILURE);
        }

        exit(EXIT_SUCCESS);
    } else {
        // 父进程执行 P 操作
        sb.sem_num = 0;
        sb.sem_op = -1;
        sb.sem_flg = 0;
        if (semop(semid, &sb, 1) == -1) {
            perror("semop");
            exit(EXIT_FAILURE);
        }

        // 父进程输出一条消息
        printf("Parent process\n");

        // 父进程执行 V 操作
        sb.sem_num = 0;
        sb.sem_op = 1;
        sb.sem_flg = 0;
        if (semop(semid, &sb, 1) == -1) {
            perror("semop");
            exit(EXIT_FAILURE);
        }

        exit(EXIT_SUCCESS);
    }

    return 0;
}
```

### 共享内存

共享内存是一种进程间通信机制，允许多个进程共享同一块内存区域。共享内存可以提高进程间通信的效率，因为数据不需要在进程之间复制。但是，共享内存需要进行同步，以避免多个进程同时访问同一块内存区域。

### 小结

如果存在多个进程共享同一个资源，则可以使用`信号量`、`记录锁`、`互斥量`来协调访问。我们可以使用映射到两个进程地址空间中的信号量、记录锁或互斥量。

- 使用信号量，则先创建一个包含一个成员的信号量集合，然后将集合信号量初始化为 1。为了分配资源，以 `sem_op` 为 -1 调用 `demop` 函数。为了释放资源，以 `sem_op` + 1 调用 `semop` 函数。对每个操作都指定 `SEM_UNDO`，以处理在未释放资源条件下进程终止的情况。
- 使用记录锁，则先创建一个空文件，并用该文件的第一个字节（无需存在）作为锁字节。为了分配资源，先对该字节获得一个写锁。释放该资源时，则对该字节解锁。记录锁的性能确保了当一个锁的持有者进程终止时，内核会自动释放该锁。
- 使用互斥量时，需要所有的进程将相同的文件映射到它们的地址空间里，并且使用 `PTHREAD_PROCESS_SHARED` 互斥量属性在文件的相同便宜处初始化互斥量。为了分配资源，我们对互斥量加锁。为了释放锁，我们解除互斥量。如果一个进程没有释放互斥量而终止，恢复将是非常困难的，除非我们使用**鲁棒互斥量**。

## POSIX 信号量

前面有说到，多进程同步操作，需要用到 sem_op 加减 1 来完成多进程协同操作。而 POSIX 信号量的函数 `int sem_trywait(sem_t *sem)`、`int sem_wait(sem_t *sem)` 自动实现了这个方法。

使用 `sem_wait` 函数时，如果信号量计数器是 0 时就会发生阻塞。直到信号量减 1 或者被信号中断时才返回。如果要避免阻塞的话，可以使用 `sem_trywait` 函数。

而调用 `sem_post` 函数可使信号量计数器增 1。这和解锁一个二进制信号量或者释放一个计数信号量相关的资源的过程是类似的。

`sem_init` 函数是初始化一个未命名的信号量。

当未命名的信号量使用完成时，可以调用 `sem_destroy` 函数销毁它。

POSIX 信号量的性能要比 XSI 信号量要好不少。

```c
// 分配一个新的 slock 结构体
struct slock * s_alloc()
{
    struct slock *sp;
    static int cnt;

    // 分配内存空间
    if ((sp = malloc(sizeof(struct slock))) == NULL) {
        return NULL;
    }

    // 生成一个唯一的信号量名称
    do {
        snprintf(sp->name, sizeof(sp->name), "/%ld.%d", (long)getpid(), cnt++);
        sp->semp = sem_open(sp->name, O_CREAT | O_EXCL, S_IRWXU, 1);
    } while ((sp->semp == SEM_FAILED) && (errno == EEXIST));

    // 如果信号量创建失败，释放内存空间并返回 NULL
    if (sp->semp == SEM_FAILED) {
        free(sp);
        return NULL;
    }

    // 删除信号量的名称，使其在进程结束时自动删除
    sem_unlink(sp->name);

    return sp;
}

// 释放一个 slock 结构体
void s_free(struct slock *sp)
{
    sem_close(sp->semp);
    free(sp);
}

// 对一个 slock 结构体进行加锁
int s_lock(struct slock *sp)
{
    return (sem_wait(sp->semp));
}

// 尝试对一个 slock 结构体进行加锁
int s_trylock(struct slock *sp)
{
    return (sem_trywait(sp->semp));
}

// 对一个 slock 结构体进行解锁
int s_unlock(struct slock *sp)
{
    return (sem_post(sp->semp));
}
```

## 套接字

关闭一个套接字，可以使用 `close` 和 `shutdown` 函数。都是关闭套接字，那么这两个方法有什么异同呢？

首先，只有最后一个活动引用关闭时，`close` 才会释放网络端点。而 `shutdown` 允许一个套接字处于不活动状态，和引用它的文件描述符数量无关。其次，`shutdown` 支持单向关闭，比如如果想让通信的进程确定数据传输何时结束，那么可以关闭写端，然后通过该套接字读端继续接收数据。

另外，`shutdown` 函数还可以用于优雅地关闭连接。当一个套接字的一端需要关闭连接时，可以先调用 `shutdown` 函数关闭该端的写端，然后等待对端关闭连接，最后再调用 `close` 函数关闭套接字。这样可以避免数据丢失或者其他错误，同时也可以让对端知道该端已经关闭连接。

### 字节序列表示法：大端/小端表示法

处理器架构支持**大端字节序（big-endian）**和**小端字节序（little-endian）**。

大端字节序：最大字节地址出现在**最低有效字节（Least Significant Byte, LSB）**上。

小段字节序：最大字节地址出现在**最大有效字节（Most Significant Byte, MSB）**上。

![](asserts/16-5.jpg)

> 注意
>
> 不管字节是如何排序的，**最大有效字节总是在左边。最低有效字节总是在右边**。
>
> 在大端模式下，高位字节存储在低地址，低位字节存储在高地址。例如，一个 4 字节的整数 0x12345678 在内存中的存储顺序为 12 34 56 78。
>
> 在小端模式下，高位字节存储在高地址，低位字节存储在低地址。例如，一个 4 字节的整数 0x12345678 在内存中的存储顺序为 78 56 34 12。
>
> 例如，对于一个 4 字节的整数 0x12345678，在大端模式下，它的高位字节是 0x12，低位字节是 0x78。假设这个整数的地址为 0x1000，那么它的存储顺序为：
>
> | 地址   | 内容 |
> | ------ | ---- |
> | 0x1000 | 0x12 |
> | 0x1001 | 0x34 |
> | 0x1002 | 0x56 |
> | 0x1003 | 0x78 |

大端和小端字节序列是由不同的 CPU 架构决定的，不同的架构采用不同的字节序列。这是因为在多字节数据存储时，字节的存储顺序不同，会影响数据的解析和处理。

大端字节序列适合于网络传输和通信协议中，因为网络传输和通信协议需要保证数据的一致性和可靠性。大端字节序列采用高位字节在前的方式存储数据，可以保证不同的 CPU 架构在传输和解析数据时能够正确地识别和处理数据，从而保证数据的一致性和可靠性。

小端字节序列适合于处理器内部和存储器中的数据存储，因为处理器内部和存储器中的数据存储都采用小端字节序列。小端字节序列采用低位字节在前的方式存储数据，可以提高处理器内部和存储器中数据的读写效率，从而提高系统的性能。

因此，在编写跨平台的程序时，需要注意字节序的问题，并使用适当的函数进行字节序转换。在网络传输和通信协议中，应该使用大端字节序列；在处理器内部和存储器中的数据存储中，应该使用小端字节序列。

### 建立 socket 连接

使用 `connect` 函数来建立 socket 连接：

```c
int connect(int sockfd, const struct sockaddr *addr, socklen_t len);
```

`addr` 参数表示想与之建立通信的服务器地址。如果 `sockfd` 没有绑定到下一个地址，connect 会给调用者绑定一个默认地址。

要想一个连接请求成功，要连接的计算机必须是开启的，并且正在运行，服务器必须绑定到一个想与之连接的地址上，并且**服务器的等待连接队列要有足够的空间**。因此，应用程序必须能够处理 `connect` 返回的错误，这些错误可能是由一些瞬时条件引起的。

```c
#define MAXSLEEP 128

int connect_retry(int domain, int type, int protocol, const struct sockaddr *addr, socklen_t alen)
{
    int numsec, fd;

    // Try to connect with exponential backoff. 指数退避算法
    for (numsec = 1; numsec <= MAXSLEEP; numsec <<= 1)
    {
        if ((fd = socket(domain, type, protocol)) < 0)
            return (-1);
        if (connect(fd, addr, alen) == 0)
        {
            // Connection accepted.
            return (fd);
        }
        close(fd);

        // Delay before trying again.
        if (numsec <= MAXSLEEP / 2)
            sleep(numsec);
    }
    return (-1);
}
```

### listen 接受连接请求

在连接 socket 连接之后，可以调用 `listen` 函数明确接受来自客户端的连接请求：

```c
int listen(int sockfd, int backlog);
```

参数 `backlog` 提供了一个提示，提示系统该进程所要入队的**未完成连接请求数量**。其实际值由系统决定，但上限由`<sys/socket.h>` 中的 `SOMAXCONN` 指定。**一旦队列满了就会拒绝多余的连接请求。**

### accept

一旦服务器调用了 `listen`，所用的套接字就能接收到连接请求。使用 `accept` 函数获得连接请求并建立连接：

```c
int accept(int sockfd, struct sockaddr *restrict addr, socklen_t *restrict len);
```

`sockfd` 参数是一个已经标记为被动套接字的套接字描述符，`addr` 参数是一个指向 `sockaddr` 结构体的指针，用于存储客户端的地址信息，`addrlen` 参数是一个指向 `socklen_t` 类型的指针，用于存储 `addr` 结构体的长度。如果 `accept` 函数执行成功，它将返回一个新的套接字描述符，该套接字用于与客户端进行通信，否则返回一个非零错误码。在调用 `accept` 函数之前，应该先调用 `bind` 函数将套接字绑定到本地地址，并调用 `listen` 函数将套接字标记为被动套接字。在调用 `accept` 函数之后，应该使用返回的新套接字描述符来与客户端进行通信，同时应该关闭原始套接字描述符，以便释放系统资源。

如果没有连接请求在等待，`accept` 会阻塞直到一个请求进来。如果 `sockfd` 处于非阻塞模式， `accept` 会返回 −1，并将 errno 设置为 EAGAIN 或 EWOULDBLOCK。

如果服务器调用 `accept`，并且当前没有连接请求，服务器会阻塞直到一个请求到来。另外，服务器可以使用 poll 或 select 来等待一个请求的到来。在这种情况下，一个带有等待连接请求的套接字会以可读的方式出现。

### 数据传输

1. `read` 和 `write` 函数：用于在套接字上进行数据传输，类似于文件I/O操作。这两个函数是阻塞的，即如果没有数据可读或写，则会一直等待，直到有数据可读或写。如果需要进行非阻塞的数据传输，可以使用 `select` 或 `poll` 函数来实现。
2. `send` 和 `recv` 函数：用于在套接字上进行数据传输，与 `read` 和 `write` 函数类似，但是具有更多的选项和控制能力。这两个函数可以指定传输的数据类型、传输的标志、传输的超时时间等参数，同时也可以通过设置**套接字选项**来控制数据传输的行为。
3. `sendto` 和 `recvfrom` 函数：用于在**无连接套接字**上进行数据传输，与 `send` 和 `recv` 函数类似，但是需要指定目标地址和端口号。这两个函数通常用于实现基于数据报的协议，如UDP协议。
4. `readv` 和 `writev` 函数：用于在套接字上进行多段数据的传输，可以将**多个缓冲区的数据一次性传输到套接字中**，或者将**套接字中的数据一次性读取到多个缓冲区**中。这两个函数可以提高数据传输的效率，减少系统调用的次数。
5. `sendmsg` 和 `recvmsg` 函数：用于在**套接字上进行多段数据的传输**，或者为了将**接收到的数据读取到多个缓冲区**。与 `readv` 和 `writev` 函数类似，但是具有更多的选项和控制能力。这两个函数可以指定传输的数据类型、传输的标志、传输的超时时间等参数，同时也可以通过设置套接字选项来控制数据传输的行为。

> 无连接的套接字是基于数据报的通信方式（UDP），每个数据包都是独立的，没有与其他数据包相关的状态信息。因此，当数据包到达时，内核无法确定它们的顺序，因为它们可能通过不同的路径到达目的地，也可能在传输过程中被重新排序。这就是为什么无连接的套接字的数据包是无序的。
>
> 如果应用程序需要处理有序的数据流，那么就需要使用面向连接的套接字，以确保数据包按照正确的顺序传输。如果想和对等方可靠通信，就必须对**数据包编号**，并且在发现数据包丢失时，请求对等应用程序**重传**（TCP）。
>