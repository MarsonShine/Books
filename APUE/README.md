# Unix 环境高级编程(APUE)

## 概念

**文件描述符**：非负整数，操作系统内核用以标识一个特定进程正在访问的的文件。在读写文件时，可以使用这个文件描述符。

**不带缓冲的I/O**: 函数 open、read、write、lseek 以及 close 属于不带缓冲的 I/O

**标准I/O**：标准函数提供了带缓冲的接口。性能更好，是最佳选择。

**程序**：是一个存储在磁盘上某个目录的可执行文件。**内核使用 `exec` 函数将程序读入内存并执行**。

**进程和进程ID**：程序的执行者就是进程，系统在开启一个进程时都会分配一个唯一的数字标识符，即称为进程ID。

**进程控制**：通过系统提供的三个函数控制进程；`fork`、`exec`、`waitpid`

**线程和线程ID**：通常一个进程只有一个控制线程——**某一时刻执行的一组机器指令**。一个进程内的所有线程都共享同一个地址空间、文件描述符、栈以及进程相关的属性。

**用户ID**：一个非负整数的数字，标识一个用户。ID 为 0 表示用户为根用户（root）。

**组ID**：标识用户的组，被用于将若干用户集合到项目和部门中去。这种机制允许同组的各个成员之间共享资源（文件）。

**信号**：用于通知系统发生了某种情况。如中断处理信号，用 signal 函数捕获信号

**时间**

- **时钟时间**：也叫墙上时间（wall clock time）；它标识进程运行的时间总量。
- 用户 CPU 时间：表示执行用户指令所用的时间。
- 系统 CPU 时间：表示该进程执行内核程序所经历的时间。

**系统调用**：进入操作系统内核的入口函数

## 文件I/O

### 文件描述符

在 Unix 系统中，文件描述符约定成俗：

- 文件描述符0：表示进程的标准输入
- 文件描述符1：表示标准输入
- 文件描述符2：表示标准错误

### 文件共享

UNIX 系统支持不同的进程共享打开文件。

UNIX 内核使用三种数据结构表示打开的文件信息：

- 每个进程在进程表中都有一个记录项，记录项中包含一张打开**文件描述符表**，可将其视为一个矢量，每个描述符占用一项。与每个文件描述符相关联的是：
  - 文件描述符标志（close_on_exec）
  - **指向文件表项的指针**
- 内核为所有打开文件维持一个**文件表**。每个文件表项包含：
  - 文件状态标识（读、写、追加、同步和非阻塞）
  - 当前文件偏移量
  - **指向该文件 v 节点表项的指针**
- 每个打开文件（或设备）都有一个 v 节点（v-node）结构。v 节点包含了文件类型和对此文件进行各种操作函数的指针。这些信息都是在打开文件时从磁盘上读入内存的，所以文件相关的信息都是随时可用的

关系图如下

![](./asserts/file-share-structure.jpg)

不同的进程打开同一个文件的结构图如下

![](./asserts/multi-process-open-one-file.jpg)

每个进程打开文件时都有自己的文件描述符表（即图中的进程表项）和文件表项，单只有一个 v-node 表项。这是因为对于文件表项，每个进程都要有它自己对该文件的偏移量。

> 关于文件共享，在《深入理解计算机系统》也有深入讲到
>
> 具体详见：https://github.com/MarsonShine/Books/blob/8002f0865f6f93c29677971d579a87e62dfeca29/CSAPP/docs/io.md#%E7%B3%BB%E7%BB%9F%E7%BA%A7-io

> 多个进程对同一个文件并发写入怎么办？
>
> 一般情况下，进程A 访问文件 F 时，写入内容并将偏移量（调用 `lseek` 方法）移到了 1500 处，这是发生内核切换；进程 B 访问文件 F，并将 F 文件的当前偏移量从 1500 移到了 1600。因为内容已经写入，所以内核将 v-node 表项中的文件长度更新为 1600。然后内核又进行切换回到了进程 A，当 A 调用 `write` 时，就从其当前文件偏移量（1500）处开始将数据写入到文件。这样就覆盖了进程 B 刚写入的内容了。
>
> 所以要解决这种并发问题，我们要将 “定位文件当前位置，写” 这两个动作（函数）合并为一个函数，这样就成为了一个“**原子操作**”。也就是说当内核发生切换时，在写操作之前，都将进程的当前偏移量设置到该文件的结尾处。函数 `pread`,`pwrite `就是这个作用。

#### 如何共享同一个文件表项？

![](./asserts/share-filetable-entry.jpg)

通过调用函数 `dup`、`dup2` 就可以复制一个已有的文件描述符。这些函数会返回新描述符与参数 fd **共享同一个文件表项**。

### 高速缓存一致性

UNIX 系统实现在内核中设有**缓冲区高速缓存**或**页高速缓存**，大多数磁盘 I/O 都通过缓冲区进行。当向文件写入文件时，**先将数据复制到缓冲区中，然后排入队列，稍后会写入磁盘**。这个过程称之为“**延迟写（delayed write）**”

有缓存就会带来数据一致性的问题，当内核需要重用缓冲区来存放其它磁盘的数据时，它会把所有延迟写数据块写入磁盘。为了保证磁盘上实际文件内容与缓冲区上的内容保持一致，UNIX 提供了 `sync、fsync` 和 `fdatasync` 三个函数同步数据。

## 文件和目录

文件类型分类如下：

1. 普通文件（regular file）。最常用的文件类型，这种文件包含了某种形式的数据（二进制还是文本格式）
2. 目录文件（directory file）。**这种文件包含了其它文件的名字以及指向这些文件有关信息的指针**。对一个目录文件具有读权限的任一进程都可以读该目录的内容，但只有内核可以直接写目录文件。
3. 块特殊文件（block special file）。这种类型的文件提供对设备（如磁盘）带缓冲的访问，每次访问以固定长度为单位进行。
4. 字符特殊文件（character special file）。该文件提供不带缓冲的访问，每次访问长度可变。系统中所有设备要么是字符特殊文件，要么是块特殊文件。
5. FIFO。该文件用于进程间通信，也成为命名管道（named pipe）
6. 套接字（socket）。这种文件类型用于进程间的网络通信。
7. 符号链接（symbolic link）。这种类型文件指向另一个文件。

### 文件访问权限

与进程相关的 ID 有 6 个或更多

- 实际用户ID
- 实际组ID

表示进程的所属

- 有效用户ID
- 有效组ID

用户文件访问权限检查

- 保存的设置用户ID
- 保存的设置组ID

由 exec 函数保存

------

`stat.st_mode` 表示对文件的访问权限。每个文件包含 9 个访问权限位，被分为 3 大类：

1. 用户权限
   1. S_IRUSR：用户读
   2. S_IWUSR：用户写
   3. S_IXUSR：用户执行
2. 组权限
   1. S_IRGRP：组读
   2. S_IWGRP：组写
   3. S_IXGRP：组执行
3. 其它权限
   1. S_IROTH：其它读
   2. S_IWOTH：其它写
   3. S_IXOTH：其它执行

如果进程拥有此文件（进程的有效用户 ID 等于文件的所有者 ID），则按用户访问权限批准或拒绝对该文件的访问。如果进程并不拥有该文件，但进程属于某个组，则按组访问权限进行授权和拒绝对该文件的访问。

#### 函数 access & faccessat

函数 `access` 和 `faccessat` 是按实际用户 ID 和实际组 ID 进行访问权限测试的。

## 文件系统

Unix 把磁盘分成一个或多个分区。每个分区都可以包含一个文件系统。i-node 是固定长度的记录项，包含了文件的大部分信息。

![](./asserts/disk-patition-filesystem.png)

其中 i 节点和数据块结构如下图：

![](./asserts/inode-datablock-filesystem.jpg)

上图显示有多个目录块同时指向一个 i 节点。每个 i 节点都有一个链接计数器，表示的就是指向该节点的目录块数。**只有当 i 节点的链接计数器显示为 0 时才能删除该文件。**这也就解释了为什么“解除对一个文件的链接”操作并不意味着“释放该文件所占用的磁盘块”。因此删除目录项的函数被称为 `unlink`。

> 还有一种链接是符号链接(symbolic link)。符号链接文件的实际内容（在数据块中）包含了该符号链接所指向的文件名字。

i 节点包含了文件有关的所有信息：**文件类型**、**文件访问**、**文件访问权限**、**文件长度**和**指向文件数据块的指针**等。`stat` 结构中的大多数信息都取自 i 节点。只有两项重要数据放在目录项中：文件名和 i 节点编号。

当在不更换文件系统的情况下为一个文件重命名，该文件的实际内容并为移动，只需要构造一个指向现有 i 节点的新目录块，并删除老的目录块。这样 i 节点的链接计数不用改变。

> 内核是如何删除文件的？
>
> **只有当链接计数为 0 时，该文件的内容才可以删除**。另一个条件也会阻止删除文件的内容：只要有进程打开了这个文件，其内容也不能删除。关闭一个文件时，内核首先检查打开该文件的进程个数；如果进程个数为 0，内核再去检查其链接个数；如果链接计数也为 0，那么就可以删除该文件的内容。

## 符号链接

符号链接是对一个文件的间接指针，它与硬链接有所不同，硬链接直接指向文件的 i 节点。引入符号链接的原因是为了避开硬链接的一些限制：

- 硬链接要求链接和文件位于同一个文件系统。
- 只有超级用户才能创建指向目录的硬链接（在底层文件系统支持的情况下）

对符号链接以及指向它向何种对象并无任何文件系统限制，任何用户都能创建指向目录的符号链接。

```sh
mkdir foo					# 创建一个新目录
touch foo/a					# 创建一个 0 长度的文件
ln -s ../foo foo/testdir	# 创建一个符号链接
ls -l foo
```

我们可以凭空创建一个符号链接，通过 `ls` 就能查看到具体的文件信息：

```sh
ln -s /no/such/file myfile	# 创建一个符号链接
ls myfile	# 查看一个本不存在的文件
cat myfile	# 查看文件内容
ls -l myfile	# 查看文件属性
```

ls 提示文件 myfile 存在，但是 cat 文件时却会报没有文件的错误。其原因就是因为 myfile 符号链接导致的。

## 标准I/O库

### 临时文件

使用 `tmpnam` 和 `tempnam` 都存在一个问题：在返回唯一的路径名和用该名字创建文件之间存在一个窗口期，在这个时间窗口内，可能会存在另一个进程用相同的文件名创建文件。这个时候就应该使用 `tmpfile` 和 `mkstemp` 函数创建文件就可以避免这个问题。

## 时间和日期

unix 系统内核提供的时间服务是计算自协调世界时(Coordinated Universal Time, UTC)公元 1970 年 1 月 1 日 00:00:00 这一特定时间以来经过的秒数。

## main 函数执行

c 程序总是从 main 函数执行的。

```c
int main(int argc, char *argv[]);
```

其中 argc 是命令行参数的数目，argv 是指向参数的各个指针所构成的数组。

当内核执行 c 程序时（使用的是 exec 函数），在调用 main 之前会先调用一个特殊的**启动例程**。**可执行程序文件将此启动例程指定为程序执行的起始地址**——这是由连接编辑器设置的，而连接编辑器则由 c 编译器调用。启动例程从内核取得命令行参数和环境变量值，然后为调用 main 函数做好准备。

### 进程终止

进程终止包含三个方面：

1. 正常终止：1）从 main 返回。2）调用退出函数；如（`exit`,`_exit`,`_Exit`）
2. 多线程：1）最后一个线程从启动例程返回。2）从最后一个线程调用 `pthread_exit`
3. 错误异常：1）调用 `abord`。2）接到一个信号。3）最后一个线程对取消请求做出响应

当执行一个程序时，调用 `exec` 的进程可以将命令行参数传递给新的程序。

> 当进程调用 `exec` 函数时，该进程被完全替换为新程序。
>
> 注意，调用 exec 函数并不创建新进程，所以前后进程的 ID 并没有改变。

### 环境表

每个程序都会接受一个**环境表**。与参数表一样，环境表也是一个**字符指针组**，其中每个指针包含一个以 null 结束的 C 字符串的地址。全局变量 `environ` 包含了该指针数组的地址：`extern char **environ`

![](./asserts/environ-table.jpg)

## C 程序的存储空间

C 程序一直是由以下几个部分组成：

- **正文段**。这是由 CPU 执行的机器指令部分。通常，正文段是可共享的，所以即使是频繁执行的程序在存储器中也只需要有一个副本，**并且正文段是只读的，目的是为了防止篡改**。

- **初始化数据段**。它包含了程序中明确地赋初值的变量。

- **未初始化数据段**。即 bss 段，这一名称来源于早期汇编程序一个操作符，意思是“由符号开始的块”（block started by symbol），在程序开始执行之前，内核将此段中的数据初始化为 0 或空指针。如函数外的申明：`long sum[1000]`，这种变量就存储在非初始化数据段中。

- **栈。自动变量以及每次函数调用时所需保存的信息都保存在此段中。每次函数调用时，其返回地址以及调用者的环境信息（如某些机器寄存器的值）都存放在此段中**。

  在函数调用时会在栈上自动分配临时变量。比如在调用递归函数时，每次调用自身时都会开辟新的栈帧，因此一次函数调用中的变量集不会影响另一次函数调用所用的变量集。

- **堆。**一般进行动态存储分配。

其经典的结构图如下：

![](./asserts/7-6.jpg)

## 存储空间分配

unix 系统中有三个函数用于**存储空间动态分配**。

1. `malloc`，分配指定字节数的存储区。此存储区中的初始值不确定。
2. `calloc`，为指定数量指定长度的对象分配存储空间。该空间中的每一位（bit）都初始化为 0。
3. `realloc`，增加或减少以前分配区的长度。当增加长度时，可能需要将以前分配区的内容复制到另一个足够大的分配区（扩容操作）。

函数 `free` 释放指针指向的存储空间。被释放的空间会被送入可用至**存储区池**，以方便后续在某个时候调用上述三个方法进行再分配。

## 资源限制函数

每个进程都有一组资源限制，分为软硬两种类型：

- 软限制
- 硬选址

```
struct rlimit {
	rlim_t rlim_cur;	// 软限制
	rlim_t rlim_max;	// 硬限制
}
```

在更改资源限制时，必须要求满足下面要求：

1. 任何一个进程都可以将一个软限制值更改为小于或等于硬限制值。
2. 任何一个进程都可以降低硬限制值，但它必须大于或等于软限制值。
3. 只有超级用户才可以提高硬限制值。

| 限制              | 描述                                                         |
| ----------------- | ------------------------------------------------------------ |
| RLIMIT_AS         | 进程总的可用存储空间的最大长度。（`sbrk`,`mmap`）            |
| RLIMIT_CORE       | core文件的最大字节数，如果值为0，则阻止创建文件              |
| RLIMIT_CPU        | CPU时间的最大量值（秒），当超过软限制值时，向进程发送`SIGXCPU`信号 |
| RLIMIT_DATA       | 数据段的最大字节长度（初始化数据+非初始化+堆）。             |
| RLIMIT_FSIZE      | 可以创建的文件的最大字节长度。当超过此软件时，则向该进程发送`SIGXCPU`信号。 |
| RLIMIT_MEMLOCK    | 一个进程使用`mlock(2)`能够锁定在存储空间中的最大字节长度。   |
| RLIMIT_MSGQUEUE   | 进程为POSIX消息队列可分配的最大存储字节数。                  |
| RLIMIT_NICE       | 为了影响进程的调度优先级，nice可设置为最大值。               |
| RLIMIT_NOFILE     | 每个进程能打开的最大文件数。更改此限制将影响到`sysconf`函数在参数`_SC_OPEN_MAX`返回的值 |
| RLIMIT_NPROC      | 每个实际用户ID可拥有的最大子进程数                           |
| RLIMIT_NPTS       | 用户可同时打开的伪终端的最大数量。                           |
| RLIMIT_RSS        | 最大驻内存集字节长度（resident set size in bytes）。如果可用物理存储器很少，则内核将从进程处取回超过RSS的部分 |
| RLIMIT_SBSIZE     | 在任意给定时刻，一个用户可以占用的套接字缓存区的最大长度（字节） |
| RLIMIT_SIGPENDING | 一个进程可排队的信号最大数量。这个限制时 sigqueue 函数实施的。 |
| RLIMIT_STACK      | 栈的最大字节长度。                                           |
| RLIMIT_SWAP       | 用户可消耗的交换空间的最大字节数。                           |
| RLIMIT_VMEM       | 进程总的可用存储空间的最大长度。（`sbrk`,`mmap`）            |

### 为什么不能将一个指针返回给一个自动变量？

**因为当函数返回时，原本该函数所用的存储空间将由下一个调用的函数的栈帧所使用。所以如果还存在其它部分引用这部分的地址，这就会产生冲突和混乱。所以这个时候应该使用全局存储空间为这些变量分配空间。**

## 进程部分

系统中有一些专用进程。

进程 ID 为 0 的进程通常是**调度进程**，通常也被称为交换进程（swapper）。**该进程是内核的一部分**，它不执行任何磁盘上的程序，因此也被称为系统进程。

进程 ID 为 1 的进程通常是 `init` 进程，在自举过程结束时由内核调用。init 进程通常读取与系统相关的初始化文件（`/etc/rc*`，`/etc/inittab`，`/etc/init.d`等文件）,并将系统引导到一个状态。init 进程不会终止。注意，init 进程是用户进程而非内核进程。

还有如进程 ID 为 2 的页守护进程（paged daemon），负责支持虚拟存储器系统的分页操作。

### fork

一个进程调用 `fork` 函数会创建一个新的进程。

fork 函数被调用一次，会返回两次。两次返回的区别是：**子进程返回的是 0，而父进程返回值则是新建子进程的进程 ID。**

子进程和父进程都继续执行 fork 调用之后的指令。子进程是父进程的副本。例如，子进程获得父进程的数据空间、堆、栈的副本。

> 注意：是子进程所拥有父进程的副本，不是共享相同的存储空间。

**当子进程要修改某些数据时，就会触发写时复制（COW），内核为该修改的区域生成一个副本（通常是虚拟存储系统的一“页”）供子进程修改。**也即就是说，在子进程对变量做出的修改是不会影响到父进程中该变量中的值。

#### fork 下的文件共享

fork 还有一个特性是：父进程打开的所有文件描述符都会被复制到子进程中，共享同一个文件的偏移量。那么当父子进程同时对该文件进行写操作该如何呢？

如果父进程的标准输出已重定向，那么子进程写到该标准输出时，它将更新与父进程共享的该文件的偏移量。假设当父进程等待子进程时，子进程写到标准输出，而在子进程终止后，父进程也会写到标准输出上，并且知道其输出会追加在子进程所写的数据之后。

> 当两个进程对同一个文件进行写操作，会发生内容覆盖。如果要拒绝这种情况发生，应该使用文件锁定机制。

![](./asserts/8-2.jpg)

如果父进程和子进程各自执行不同的程序段，那么在这种情况下，父进程和 fork 子进程会各自关闭它们不需使用的文件描述符，这样就不会干扰对方使用文件描述符了。

fork 一般有两种用法：

1. 一个父进程希望复制自己，使父进程和子进程同时执行不同的代码段。这在网络服务进程中非常常见，父进程等待客户端的服务请求。当请求到达时，父进程调用 `fork`，使子进程处理此请求。父进程则继续等待下一个服务请求。
2. 一个进程要执行不同的程序。这是对 `shell` 是常见的情况。在这种情况下，子进程从 `fork` 返回后立即调用 `exec`。

> 还有一个函数与 `fork` 相似 —— `vfork`。
>
> vfork 创建一个新进程，但是它是用于执行 `exec` 一个新程序。但是它并不将父进程的地址空间完全复制到子进程中，所以不能用它来修改数据等。
>
> 值得注意的是，**vfork 保证了子进程先运行**，在它调用了 `exec` 或 `exit` 之后父进程才有可能被调度执行。