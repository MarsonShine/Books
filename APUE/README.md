# Unix 环境高级编程(APUE)

## 概念

**文件描述符**：非负整数，操作系统内核用以标识一个特定进程正在访问的的文件。在读写文件时，可以使用这个文件描述符。

**不带缓冲的I/O**: 函数 open、read、write、lseek 以及 close 属于不带缓冲的 I/O

**标准I/O**：标准函数提供了带缓冲的接口。性能更好，是最佳选择。

**程序**：是一个存储在磁盘上某个目录的可执行文件。**内核使用 `exec` 函数将程序读入内存并执行**。

**进程和进程ID**：程序的执行者就是进程，系统在开启一个进程时都会分配一个唯一的数字标识符，即称为进程ID。

**进程控制**：通过系统提供的三个函数控制进程；`fork`、`exec`、`waitpid`

**线程和线程ID**：通常一个进程只有一个控制线程——**某一时刻执行的一组机器指令**。一个进程内的所有线程都共享同一个地址空间、文件描述符、栈以及进程相关的属性。

**用户ID**：一个非负整数的数字，标识一个用户。ID 为 0 表示用户为根用户（root）。

**组ID**：标识用户的组，被用于将若干用户集合到项目和部门中去。这种机制允许同组的各个成员之间共享资源（文件）。

**信号**：用于通知系统发生了某种情况。如中断处理信号，用 signal 函数捕获信号

**时间**

- **时钟时间**：也叫墙上时间（wall clock time）；它标识进程运行的时间总量。
- 用户 CPU 时间：表示执行用户指令所用的时间。
- 系统 CPU 时间：表示该进程执行内核程序所经历的时间。

**系统调用**：进入操作系统内核的入口函数

## 文件I/O

### 文件描述符

在 Unix 系统中，文件描述符约定成俗：

- 文件描述符0：表示进程的标准输入
- 文件描述符1：表示标准输入
- 文件描述符2：表示标准错误

### 文件共享

UNIX 系统支持不同的进程共享打开文件。

UNIX 内核使用三种数据结构表示打开的文件信息：

- 每个进程在进程表中都有一个记录项，记录项中包含一张打开**文件描述符表**，可将其视为一个矢量，每个描述符占用一项。与每个文件描述符相关联的是：
  - 文件描述符标志（close_on_exec）
  - **指向文件表项的指针**
- 内核为所有打开文件维持一个**文件表**。每个文件表项包含：
  - 文件状态标识（读、写、追加、同步和非阻塞）
  - 当前文件偏移量
  - **指向该文件 v 节点表项的指针**
- 每个打开文件（或设备）都有一个 v 节点（v-node）结构。v 节点包含了文件类型和对此文件进行各种操作函数的指针。这些信息都是在打开文件时从磁盘上读入内存的，所以文件相关的信息都是随时可用的

关系图如下

![](./asserts/file-share-structure.jpg)

不同的进程打开同一个文件的结构图如下

![](./asserts/multi-process-open-one-file.jpg)

每个进程打开文件时都有自己的文件描述符表（即图中的进程表项）和文件表项，单只有一个 v-node 表项。这是因为对于文件表项，每个进程都要有它自己对该文件的偏移量。

> 关于文件共享，在《深入理解计算机系统》也有深入讲到
>
> 具体详见：https://github.com/MarsonShine/Books/blob/8002f0865f6f93c29677971d579a87e62dfeca29/CSAPP/docs/io.md#%E7%B3%BB%E7%BB%9F%E7%BA%A7-io

> 多个进程对同一个文件并发写入怎么办？
>
> 一般情况下，进程A 访问文件 F 时，写入内容并将偏移量（调用 `lseek` 方法）移到了 1500 处，这是发生内核切换；进程 B 访问文件 F，并将 F 文件的当前偏移量从 1500 移到了 1600。因为内容已经写入，所以内核将 v-node 表项中的文件长度更新为 1600。然后内核又进行切换回到了进程 A，当 A 调用 `write` 时，就从其当前文件偏移量（1500）处开始将数据写入到文件。这样就覆盖了进程 B 刚写入的内容了。
>
> 所以要解决这种并发问题，我们要将 “定位文件当前位置，写” 这两个动作（函数）合并为一个函数，这样就成为了一个“**原子操作**”。也就是说当内核发生切换时，在写操作之前，都将进程的当前偏移量设置到该文件的结尾处。函数 `pread`,`pwrite `就是这个作用。

#### 如何共享同一个文件表项？

![](./asserts/share-filetable-entry.jpg)

通过调用函数 `dup`、`dup2` 就可以复制一个已有的文件描述符。这些函数会返回新描述符与参数 fd **共享同一个文件表项**。

### 高速缓存一致性

UNIX 系统实现在内核中设有**缓冲区高速缓存**或**页高速缓存**，大多数磁盘 I/O 都通过缓冲区进行。当向文件写入文件时，**先将数据复制到缓冲区中，然后排入队列，稍后会写入磁盘**。这个过程称之为“**延迟写（delayed write）**”

有缓存就会带来数据一致性的问题，当内核需要重用缓冲区来存放其它磁盘的数据时，它会把所有延迟写数据块写入磁盘。为了保证磁盘上实际文件内容与缓冲区上的内容保持一致，UNIX 提供了 `sync、fsync` 和 `fdatasync` 三个函数同步数据。

## 文件和目录

文件类型分类如下：

1. 普通文件（regular file）。最常用的文件类型，这种文件包含了某种形式的数据（二进制还是文本格式）
2. 目录文件（directory file）。**这种文件包含了其它文件的名字以及指向这些文件有关信息的指针**。对一个目录文件具有读权限的任一进程都可以读该目录的内容，但只有内核可以直接写目录文件。
3. 块特殊文件（block special file）。这种类型的文件提供对设备（如磁盘）带缓冲的访问，每次访问以固定长度为单位进行。
4. 字符特殊文件（character special file）。该文件提供不带缓冲的访问，每次访问长度可变。系统中所有设备要么是字符特殊文件，要么是块特殊文件。
5. FIFO。该文件用于进程间通信，也成为命名管道（named pipe）
6. 套接字（socket）。这种文件类型用于进程间的网络通信。
7. 符号链接（symbolic link）。这种类型文件指向另一个文件。

### 文件访问权限

与进程相关的 ID 有 6 个或更多

- 实际用户ID
- 实际组ID

表示进程的所属

- 有效用户ID
- 有效组ID

用户文件访问权限检查

- 保存的设置用户ID
- 保存的设置组ID

由 exec 函数保存

------

`stat.st_mode` 表示对文件的访问权限。每个文件包含 9 个访问权限位，被分为 3 大类：

1. 用户权限
   1. S_IRUSR：用户读
   2. S_IWUSR：用户写
   3. S_IXUSR：用户执行
2. 组权限
   1. S_IRGRP：组读
   2. S_IWGRP：组写
   3. S_IXGRP：组执行
3. 其它权限
   1. S_IROTH：其它读
   2. S_IWOTH：其它写
   3. S_IXOTH：其它执行

如果进程拥有此文件（进程的有效用户 ID 等于文件的所有者 ID），则按用户访问权限批准或拒绝对该文件的访问。如果进程并不拥有该文件，但进程属于某个组，则按组访问权限进行授权和拒绝对该文件的访问。

#### 函数 access & faccessat

函数 `access` 和 `faccessat` 是按实际用户 ID 和实际组 ID 进行访问权限测试的。