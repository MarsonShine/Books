关于 C#5.0 async 特性有两点要考虑，特别是 await 关键字，它发生了什么？

- 作为语言特征，它的行为是可以学习。
- 在编译转换期间，这是不使用异步的更复杂的 C# 片段的语法糖

这两点都是正确的；它们是硬币的正反两面。在这节，我们集中讨论第一种 async 方式。在 14 章会讨论另一方面，在更复杂的情况下，它会让调试和性能更加清晰。

# 休眠（Hibernating）和恢复（Rsuming）方法

当你的程序运行到 await 关键字的时候，我们知道两件事会发生：

- 当前线程运行到你的代码会释放使你的代码是异步的。就是说从正常，同步的角度来看，你的方法应该返回。
- 当等待的 Task 完成时，你的方法会继续你使用它（异步 await）的地方，在等待结束之前它是不会提前返回的。

为了完成这些行为，你的方法在到达 await 时候必须暂停，并在稍后的某个时刻恢复。

我认为这个过程是计算机休眠的小规模版本。方法的当前状态存储下来，方法完成并退出。当计算机休眠，动态，正在运行的状态存储到磁盘中并且完全关闭。就像你能拔掉电源电脑休眠没有任何影响一样，一个正在等待的方法使用了比其他都小的内存，执行的线程已经被释放。

> 合在一起分析，方法阻塞很象计算机挂起。它尽管使用很少的资源，但是她还是一直在运行的。

理想情况下，程序不应该能察觉到发生过休眠。尽管事实上在执行过程中休眠和恢复方法是一个相当复杂的操作，C# 会确保你的代码被恢复，就好像什么事没有发生一样。

# 方法状态

当你使用 **await** 时，你要尽可能的弄清楚 C# 在背后做了什么工作，关于你的方法的状态要考虑所有的细节。

首先，方法中所有的局部变量都会被存储，这些值包括：

- 方法参数
- 在你当前域的所有变量
- 所有其他变量，比如循环计数器
- 还有 **this**，如果你的方法是非静态的，并且当你方法恢复时，那么你的 class 类的变量就会被记住。

所有的这些都会以一个对象存储到 .NET GC 堆中。当你 **await**，这个对象就被分配这些资源，在大多时候这是不会引起性能问题的。

C# 也能记住在方法到达 **await** 的位置。在当前方法中可以用数字来表示 **await** 关键字存储。

对于 **await** 表达式的使用是没有限制的。例如，它能作为一个大的表达式的一部分，也许还涉及到不止一个 **await**：

```c#
int myNum = await AlexsMethodAsync(await myTask, await StuffAsync());
```

这就是增加了额外的要求去记住表达式其余的状态当你正在 awaiting 的时候。比如在这个例子中， 当我们运行 `await StuffAsync()` 的时候，需要记住 await myTask 的结果。.NET IL 会存储这种子表达式在栈上， **await** 关键字需要存储的就是栈。

除此之外（On top of this），当程序在方法中运行到第一个 **await **时，方法就会返回。除非这个方法是 **async void** 的，否则在那个时候 Task 返回，调用者能以某种方式等待我们完成。C# 必须还要存储一种方法来维护返回的方法，当我们的方法完成之后，Task 会变成完成状态，并且执行向上移动到异步方法链。至于额外维护的原理是怎么样讲第14章。

# 上下文（Context）

作为努力的一部分的让程序在等待的时候变得尽可能透明，C# 在 **await** 捕捉了各种上下文，当方法恢复的时候上下文会被存储起来。

其中最重要的就是异步上下文（synchronization context），它可以用来在指定线程恢复方法。这对UI 应用程序尤其重要，只有它能在正确的线程来维护他们的 UI 。Synchronization context 是一个复杂的主体，第 8 章讨论了更多的细节。

调用方法的线程也能捕捉其他的上下文。控制管理这就跟 class 类有相同的名字一样，所以我会列出在类中重要上下文的类型：

**ExecutionContext**

​	这是父上下文，其他所有的上下文都是它的一部分。它是系统 .NET 特征就像 Task 用来捕捉 以及 传递上下文，但是这不是它们自有的的行为。

**SecurityContext**

我们发现任何安全信息都在这里，仅限于当前线程。如果你的代码需要运行在特定的用户，你也许能模拟用户，或者 ASP.NET 能为你做这个模拟。那样的话，模拟的信息会存储在 **SecurityContext**

**CallContext**

在当前线程声明周期，它允许程序存储自定义数据。尽管这在大多数场景中是个坏的实践，但是它能避免在程序中传递各种上下文时参数过多。 **LogicalCallContext** 是跟系统相关的，它能在夸应用程序域（AppDomains）工作。

> 要注意本地线程存储，它在目的上跟调用 CallContext 是相似的，在同步场景是不工作的，因为线程在长时间运行的操作时会被释放，只能用其他方式。你的方法能在完全不同的线程恢复。

C# 将会还原他们的线程类型信息，当你的方法被恢复时。还原上线文是需要一些代价的，比如，程序大量异步，以及信息模拟，那运行就会缓慢。我的建议是避免 使用新建上下文这种 .NET 特性，除非你清楚它是非常必要的。

# 什么情况下不能用使用 await

**await** 能用在标记了 **async** 所有方法中，这在绝大数情况方法中是这样的。但是也有少许地方你是不能使用 **await**。我将详细解释一下为什么在这些场景下是无法使用 await 的。

## 在 catch 和 finally 块中

在 **try** 语句块中是完全可以使用 **await**，但是你在 **catch** 或 **finally** 块中使用它是无效的。在 **catch** 以及 **finally** 中，异常还是在程序当中处于展开的堆栈当中，并在快中抛出。如果你在此之前使用了 **await**，那么堆栈将会发生变化，重新抛出异常的行为就会将变得非常难以定义。

千万要记住不要在 **catch** 块中使用 **await**，它常被用在 **catch** 块之后，无论是通过一个 **return** 语句或是 **bool** 变量来记住原始操作是否抛出异常。例如，如果你下个写如下效果的代码：

```c#
var webClient = new WebClient();
try {
    var data = await webClient.DownloadDataTaskAsync(URL);
} catch (Exception e) {
    var data = await webClient.DownloadDataTaskAsync(URL);
}
```

应该用下面的代码替换

```c#
bool failed = false;
var webClient = new WebClient();
try {
    var data = await webClient.DownloadDataTaskAsync(URL);
} catch (Exception e) {
    failed = false;
}
if (failed) {
    var data = await webClient.DownloadDataTaskAsync(URL);
}
```

## lock 语句块

lock 语句块是程序为了防止其他线程与当前前程在同一时刻访问共享的对象。因为异步代码通常会释放刚开始在上面执行的线程，并且可能在以后未知的时间内，与原始线程不同的线程上回调，在等待时候占用锁，这是没有意义的。

在某些场景中，来自并发访问来保护你的对象这是至关重要的，但在等待的时，其他线程访问这个对象，这是无关紧要的。在这样的场景下，你可以选择编写显式的 lock 两次这种稍微冗长的代码：

```c#
lock(mutex) {
    // Prepare for async operation
}
await CorrectWay();
lock(mutex) {
    // Use result of async operation
}
```

或者是你可以使用并发库来控制，例如 NAct 这在第十章会有介绍。

如果很不幸，在你的异步方法执行的过程中，你可能需要用到一些锁。如果是这样，那么你就需要好好想想，因为一般情况下，在一个异步调用的时候,它是很难去锁住资源的而没有引起严重的争用和死锁问题。

## LINQ 查询表达式

C# 有语法能够很容易的写申明式过滤查询，转换，排序和分组数据。这些查询能够在 .NET 集合中执行，或者转换在数据库或是其他数据源上执行。

```c#
var dataSource = new int[4] { 1, 2, 3, 4 };
IEnumerable<int> transformed = from x in dataSource
                                where x != 9
                                select x + 2;
```

在大多数这样 LINQ 查询表达式你是无法使用 **await**，因为那些被编译器转换的地方被编译成 lambda 表达式，正因如此，lambda 表达式将需要标记 **async**。没有语法支持隐式的标记这些 lambda 表达式为 **async**， 如果这么做的话，也会很困惑。

你可以把 LINQ 查询表达式改成写用 LINQ 的拓展方法来等价的表示。然后 lambda 表达式就会编程显式的，你就可以用 **async** 来标记它们，也就可以使用 **await**。

```c#
IEnumerable<Task<int>> tasks = dataSource
    .Where(x => x != 9)
    .Select(async x => await DoSomthingAsync(x) + await DoSomthingElseAsync(x));
IEnumerable<int> transformed = await Task.WhenAll(tasks);
```

**Task.WhenAll** 相关的 Task 集合工作的知识会在第七章介绍。

## 不安全代码

代码标记了 **unsafe** 的代码，不能含有 await。不安全代码的情况应该非常罕见，并且应该保持独立的方法，不能异步。**await** 编译器转换大多数代码的时候，会破坏不安全代码。

# 异常捕获

异常在异步方法中要被设计成与普通同步方法的异常是相似的。然而，异步额外的复杂性是这里面有微妙的不同。这小节讨论异步怎样使异常能够简单的处理，以及在第九章要讲的警告的细节。

让 Task 完成时，Task 会有一个具体的类型来表示它是完成还是失败。最简单的是 Task 提供了 **IsFaulted** 属性，true 说明在 Task 运行期间抛出了一个错误。**await** 关键字注意到它并在该 Task 内抛出异常。

> 如果你熟悉 .NET 异常系统，你可能想知道当异常抛出时，异常的堆栈是否正确存储。这在过去一直是不可能的；每个异常只能被抛出一次。然而在 .NET4.5 这个限制被修复了，通过一个新类——**ExceptionDispatchInfo**，它与 Exception 合作在正确的堆栈捕捉和抛出。

异步方法也关心异常。任何异常在异步方法运行期间发生了，并且没有捕获，那么它会替代 Task 的返回给调用者。当发生异常时，调用者如果已经准备好等待 Task，异常将会在那里抛出。这样异常就通过调用者传递回来了，以同步代码相同的方式行程一个虚拟的堆栈跟踪。

> 我之所以把它称为 *虚拟堆栈跟踪* ，是因为堆栈是一个线程具体有的，在 async 代码中，这当前线程实际的堆栈可能与从异常产生的堆栈非常不同了。捕获堆栈异常跟踪是程序员的目的，程序员可以调用方法，而不是一些细节关于 C# 如何选择执行那些方法的部分。

# 异步方法在需要之前是同步的

我是说在，只有它们在等待中使用异步方法才是异步的，在此之前都是同步的。直到异步发生，运行在调用他们的线程当中，就像跟一般的同步方法一样。有时会产生非常实际的影响，特别是当整个异步方法链可以同步完成时。

要记住一点，异步方法只有当到达 **await** 处才会等待。甚至有时候都不需要这么做，因为有时候在等待 Task 的时候，它早就完成了。Task 早就完成场景有下面几个：

- 创建的时候就完成了，通过 `Task.FromResult` 公共方法，这将在第七章有详细解释
- 通过从不会 **await** 的异步方法返回
- 运行在真正的异步操作，但是此刻完成了（因为在当前线程在等待之前也许做其他事）
- 通过一个到达 **await** 的异步方法中返回，但是  await 的是早已经完成的 Task

因为最后一种可能性，在深度链式异步方法中，当你在 **await** 一个已经完成的 Task的时候，一些有趣的事发生了。整个链就像同步的完成一样。这是因为在链式的异步方法中，第一个 **await** 总是在最深的一级被调用的。只有在最深的方法返回，其它的才会同步到达。

你也许想知道为什么如果出现第一个或第二个可能发生的情况，你会首先使用 async 。如果那些方法保证能同步返回，那么你将会编写同步代码比编写没有 **await** 的异步方法更加有效，这是对的。然而，方法结果缓存在内存中，结果能从缓存中同步返回，但是它 http 请求需要异步。你也许想让方法返回一个 Task 或 Task<T> 未来可靠的代码，当你知道这是好的机会，你将愿意使那些方法在某个时间段变得异步。