# 前言

现如今异步代码已经越来越重要，并在各个应用程序都有广泛的使用。但是如果你不懂这其中究竟发生了什么，那么当你的应用程序发生了未知的行为或错误，你却无法理解这其中的原因，以至于无法及时修复。所以掌握异步程序背后的原因是非常重要的。

# 桌面用户应用程序

桌面应用程序是非常要求性能的。因为要及时的响应用户操作。（Human Computer Interation）HCI 研究发现，在人机交互时，在一个长时间的交互操作下，为了让用户感觉不到慢，需要用一个进度条。

当程序等待未响应的时候，人都会感到沮丧。而程序未响应是因为程序要长时间运行一个操作并等待结果，无论是长时间的计算，还是 I/O 读写操作。

在 C# 中有很多 UI 框架就用到了单个 UI 线程：

- WinForms
- WPF
- Silverlight

只有当前的UI 线程才能处理特定的窗口内容。只有这个 UI 线程才能检查数据和用户行为并且做出响应。如果这个线程正在运行或者被阻塞一小段时间，那么用户就会注意到应用程序非常缓慢。

异步代码，甚至是手写的，就意味着 UI 线程能返回主线程去检查用户事件中的消息队列。也能在窗口执行进度条动画展示，鼠标移动等那些用户在意的重要的视觉因素，表明应用程序能够很好的做出响应。

> 注意：所有的 UI 框架都只能使用一个线程的理由是为了同步。如果多线程，那么其中一个正在访问按钮的长度，与此同时另一个线程在进程中对这个按钮正在布局。为了防止冲突，你需要一个锁，它会降低性能，但是在同一时刻只有一个线程对数据进行访问。

## 类比：咖啡店

我们用类比的方式来理解上面涉及到的问题。如果你已经理解了，那么你可以跳过此小结。

想象一下在一个很小的咖啡店里，有一些客人要品尝他们的早餐。这里只有一个职员。他要专注于对客户的服务，但是他没有学习异步技术。

UI 线程就是这个职员。它以相同的方式在电脑中工作，只有咖啡店的职员才能在咖啡店工作。在这个例子中，只有一个工作人员，就像只有一个 UI 线程一样。

第一个客户向职员要了一片吐司。职员去拿面包然后开始考面包。然后他要盯着烤面包炉直到烤完吐司。这个时候客户发现有更好吃的食物，但是这个时候职员没有理他，因为他正在盯着烤面包机，就好像他阻塞了。五分钟后，吐司考好了，职员带给他，这个时候已经排起了长队，并且客户非常生气了，因为该职员忽视了他

现在让我们来教这位职员以异步的方式来处理这件事。

首先，要确保烤面包机是支持异步的。当编写异步代码时，我们要确保调用一个长时间运行的操作时能够回过头来做其他事。同样，烤面包机有一个定时器，烤好的时候能够自动弹起来，引起职员的注意。

下一步要做的就是一旦他开始用烤面包机就要忽略烤面包机。他应该返回去服务客户。相同的，我们的异步代码一旦开始一个长时间的操作就要必须返回，所以 UI 线程能够响应用户的动作。

这里有两个理由：

- 它更能让用户感到响应——客户能要求更好的时不能忽略。
- 用户同时能做其他的操作——下一个客户也能下单。

现在职员能够在相同时间处理多个客户，直到烤面包机能同时烤的数量，并且他还要花时间端这些吐司。但是这又会引起一个问题：他发现这样很难记住哪些面包是为哪些客户准备的。事实上，UI 线程并没有足够的内存去处理用户事件，当这个操作发生等待的时候。

因此当开始执行的时候要触发回调，能提示我这个事情已经完成了。对于职员来说，就只需要简单的把吐司对应那个客户的名字写到纸上就行了。我们可能还有更复杂的，一般情况下，我们希望在工作完成能够提供一个让我们做什么的完整说明。

有了这些，职员现在就有一个完整的异步操作了。客户的体验也非常好。他们少的等待，更好的响应服务。

# Web 应用程序

ASP.NET Web 应用程序不像桌面应用程序一样限制了一个 UI 线程执行。也就是说能够更好的利用异步代码获益。一个高耗时的操作，特别是远程访问数据库查询，这在 Web 应用程序当中是非常常见的。

来处理 web 请求的线程总数或者并发处理请求的线程数总会有限制，这取决于你的 IIS 版本。如果你的查询操作时间很长，那么提高并发请求数来提高服务器的吞吐量是个不错的方法。

当线程阻塞时，它不会使用 CPU。然而这不代表就不占用你服务器的资源。事实上，线程会导致两个重要的开销，即时它被阻塞：

1. 内存：

   每个托管线程在Windows上预留大约兆子节的虚拟内存。

   如果你有几十个线程并没有什么问题，但是如果你使用了上百个线程，那么就很容易的失去控制。如果内存交替到物理磁盘，那么线程就会变得很慢了。

2. 调度器开销

   操作系统调度器能够选择一些线程在 CPU 上做出响应。即时线程阻塞，调度器必须要考虑他们，发现他们是不是没有阻塞了。这个时候就发生线程上下文切换，这会减慢整个系统的速度。

这些都会给服务器带来负载，增高延迟，降低吞吐力。

切记：异步代码的主要特征是，启动长时间运行的操作线程被释放来做其他事。在 ASP.NET，线程主要来自于线程池，所以在等待长时间操作时它会返回到线程池。它能处理其他请求，所以在处理相同数量的请求的线程数会更少。

## 类比：餐厅厨房

web 服务器就好比一家餐厅。很多客户下单点菜，并且厨房能够尽快的满足他们。

在厨房中有很多厨师，每个就代表一个线程。他们在炒客户订单里的菜，但是在准备期间，每个菜都需要在烤箱里面一段时间，这个时候厨师没事可做。这映射了在 web请求中经常会数据库查询，web服务器并没有参与进来。

在一个封闭的厨房里，厨师会坐在烤箱前，直到烤好。关联到线程，这些厨师签了一份奇怪的合同，他们在做饭等待的时候是没有工资的，因为当阻塞的时候它没有占用 CPU 的时间，也许他在看报纸。

甚至我们不需要支付他们工资，也可以为每一道菜聘请新的厨师，而正在等待的厨师还在厨房里，占用了厨房的空间。厨房里不能在有超过10个厨师，这样会变得难以移动，这样每个人都会工作得更慢。

当然，异步系统会工作得更好。每次食物放到烤箱，厨师都会记下来这是什么菜，准备到什么阶段了，然后找新的任务做。当烤箱好了之后，厨师就会拿出来继续做接下来的准备工作。

在 web 服务器，异步会让服务器更加高效和健壮。只需要少量的线程能管理多个请求，而这些请求之前要数百个线程，或是开销太大难以实现。实际上，在一些 web 框架，尤其是 node.js，抛弃了多线程的想法，用单线程去处理所有的异步请求。它经常用单个线程处理更多的请求，哪怕阻塞了，系统也能处理。同样，一个有条理的厨师在空的厨房里要比上百个厨师能够烹饪更多的食物，而不是花了很多时间被彼此绊倒或是读报纸。

# 并行代码



