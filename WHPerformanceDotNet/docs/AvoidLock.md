# 如何正确使用锁

在提供 `async,await` 关键字之后，我们尤其要注意，在使用的时候千万不要同步等待 Task。这样很有可能会发生死锁，以及吞吐量大的时候会发生浪费线程池的线程以及线程上下文切换导致更大的开销。

所以我们在使用多线程乃至并发的时候，尽量要做到无锁。

我们在于 I/O 线程交互时，发生等待阻塞当前线程。这时就有两种情况

1. 线程会被阻塞为等待状态，不会参与**线程调度**，并运行另一个线程。如果当前所有线程都被占用或者阻塞，那么就会在线程池中新创建一个线程来完成后续任务。
2. 线程遇到某个同步对象，会等待解锁而不停的自旋（Spin）。如果无法及时获取信号量，就会进入第 1 步的状态。

以上两种情况都会对线程池产生一定影响，会创建不必要的线程以及第 2 步会让 CPU 白白自旋浪费资源。所以都是不可取的。

# 如何高效的在 I/O 中使用 Task

以下载资源为例，一般我们的做法都是一次性读取整个文件流加载到内存中。这样会导致程序运行时间长，伸缩性不强。由于等待时间长，浪费的资源也很大。所以我们可以从流中读取多次并加载到内存，直到读取内容结束。、用两层 Task 即可完成任务，外层 Task 表示全部读取的工作，提供给调用者调用。而内层的 Task 用于每次读取剩下的文件流。我们不能在第 1 次返回 Task，这样我们得到的不是读取整个流的 Task，而是用一个 Task 来表示内层的 Task 已经全部读取完成。

这可以用 `TaskCompletionSource<T>` 来达到目的，它可以帮你生成一个用于返回的伪 Task，这会让 Wait 或 ContinueWith 的调用者继续往下执行。

