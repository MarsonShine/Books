# 集合的实现与复杂度

- `Dictionary` 字典集，通过哈希表实现，插入和查找的时间复杂度是 `O(1)`
- `SortedDictionary` 有序字典集，是通过二叉查找树来实现的，所以时间复杂度为 O(log n)
- `SortedList` 通过数组排序实现的。O(log n) 的时间复杂度，但是它在插入时的最坏时间复杂度为 O(n)。如果你要插入随机元素，你需要屏藩的调整容量大小以及移动已存在的数据。如果你是要有序的插入所有元素，那么使用它则是最快的。

上面三个集合，只有 `SortedList` 要求很小的内存。其它两个会要更多的内存访问，但是在插入时间上平均要好些。选择使用哪个具体依赖你的应用程序的要求。

- `HashSet` 使用哈希表实现，所以插入，查找删除操作都是 O(1)
- `SortedSet`  使用二叉查找树实现，故时间复杂度为 O(log n)
- `List` 插入时间复杂度为 O(1)，但是删除和查找的时间复杂为 O(n)
- `Stack` 和 `Queue` 只能插入或者从中删除，所以所有操作的时间复杂度为 O(1)
- `LinkedList` O(1) 的插入和删除，经常避免被用在大量的基元类型操作，因为它会给你添加的每个元素分配新的 `LinkedListNode<T>` 对象，这会浪费开销。
- `BitArray` 表示位的数组。你可以单独的设置位以及再整个数组对象上执行布尔逻辑。如果你只需要 32 位的数据，那么就用 `BitVector32`，它会更快并且开销更小（因为是结构体）