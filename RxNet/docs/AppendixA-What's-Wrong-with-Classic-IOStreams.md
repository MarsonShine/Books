# 附录 A：经典 IO 流的问题所在

在[关键类型](key-types.md)一章中，我指出 `System.IO.Stream` 并不适合 Rx 中的事件流建模。本附录将解释其中的原因。

`System.IO.Stream` 所代表的抽象概念被设计为操作系统的一种方法，使应用代码能够与可以接收和/或产生字节流的设备进行通信。这使得它们成为卷对卷磁带存储设备的良好模型，这种存储设备在设计这种流时非常普遍，但如果只想表示一串值，则显得不必要的繁琐。随着时间的推移，流被用来表示越来越多的不同事物，包括文件、键盘、网络连接和操作系统状态信息，这意味着当 2002 年 .NET 出现时，它的流类型需要混合多种功能，以适应一些相当多样化的场景。而且，由于并非所有的流都是相同的，有些功能在某些流上不起作用是很常见的。

**IO 流的设计目的是支持高效地传输相当大容量的字节数据**，通常使用的设备本身就能处理大块数据。在设计 IO 流的主要场景中，读写操作需要调用操作系统 API，而这些 API 通常成本较高，因此基本的读写操作需要使用字节数组。(如果只需调用一次系统，就能传输数千个字节，那么单次调用的开销远低于一次处理一个字节的开销）。虽然这有利于提高效率，但却给开发人员带来了不便（如果你希望使用流纯粹表示进程中的事件流，而这些事件流实际上不需要进行系统调用，因此无法享受这种性能/便利权衡带来的好处，那就会很麻烦）。

这个问题有一个标准的临时解决方案：向应用程序代码呈现流的库通常不直接表示底层操作系统流。相反，它们通常是缓冲的，这意味着库将以相当大的块进行读取，并将最近获取的字节保存在内存中，直到应用程序代码请求它们。这可以使像 .NET 的单字节`Stream.ReadByte` 方法能够相对高效地工作：对该方法的几千次调用可能只会导致一次调用操作系统 API，该 API 提供对流所表示的任何物理设备的访问。同样地，如果你向一个 IO 流发送数据，缓冲流将等待直到你提供了一定数量的数据（在某些 .NET Streams 中，4096 字节是常见的默认值）之后，才会实际发送任何数据到目标位置。

但对于我们在 Rx 中表示的事件源类型来说，这可能是一个严重的问题。如果 IO 流故意将您与数据的实际移动隔绝开来，那么在金融应用程序中，这可能会带来灾难性的延迟，因为在金融应用程序中，信息的收发延迟可能会产生巨大的财务后果。即使没有直接的财务影响，这种缓冲也不利于在用户界面中表现事件。没有人愿意在应用程序开始执行输入之前点击按钮数千次。

还有一个问题是，你并不总是知道你得到的是哪一种数据流。如果你确实知道你得到的是一个非缓冲流，代表磁盘上的一个文件（因为你自己创建了这个流），那么你通常会写出与你知道你得到的是一个缓冲流完全不同的代码。但是，如果你编写的方法接受了一个流参数，你就不清楚你得到了什么，所以你不一定知道哪种编码策略是最好的。

另一个问题是，由于 `System.IO.Stream` 是面向字节的，因此它无法产生更复杂的值。如果你想要一个 `int` 值流（这并不比字节值流复杂多少），`System.IO.Stream` 毫无帮助，直到最近，它甚至可能会阻碍你。如果你使用普通的 `Read` 或 `ReadAsync` 方法，你可以尝试一次读取四个字节，但是 `System.IO.Stream` 有权决定只返回三个字节。（流允许以这种小气的方式是因为最初的设计假设流表示某种底层设备，该设备可能本质上是使用固定大小的数据单元进行操作。磁盘驱动器和固态硬盘无法读取或写入单个字节；相反，每个操作都使用一些完整的“扇区”，每个扇区由数百或数千个字节组成。因此，读操作可能无法精确地返回您请求的字节数。对于表示通过网络传入的数据的流，这也可能发挥作用：这样的流可能已经接收到一些数据，但少于您要求的数据量，并且它们可能决定返回它们已经接收到的数据，而不是让您等待下一条网络消息的到来。）现在，消费代码需要解决如何处理这个问题。.NET 7.0 终于解决了这个问题（在 `Stream` 首次出现大约两个十年之后），通过添加了 [ReadExactly](https://learn.microsoft.com/en-us/dotnet/api/system.io.stream.readexactly) 和 [ReadExactlyAsync](https://learn.microsoft.com/en-us/dotnet/api/system.io.stream.readexactlyasync) 方法，但如果你必须针对 .NET Framework 进行开发，这些方法是不可用的，你仍然需要自己完全解决这个问题。

即使使用了新方法（或者编写了封装程序来处理 `Stream` 作为磁带存储设备抽象的起源所导致的这些问题），仍然存在缺陷。如果你想让类型系统帮你区分 `int` 值流和 `float` 值流，`Stream` 不会帮你。你最终需要的是另一种具有类型参数的抽象。比如 `IObservable<T>`。我们确切地知道 `IObservable<T>` 中的数据类型，这对于实现它所支持的许多 LINQ 操作符至关重要。

另一个潜在的混乱来源是 Unix 的“一切皆文件”设计特性。操作系统通过与文件相同的操作系统抽象来表示各种事物，这简化了操作系统的设计，在某些情况下，还能让您以创造性的方式应用原本为文件设计的工具。但这样做的缺点是，有些数据流很不稳定。从 .NET 类型系统的角度来看，流看起来与其他流一样，但只有在以特定大小的块为单位进行读写时才能工作。

相反，Rx 严格定义了可观察源与其订阅者之间的交互规则，这意味着我们可以清楚地知道自己的位置。

对于流如何支持多个订阅者，并没有一个清晰的模型。Unix `tail` 命令等程序能够“跟踪文件”的变化，但它们实现这一功能的方式并不像两个观察者同时调用订阅那么简单。

这些只是消费者方面的问题。如果你想以流的形式实现一个事件源，那也不是什么有趣的事。要实现自己派生自 `Stream` 的类型，你需要实现它定义的全部 10 个抽象成员： 5 个属性和 5 个方法。这与 `System.Reactive` 提供的实现 Rx 事件源的简单方法相去甚远。