[PostgresSQL 的官方文档](https://www.postgresql.org/docs/)

## 页剪枝和HOT更新

在 PGSQL ，**页剪枝**（Page Pruning）和**HOT更新**（Heap-Only Tuple Update）是用于优化存储和提高性能的重要机制。

**页剪枝（Page Pruning）：**

当数据库读取或更新堆页面时，可能会执行快速清理或修剪操作，以回收空间并提高存储效率。 这种操作通常在以下情况下发生：

1. 访问页面时，发现之前的更新操作在当前页面上没有找到足够的剩余空间。 在这种情况下，页面头部可能被设置了 `PD_PAGE_FULL` 标志，指示该页面已满。下次访问该页面时，根据这个标志进行修剪操作，以回收空间。
2. 访问页面时，发现页面中的剩余空间不满足填充因子的要求，或者小于页面大小的 10%。 例如，在创建表时，可以通过 `WITH fillfactor = 75` 来设置填充因子。 如果页面的剩余空间低于此阈值，系统可能会进行修剪操作。

**页剪枝的主要目的是通过清理无效或过时的元组，释放页面空间，从而提高数据库的存储效率和查询性能。** 

**HOT更新（Heap-Only Tuple Update）：**

在传统的数据库更新操作中，更新一行数据通常会在表中插入一个新版本的行，然后系统需要在所有相关索引中添加新的索引项，并指向新的元组版本。 这意味着一次 UPDATE 操作可能需要修改多个索引，可能导致索引的频繁更新，增加存储开销，并降低性能。

为了解决这个问题，PostgreSQL 引入了 [HOT 更新技术](https://postgres.ac.cn/docs/current/storage-hot.html)。当更新操作满足以下条件时，可以使用HOT更新：

1. 更新不会修改表的索引引用的任何列，包括摘要索引。核心 PostgreSQL 发行版中唯一的摘要索引方法是 [BRIN](https://postgres.ac.cn/docs/current/brin.html)。
2. 包含旧行的页面上有足够的空闲空间可用于存储更新后的新行。

在这种情况下，系统会在同一数据块（数据页）内存储新行，并让旧行指向新行，形成一个链表结构。 这样，通过索引访问旧行数据时，可以顺着链表找到最新的行版本。 由于新行和旧行位于同一数据块内，且没有修改索引列，因此无需更新索引，从而减少了索引维护的开销，提高了更新操作的性能。 

此外，定期的 `VACUUM` 操作仍然是必要的，以清理不再需要的行版本，保持数据库的健康状态。 

## 页分裂

页分裂发生在插入新数据时，索引页面的空间不足以容纳新的记录，从而触发页面分裂的过程：

1. **检测页面空间不足**：
   - 当向B树/B+树插入新数据时，数据库首先寻找合适的页面（叶节点）存储该数据。
   - 如果页面的剩余空间不足以插入新记录，就会触发页分裂。
2. **分裂页面**：
   - 数据库将原有页面中的数据分成两部分，通常按照一定的分裂策略（如中间点）进行划分。
   - 一部分数据保留在当前页面中，另一部分被移动到新创建的页面中。
3. **调整父节点**：
   - 分裂后，会在父节点插入一个新的索引项，以记录新页面的范围。
   - 如果父节点也没有足够的空间存储新的索引项，父节点也可能发生分裂，进一步向上递归，直到根节点。

这就会导致**树的高度增加**，进而导致性能。

性能下降是多方面的：

- 额外的 I/O 和计算开销，包括创建新页面、移动数据、调整索引等。
- 对于频繁发生插入操作的系统，大量页分裂会导致性能显著下降。
- 索引的碎片化，降低查询效率。
- 数据在逻辑上是连续的，但在物理上分布在不同的页面中，导致额外的 I/O。
- 页分裂会创建新的页面，占用更多的存储空间。

解决方案也有如下方案：

1. **合理设置填充因子（Fill Factor）**：如较低的填充因子（如70%-80%）为未来的插入操作预留空间，减少页分裂的发生。
2. **定期维护索引**：使用数据库的`REBUILD`或`REORGANIZE`命令重建索引，减少碎片化。
3. **批量插入**：尽量采用批量插入操作而非单条记录插入，可以降低页分裂的频率。
4. **合理设计主键或索引列**：例如避免使用高随机性的主键（如 GUID），选择自增主键或顺序主键，减少插入时的随机性，从而降低页分裂的概率。
5. **PGSQL 自动清理（Autovacuum 和 VACUUM）**：PostgreSQL 的自动清理机制（`VACUUM` 和 `Autovacuum`）会清理无用的行版本和死索引项，间接地减少页分裂导致的碎片化问题。

> 在进行索引重建时，一般是需要查询索引碎片化指标数据的，以下方式可以查询：
>
> 1. 检查 `pg_stat_all_indexes` 中的索引使用统计。
> 2. 使用 `pg_relation_size()` 查看索引大小。
> 3. 使用 `pgstatindex()` 查看叶节点密度。
> 4. 借助 `pg_bloat_check` 工具估算膨胀比例。
> 5. 查看 `VACUUM VERBOSE` 的输出中索引死元组情况。

## Vacuum 和 Autovacuum

在 PostgreSQL 中，[**VACUUM** 和 **Autovacuum**](https://www.postgresql.org/docs/current/routine-vacuuming.html) 是用于维护数据库健康和性能的重要机制。

### VACUUM

**VACUUM** 命令用于清理表中的死元组（已删除或更新的旧版本行），释放空间供未来使用，并防止表和索引膨胀。

在 PostgreSQL 的多版本并发控制（MVCC）机制下，删除或更新操作不会立即物理移除旧数据，而是将其标记为无效。

因此，定期执行 VACUUM 对于回收存储空间和保持数据库性能至关重要。

VACUUM 的主要功能包括：

- **回收空间**：将死元组占用的空间标记为可重用，以供新数据插入。
- **防止事务 ID 环绕**：通过将旧事务 ID 冻结，避免事务 ID 重用导致的数据可见性问题。
- **更新统计信息**：可选地更新表的统计信息，帮助查询优化器生成更优的执行计划。

需要注意的是，**VACUUM FULL** 会对表进行更彻底的清理，包括重新组织表的数据并释放未使用的空间回操作系统，**但会锁定整个表，可能影响并发操作。** 

### Autovacuum

**Autovacuum** 是 PostgreSQL 的自动清理守护进程，负责在后台自动执行 VACUUM 和 ANALYZE 操作。

它定期扫描数据库中的表，检测需要清理的死元组，并在无需人工干预的情况下执行清理操作。

Autovacuum 的工作机制包括：

- **周期性扫描**：根据配置参数 `autovacuum_naptime`（默认值为 1 分钟），Autovacuum 守护进程会定期唤醒，检查数据库中的表是否需要清理。

- **触发条件**：当表中的死元组数量超过一定阈值时，Autovacuum 会触发 VACUUM 操作。

  该阈值由以下公式确定：

  ```
  复制代码
  autovacuum_vacuum_threshold + autovacuum_vacuum_scale_factor * pg_class.reltuples(表的行数)
  ```

  默认情况下，`autovacuum_vacuum_threshold` 为 50，`autovacuum_vacuum_scale_factor` 为 0.2。 

- **并发工作进程**：Autovacuum 使用多个工作进程并行处理不同的表。

  最大工作进程数由参数 `autovacuum_max_workers` 控制（默认值为 3）。

  每个工作进程在处理表时，会根据表的大小和活动情况决定是否执行 VACUUM 或 ANALYZE。

### 清理阶段

VACUUM 操作通常包括以下阶段：

1. **扫描堆表**：遍历表的所有页面，标记死元组，并可能执行冻结操作。
2. **清理索引**：清理与死元组关联的索引项，确保索引结构的有效性。
3. **清理堆表**：实际删除死元组，并将空间标记为可重用。
4. **截断堆表**：如果表末尾存在连续的空页面，VACUUM 会将其截断，释放空间回操作系统。
5. **最终清理**：更新统计信息和可用空间映射，确保数据库元数据的准确性。

### 管理负载机制

为了避免 VACUUM 操作对数据库性能产生负面影响，PostgreSQL 提供了多种参数来控制其资源消耗：

- **成本延迟机制**：通过设置 `vacuum_cost_delay`（每次达到成本限制后的休眠时间，默认值为 0 毫秒）和 `vacuum_cost_limit`（每个 VACUUM 操作的成本限制，默认值为 200），可以控制 VACUUM 的执行速度，减少对系统性能的影响。

- **自动清理成本参数**：`autovacuum_vacuum_cost_delay` 和 `autovacuum_vacuum_cost_limit` 分别用于控制 Autovacuum 的延迟和成本限制。

  默认情况下，`autovacuum_vacuum_cost_delay` 为 2 毫秒，`autovacuum_vacuum_cost_limit` 为 -1（表示使用 `vacuum_cost_limit` 的值）。

- **工作进程数**：通过调整 `autovacuum_max_workers`，可以控制同时运行的 Autovacuum 工作进程数量。

  需要注意的是，增加工作进程数可能导致每个进程分配的资源减少，应根据系统性能进行合理配置。

通过合理配置这些参数，PostgreSQL 能够在保持数据库性能的同时，自动执行必要的清理操作，确保数据库的高效运行。

## 表重建和索引重建

如果表或索引文件的大小增加了，VACUUM 可以清理一些页内空间，但很少能减少页面的数量。只有当文件末尾出现若干空页面时，回收的空间才能返还给操作系统，但这种情况并不常见。

大小过大会导致诸多不良影响：

- 全表 (或索引) 扫描将花费更长时间。
- 可能需要更大的缓冲区缓存 (页面作为一个整体被缓存，因此数据密度降低)。
- B 树会有额外的层级，这会减慢索引访问的速度。
- 文件在磁盘上和备份中占用额外空间。

可以执行VACUUM FULL 命令执行完全清理，可以对表和索引进行重建，请注意，该操作会执行表锁定。

除了 VACUUM FULL，还有其它重建方式。

### CLUSTER

`CLUSTER` 命令不仅会清理表中的死元组，还会根据指定的索引对表中的**元组进行排序**。它会将表按照索引的顺序重新组织，以优化基于该索引的查询性能。

但同样此操作需要对表进行锁定，如果表非常大，操作会非常耗时，并且会对其它事务操作造成影响。

**注意**：PostgreSQL 不支持聚簇（即排序）永久化：每当有新的插入或更新操作时，表的物理顺序就会改变。因此，`CLUSTER` 只会在执行时优化顺序，对未来的更新不会产生影响。

### REINDEX

如果索引变得碎片化，或者因为某些原因索引失效（例如损坏），可以使用 `REINDEX` 来重新创建索引。

**注意：**`REINDEX` 只重建索引，而不是对整个表进行重建。所以它不会回收表空间。

### 拓展工具

[pg_repack](github.com/reorg/pg_repack) 是一个 PostgreSQL 扩展，用于在 **几乎零停机的情况下**重建表和索引。与 `VACUUM FULL` 不同，`pg_repack` 通过在后台创建一个新的**临时表**和索引，逐步将数据从旧表复制到新表，尽量减少对生产系统的影响。

这里简单讲下 pg_repack 的工作原理：

在重建过程中，`pg_repack` 不会占用长时间的排它锁，而是通过创建新的表（或索引）来避免对现有表的操作产生长时间的阻塞。

排它锁只会在重建的 **开始和结束时** 短暂存在。具体来说，操作会先在后台创建新表或新索引，随后进行数据的逐步迁移，最后删除旧表并替换成新表（索引）。

**较少停机时间**：由于数据在后台逐步迁移，这大大减少了实际业务运行中的停机时间。

> 这里着重讲下数据同步：
>
> 因为是在新表和新索引进行操作，然后再转移，那么之前的旧表会继续有数据和新增索引信息，怎么保持数据的同步和一致性呢？
>
> 实际上这跟增量同步的机制是类似的：
>
> **创建临时表**：
>
> - `pg_repack` 会创建一个与原始表结构完全相同的临时表。这张表是通过原始表的定义来创建的，但初始时没有任何数据。
>
> **复制数据到临时表**：
>
> - 在数据复制阶段，`pg_repack` 会将原始表的数据逐步（按批次）复制到临时表中。
> - 由于数据是在逐步复制的，这意味着它在进行数据迁移时不会锁定原始表，原始表仍然可以进行 INSERT、UPDATE、DELETE 操作。这使得在复制过程中，原始表仍然可以继续接收新的数据。
>
> **保持同步（最小化数据差异）**：
>
> - 在数据复制的过程中，`pg_repack` 会监控原始表的更改（如插入、更新和删除）。在复制数据到临时表后，系统会保持一个视图，查看原始表中的任何新数据和更新，并及时同步到临时表。
> - 这种机制是通过对原始表的增量变更（通常是通过触发器或日志记录的方式）来实现的，如 [WAL](https://github.com/MarsonShine/MS.Microservice/blob/master/docs/patterns-of-distributed-systems/Write-Ahead-Log.md)，从而保证在复制期间数据的一致性。
>
> **交换原始表与临时表**：
>
> - 一旦数据复制完成并且临时表与原始表保持同步，`pg_repack` 就会使用一个非常短的时间窗口（在此期间对表会加锁）来交换原始表和临时表。这一步是所有数据同步的最后一步，在交换表的过程中，`pg_repack` 会保证将最后的差异同步到临时表。
> - 这个交换过程是原子性的，只会对表进行非常短时间的排它锁定，这通常是不可感知的，尤其是在高负载的系统中。
>
> **清理临时表**：
>
> - 完成表和索引的交换后，`pg_repack` 会删除临时表，并清理过程中产生的任何临时文件或资源。

## 锁

### 关系级锁（Table-Level Locks）

关系级锁是对数据库中**整个表**的锁定，通常在进行**表结构修改** 或**多行修改**操作时使用。它的作用是防止其他事务对同一表的并发操作。

#### 锁类型

- **ACCESS SHARE LOCK**：最轻的锁，允许其他事务读取表数据，但不允许修改。
- **ROW SHARE LOCK**：允许其他事务读取数据，但不允许进行数据修改。通常在执行 **SELECT FOR UPDATE** 时使用。
- **ROW EXCLUSIVE LOCK**：允许其他事务读取数据，但会阻止其他事务插入、更新或删除表中的行。
- **SHARE UPDATE EXCLUSIVE LOCK**：主要用于更新操作，但也允许**其他 SELECT**和**某些非冲突操作**，如 VACUUM、CREATE INDEX CONCURRENTLY。
- **SHARE LOCK**：允许读取，但阻止其他事务修改。
- **EXCLUSIVE LOCK**：锁定表，阻止其他事务进行任何类型的读写操作。
- **ACCESS EXCLUSIVE LOCK**：最强的锁，完全阻止其他事务对该表的任何操作（包括读取和写入）。通常在 **ALTER TABLE** 或 **DROP TABLE** 时使用。

#### 内存结构

- 每个事务持有的锁记录都存在于**锁管理区（Lock Manager）** 中，相关信息存储在内存结构中。
- 锁的粒度较粗，主要通过**锁表**实现，但会对性能产生较大影响，尤其在高并发场景下。

### **行级锁（Row-Level Locks）**

行级锁是 PostgreSQL 支持的较细粒度的锁定方式，它能够在同一表中对**单行数据**进行加锁，从而避免多个事务同时修改同一行数据。这是并发事务控制的一个关键特性。

#### 锁类型

- **FOR UPDATE**：用于加锁选中的行，防止其他事务对其进行修改。通常与事务一起使用。
- **FOR SHARE**：允许共享锁定，其他事务也可以对行进行共享锁操作，但不允许修改。

#### 内存结构

- 行级锁的管理较为精细，通常会使用**行锁队列（Row Lock Queue）**来进行排队管理。每一行数据在内存中有一个状态指示，表示该行是否已被某个事务锁定。

### **非对象锁（Non-Object Locks）**

非对象锁通常指的是 PostgreSQL 中的一些轻量级锁，如**事务锁**和**元数据锁**，并不直接关联具体的数据对象（例如行或表），而是为事务或系统资源的访问提供同步。

它可以锁定存储在系统表中的任何东西：表空间、订阅、模式、角色、策略、枚举数据类型等等。

#### 内存结构

这些锁的管理不需要关注数据内容的变化，它们通常存储在内存中的**全局锁管理器**中，用于协调不同事务之间的资源竞争。

### **关系拓展锁（Relation Extension Locks）**

关系拓展锁用于控制对关系的扩展（如增加页）。在 Postgres 中，表是由多个数据页组成的，表的大小会随着数据量的增长而增加。关系拓展锁是当系统在对表进行扩展（例如插入大量数据时增加新的页）时需要使用的锁。

#### 内存结构

它主要管理**元数据**，确保在对表进行扩展操作时，多个事务不会互相干扰。

### 页锁（Page Locks）

页锁是在 Postgres 中对**数据页**（Page）加锁的机制。一个数据页通常包含多条记录。页锁是为了防止在修改数据时发生**并发冲突**，尤其是当多条记录位于同一页时。

#### 锁类型

- **PAGE SHARE LOCK**：允许多个事务读取相同数据页，但不能修改。
- **PAGE EXCLUSIVE LOCK**：当一个事务对数据页进行修改时，其他事务无法读取该页。

#### 内存结构

- 页锁通常通过**数据页管理**来进行管理。每一页上都会有锁记录，以确保其他事务对该页的访问受到控制。

### 咨询锁（Advisory Locks）

咨询锁是 PostgreSQL 提供的一种显式控制锁，允许应用程序自行管理锁，适用于**应用程序级别的同步**。它们并不与行或表的操作直接相关，而是用于在事务之间实现一些轻量级的同步机制。

#### 锁类型

- **pg_advisory_lock**：用于获取一个会话级别的锁，只会在当前会话中有效。
- **pg_advisory_try**：如果可以无需等待，便获取锁。
- **pg_advisory_unlock**：释放锁。
- **pg_advisory_share**：使用共享锁模式 (默认情况下，使用独占模式)。
- **pg_advisory_xact_lock**：在事务级别获取锁，事务结束时会自动释放。

#### 内存结构

- 存储在共享内存中，便于在不同进程之间共享和管理。

### 谓词锁（Predicate Locks）

谓词锁是对**查询条件的锁定**，它是基于**查询的谓词**（即 WHERE 条件）来进行锁定的一种机制。此锁防止其他事务修改与当前事务查询条件匹配的数据行，确保事务的一致性和隔离性。

#### 内存结构

- 谓词锁在内存中会生成一个**锁定条件**，与查询的具体谓词（例如 WHERE 子句）相关联。

#### 应用场景

- **Serializable Isolation Level** 下，数据库会对满足查询条件的所有行进行锁定，即使这些行尚未被选中，也会被锁定，以防止其他事务插入、删除或更新可能影响当前查询的行。