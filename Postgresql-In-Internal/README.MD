[PostgresSQL 的官方文档](https://www.postgresql.org/docs/)

## 页剪枝和HOT更新

在 PGSQL ，**页剪枝**（Page Pruning）和**HOT更新**（Heap-Only Tuple Update）是用于优化存储和提高性能的重要机制。

**页剪枝（Page Pruning）：**

当数据库读取或更新堆页面时，可能会执行快速清理或修剪操作，以回收空间并提高存储效率。 这种操作通常在以下情况下发生：

1. 访问页面时，发现之前的更新操作在当前页面上没有找到足够的剩余空间。 在这种情况下，页面头部可能被设置了 `PD_PAGE_FULL` 标志，指示该页面已满。下次访问该页面时，根据这个标志进行修剪操作，以回收空间。
2. 访问页面时，发现页面中的剩余空间不满足填充因子的要求，或者小于页面大小的 10%。 例如，在创建表时，可以通过 `WITH fillfactor = 75` 来设置填充因子。 如果页面的剩余空间低于此阈值，系统可能会进行修剪操作。

**页剪枝的主要目的是通过清理无效或过时的元组，释放页面空间，从而提高数据库的存储效率和查询性能。** 

**HOT更新（Heap-Only Tuple Update）：**

在传统的数据库更新操作中，更新一行数据通常会在表中插入一个新版本的行，并在相关索引中添加新的索引项。 这种方式可能导致索引的频繁更新，增加存储开销，并降低性能。

为了解决这个问题，PostgreSQL 引入了 [HOT 更新技术](https://postgres.ac.cn/docs/current/storage-hot.html)。当更新操作满足以下条件时，可以使用HOT更新：

1. 更新不会修改表的索引引用的任何列，包括摘要索引。核心 PostgreSQL 发行版中唯一的摘要索引方法是 [BRIN](https://postgres.ac.cn/docs/current/brin.html)。
2. 包含旧行的页面上有足够的空闲空间可用于存储更新后的新行。

在这种情况下，系统会在同一数据块内存储新行，并让旧行指向新行，形成一个链表结构。 这样，通过索引访问旧行数据时，可以顺着链表找到最新的行版本。 由于新行和旧行位于同一数据块内，且没有修改索引列，因此无需更新索引，从而减少了索引维护的开销，提高了更新操作的性能。 

此外，定期的 `VACUUM` 操作仍然是必要的，以清理不再需要的行版本，保持数据库的健康状态。 

## 页分裂

页分裂发生在插入新数据时，索引页面的空间不足以容纳新的记录，从而触发页面分裂的过程：

1. **检测页面空间不足**：
   - 当向B树/B+树插入新数据时，数据库首先寻找合适的页面（叶节点）存储该数据。
   - 如果页面的剩余空间不足以插入新记录，就会触发页分裂。
2. **分裂页面**：
   - 数据库将原有页面中的数据分成两部分，通常按照一定的分裂策略（如中间点）进行划分。
   - 一部分数据保留在当前页面中，另一部分被移动到新创建的页面中。
3. **调整父节点**：
   - 分裂后，会在父节点插入一个新的索引项，以记录新页面的范围。
   - 如果父节点也没有足够的空间存储新的索引项，父节点也可能发生分裂，进一步向上递归，直到根节点。

这就会导致**树的高度增加**，进而导致性能。

性能下降是多方面的：

- 额外的 I/O 和计算开销，包括创建新页面、移动数据、调整索引等。
- 对于频繁发生插入操作的系统，大量页分裂会导致性能显著下降。
- 索引的碎片化，降低查询效率。
- 数据在逻辑上是连续的，但在物理上分布在不同的页面中，导致额外的 I/O。
- 页分裂会创建新的页面，占用更多的存储空间。

解决方案也有如下方案：

1. **合理设置填充因子（Fill Factor）**：如较低的填充因子（如70%-80%）为未来的插入操作预留空间，减少页分裂的发生。
2. **定期维护索引**：使用数据库的`REBUILD`或`REORGANIZE`命令重建索引，减少碎片化。
3. **批量插入**：尽量采用批量插入操作而非单条记录插入，可以降低页分裂的频率。
4. **合理设计主键或索引列**：例如避免使用高随机性的主键（如 GUID），选择自增主键或顺序主键，减少插入时的随机性，从而降低页分裂的概率。
5. **PGSQL 自动清理（Autovacuum 和 VACUUM）**：PostgreSQL 的自动清理机制（`VACUUM` 和 `Autovacuum`）会清理无用的行版本和死索引项，间接地减少页分裂导致的碎片化问题。

> 在进行索引重建时，一般是需要查询索引碎片化指标数据的，以下方式可以查询：
>
> 1. 检查 `pg_stat_all_indexes` 中的索引使用统计。
> 2. 使用 `pg_relation_size()` 查看索引大小。
> 3. 使用 `pgstatindex()` 查看叶节点密度。
> 4. 借助 `pg_bloat_check` 工具估算膨胀比例。
> 5. 查看 `VACUUM VERBOSE` 的输出中索引死元组情况。

## Vacuum 和 Autovacuum

在 PostgreSQL 中，[**VACUUM** 和 **Autovacuum**](https://www.postgresql.org/docs/current/routine-vacuuming.html) 是用于维护数据库健康和性能的重要机制。

### VACUUM

**VACUUM** 命令用于清理表中的死元组（已删除或更新的旧版本行），释放空间供未来使用，并防止表和索引膨胀。

在 PostgreSQL 的多版本并发控制（MVCC）机制下，删除或更新操作不会立即物理移除旧数据，而是将其标记为无效。

因此，定期执行 VACUUM 对于回收存储空间和保持数据库性能至关重要。

VACUUM 的主要功能包括：

- **回收空间**：将死元组占用的空间标记为可重用，以供新数据插入。
- **防止事务 ID 环绕**：通过将旧事务 ID 冻结，避免事务 ID 重用导致的数据可见性问题。
- **更新统计信息**：可选地更新表的统计信息，帮助查询优化器生成更优的执行计划。

需要注意的是，**VACUUM FULL** 会对表进行更彻底的清理，包括重新组织表的数据并释放未使用的空间回操作系统，**但会锁定整个表，可能影响并发操作。** 

### Autovacuum

**Autovacuum** 是 PostgreSQL 的自动清理守护进程，负责在后台自动执行 VACUUM 和 ANALYZE 操作。

它定期扫描数据库中的表，检测需要清理的死元组，并在无需人工干预的情况下执行清理操作。

Autovacuum 的工作机制包括：

- **周期性扫描**：根据配置参数 `autovacuum_naptime`（默认值为 1 分钟），Autovacuum 守护进程会定期唤醒，检查数据库中的表是否需要清理。

- **触发条件**：当表中的死元组数量超过一定阈值时，Autovacuum 会触发 VACUUM 操作。

  该阈值由以下公式确定：

  ```
  复制代码
  autovacuum_vacuum_threshold + autovacuum_vacuum_scale_factor * pg_class.reltuples(表的行数)
  ```

  默认情况下，`autovacuum_vacuum_threshold` 为 50，`autovacuum_vacuum_scale_factor` 为 0.2。 

- **并发工作进程**：Autovacuum 使用多个工作进程并行处理不同的表。

  最大工作进程数由参数 `autovacuum_max_workers` 控制（默认值为 3）。

  每个工作进程在处理表时，会根据表的大小和活动情况决定是否执行 VACUUM 或 ANALYZE。

### 清理阶段

VACUUM 操作通常包括以下阶段：

1. **扫描堆表**：遍历表的所有页面，标记死元组，并可能执行冻结操作。
2. **清理索引**：清理与死元组关联的索引项，确保索引结构的有效性。
3. **清理堆表**：实际删除死元组，并将空间标记为可重用。
4. **截断堆表**：如果表末尾存在连续的空页面，VACUUM 会将其截断，释放空间回操作系统。
5. **最终清理**：更新统计信息和可用空间映射，确保数据库元数据的准确性。

### 管理负载机制

为了避免 VACUUM 操作对数据库性能产生负面影响，PostgreSQL 提供了多种参数来控制其资源消耗：

- **成本延迟机制**：通过设置 `vacuum_cost_delay`（每次达到成本限制后的休眠时间，默认值为 0 毫秒）和 `vacuum_cost_limit`（每个 VACUUM 操作的成本限制，默认值为 200），可以控制 VACUUM 的执行速度，减少对系统性能的影响。

- **自动清理成本参数**：`autovacuum_vacuum_cost_delay` 和 `autovacuum_vacuum_cost_limit` 分别用于控制 Autovacuum 的延迟和成本限制。

  默认情况下，`autovacuum_vacuum_cost_delay` 为 2 毫秒，`autovacuum_vacuum_cost_limit` 为 -1（表示使用 `vacuum_cost_limit` 的值）。

- **工作进程数**：通过调整 `autovacuum_max_workers`，可以控制同时运行的 Autovacuum 工作进程数量。

  需要注意的是，增加工作进程数可能导致每个进程分配的资源减少，应根据系统性能进行合理配置。

通过合理配置这些参数，PostgreSQL 能够在保持数据库性能的同时，自动执行必要的清理操作，确保数据库的高效运行。