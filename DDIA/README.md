# 数据密集型应用系统涉及

## 数据复制

主从复制分为同步和异步分支。

同步复制：在同步操作执行完毕之前，操作一直都是阻塞的。这样已经确认同步就会保证主节点与从节点之间的数据一致性。但是确定也同样明显，就是当节点（主/从）发生错误时（宕机，网络故障等），那么在恢复之前这些节点一直都是处于阻塞状态，不会继而处理其它请求。

异步复制：异步复制则是在开始同步操作时，只需要像客户端确认了写操作，就会返回处理其它的请求。这样节点即使挂掉了，主节点都能继续处理其它请求，这样吞吐率更好。但是伴随而来的是也就无法保证节点之间的数据同步性（一致性）。

所以有些同步措施会采用 ”半同步“ 机制：将其中一个从节点设置为异步复制，其它节点为同步复制，这样就保证了至少两个节点拥有最新的数据副本。

高可用复制过程设计：

1. 在指定一个时间点对主节点的数据进行一致性快照，此时就确定了快照与系统的复制日志索引号相关联。
2. 将快照复制到新的从节点
3. 根据前面获取的日志索引号，从节点请求主节点，将快照之后所发生的数据更改一一进行 “补偿”，同步数据。这一过程被称为追赶。

高可用还要处理失败场景：

从节点失效：我们知道节点是随时可能发生崩溃或者其它故障的，我们可以根据前面的系统复制日志的索引号来查出节点故障前的最后一步执行到哪，然后接着进行 “追赶式恢复”。

主节点失效：当主节点发生崩溃错误失效时，这是我们可以通过[选举](https://github.com/MarsonShine/MS.Microservice/blob/master/docs/patterns-of-distributed-systems/Quorum.md)将其中一个从节点恢复到主节点继续执行复制。这个过程被称为节点切换。

## 如何实现复制日志

第一种就是通过转发相同的操作语句（基于语句的复制）。主节点记录所执行的每个写请求并将该操作语句作为日志转发给从节点。以数据库作为例子，我们每个 INSERT/UPDATE/DLETE 语句都会转发给从节点。

这种方式很简单，但是限制的条件有很多，特别是带状态（副作用）的语句，如获取当前时间 `NOW()`，不同的节点在同步操作产生的数据也会不一致。一般解决方案就是将计算后的一个确定的值转发给其它节点，但是却很难做到将一个带状态变化为一个无状态的。

第二种是通过[预写日志操作](https://github.com/MarsonShine/MS.Microservice/blob/master/docs/patterns-of-distributed-systems/Write-Ahead-Log.md)。简而言之就是将所有操作预先记录在日志种，然后依依复现。

## 带来的新问题

主从复制肯定会带来 “滞后问题”。因为执行同步的时间不固定，特别是在主节点在写操作之后，从节点请求主节点复制数据同步完成之前，读请求过来就会导致数据不一致的情况。这是正常也是必然的，这是一个暂时的状态，但是我们如何将这种情况降至最低呢？

### 读自己的写

首先要确认一件事，我们以 Mysql 的主从复制场景举例。像我们做读写分离设置主从库时，一般将主库为写库，从库作为读库。当时我们读取数据在同步数据之后自然能看到数据的一致性。但是如果读取数据发生数据同步完成之前，那么就会产生令人错误的结果。所以这个时候我们需要 “写后读一执行”，这种机制表示用户查询的数据都是自己提交写的数据，能看到最新的数据。那么如何实现**写后读一致性**呢？

首先我们可以将数据提前分类，即分清楚那些数据是不需要实时性敏感的，把这种数据我们都用从库来读。而那种实时性非常敏感的，需要看到修改后的数据，我们则可以继续用主库读取数据。

还有一种方案，就是将数据 ”时间轴化“，将密集型的数据（如根据更新时间的大与小来决定）用主库来查询，如查询更新后的一分钟内用主库查询。但是这又带来了另一种（更新时间）负面状态信息，特别是在分布式下，不同的机器是无法知道另一机器的更新时间的，所以我们需要将这些信息共享化，如存放到 redis。

### 单调读

继续思考这种场景：在分布式场景中，假设有一个主节点，3 个从节点。现在主节点插入了一个数据，此时从节点1 数据复制完成，用户查询节点 1 能查到主节点插入请求的数据。而此时节点 2 和节点 3 的用户查询该数据却为空。特别是当写操作的主节点的用户与查询节点2 和 3 的用户都是同一个人，那问题就体现得更严重的。其解决方案就是读数据时，**单调读保证**：即确保每个用户都是从固定的统一副本读取的，当这个节点发生失效时，用户查询则就转角给其他工作的另一个节点。

### 前缀一致性读

数据读写一般都具有顺序性，而前缀一致性读就是**保证了对于一系列按照某个顺序发生的请求，在读取的时候也是按照当时写入的顺序。**