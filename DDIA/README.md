# 数据密集型应用系统涉及

## 数据复制

主从复制分为同步和异步分支。

同步复制：在同步操作执行完毕之前，操作一直都是阻塞的。这样已经确认同步就会保证主节点与从节点之间的数据一致性。但是确定也同样明显，就是当节点（主/从）发生错误时（宕机，网络故障等），那么在恢复之前这些节点一直都是处于阻塞状态，不会继而处理其它请求。

异步复制：异步复制则是在开始同步操作时，只需要像客户端确认了写操作，就会返回处理其它的请求。这样节点即使挂掉了，主节点都能继续处理其它请求，这样吞吐率更好。但是伴随而来的是也就无法保证节点之间的数据同步性（一致性）。

所以有些同步措施会采用 ”半同步“ 机制：将其中一个从节点设置为异步复制，其它节点为同步复制，这样就保证了至少两个节点拥有最新的数据副本。

高可用复制过程设计：

1. 在指定一个时间点对主节点的数据进行一致性快照，此时就确定了快照与系统的复制日志索引号相关联。
2. 将快照复制到新的从节点
3. 根据前面获取的日志索引号，从节点请求主节点，将快照之后所发生的数据更改一一进行 “补偿”，同步数据。这一过程被称为追赶。

高可用还要处理失败场景：

从节点失效：我们知道节点是随时可能发生崩溃或者其它故障的，我们可以根据前面的系统复制日志的索引号来查出节点故障前的最后一步执行到哪，然后接着进行 “追赶式恢复”。

主节点失效：当主节点发生崩溃错误失效时，这是我们可以通过[选举](https://github.com/MarsonShine/MS.Microservice/blob/master/docs/patterns-of-distributed-systems/Quorum.md)将其中一个从节点恢复到主节点继续执行复制。这个过程被称为节点切换。

## 如何实现复制日志

第一种就是通过转发相同的操作语句（基于语句的复制）。主节点记录所执行的每个写请求并将该操作语句作为日志转发给从节点。以数据库作为例子，我们每个 INSERT/UPDATE/DLETE 语句都会转发给从节点。

这种方式很简单，但是限制的条件有很多，特别是带状态（副作用）的语句，如获取当前时间 `NOW()`，不同的节点在同步操作产生的数据也会不一致。一般解决方案就是将计算后的一个确定的值转发给其它节点，但是却很难做到将一个带状态变化为一个无状态的。

第二种是通过[预写日志操作](https://github.com/MarsonShine/MS.Microservice/blob/master/docs/patterns-of-distributed-systems/Write-Ahead-Log.md)。简而言之就是将所有操作预先记录在日志种，然后依依复现。

## 带来的新问题

主从复制肯定会带来 “滞后问题”。因为执行同步的时间不固定，特别是在主节点在写操作之后，从节点请求主节点复制数据同步完成之前，读请求过来就会导致数据不一致的情况。这是正常也是必然的，这是一个暂时的状态，但是我们如何将这种情况降至最低呢？

### 读自己的写

