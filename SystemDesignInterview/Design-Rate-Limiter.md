# 设计一个限流器

在网络系统中，限流器用于控制客户端或服务发送的流量速率。在HTTP世界中，限流器限制客户端请求在指定时间内允许发送的数量。如果API请求计数超过限流器定义的阈值，则所有多余的调用将被阻止。以下是一些例子：

- 用户每秒钟只能写入不超过2篇帖子。 
- 您可以从同一个IP地址每天创建最多10个帐户。
- 您每周最多可以从同一设备领取5次奖励。

首先来看下限流器的好处：

- 防止由拒绝服务（DoS）攻击引起的资源饥饿。几乎所有大型技术公司发布的API都强制执行某种形式的限流。例如，Twitter 将推文数量限制为每 3 小时 300 条。Google 文档 API 的默认限制如下：每个用户每60秒钟最多为 300 个读请求。限流器通过阻止超量调用来防止 DoS 攻击，无论是故意的还是无意的。
- 减少成本。限制超量请求意味着减少服务器数量，并将更多资源分配给高优先级的 API。限流对于使用付费第三方 API 的公司非常重要。例如，对于以下外部 API：检查信用，进行付款，检索健康记录等，您按每个调用收费。限制调用次数对于降低成本至关重要。
- 防止服务器过载。为了减少服务器负载，使用限流器过滤由机器人或用户行为不当引起的超量请求。

## 限流器应该放在哪里？

直观地说，你可以在客户端或服务器端实现一个限流器。
- 客户端实施。一般来说，客户端是一个不可靠的地方来执行限流，因为客户端的请求很容易被恶意行为者伪造。此外。我们可能无法控制客户端的实现。
- 服务器端的实现。下图显示了一个放在服务器上的限流器端。

![](./asserts/server-rate-limiter.jpg)

除了客户端和服务器端的实现，还有另一种方法。我们不在 API 服务器上设置限流器，而是创建一个限流器的中间件，它可以对你的 API 的请求进行节流，如下图所示。

![](./asserts/middleware-rate-limiter.jpg)

让我们用下图中的一个例子来说明限流在这种设计中是如何工作的。

![](./asserts/middleware-rate-limiter-example1.jpg)

假设我们的 API 允许每秒2个请求，而一个客户在一秒钟内向服务器发送了 3个请求。前两个请求被路由到 API 服务器。然而，限流器中间件会对第三个请求进行节流，并返回HTTP 状态代码 429。HTTP 429 响应状态代码表明用户发送了太多的请求。

云微服务已经广泛流行，限流通常在一个叫做 API 网关的组件中实现。API 网关是一个完全可管理的服务，支持限流、SSL 终止、认证、IP 白名单、服务静态内容等。现在，我们只需要知道，API 网关是一个支持限流的中间件。

在设计限流器时，要问自己的一个重要问题是：限流器应该在哪里实现，在服务器端还是在网关中？这没有绝对的答案。这取决于你公司目前的技术栈、工程资源、优先级、目标等。这里有一些一般的指导方针:

- 评估你目前的技术栈，如编程语言，缓存服务等。确保你目前的编程语言能够有效地在服务器端实现限流。
- 确定适合你的业务需求的限流算法。 当你实施一切都在服务器端实现，你可以完全控制算法。一切都在服务器端实现的话，你可以完全控制算法。然而，如果你使用的是第三方网关，你的选择可能是有限的。
- 如果你已经使用了微服务架构，并在设计中包含了一个 API 网关，以执行认证、IP 白名单等。你可以在 API 网关上添加一个限流器。
- 建立你自己的限流服务需要时间。如果你没有足够的工程资源来实现一个限流器，商业 API 网关是一个更好的选择。

## 限流算法

速率限制可以使用不同的算法实现，每种算法都有其独特的优缺点。尽管本章不专注于算法，但对其进行高层次的理解有助于选择适合我们使用情况的正确算法或算法组合。以下是一些流行算法的列表：

- 令牌桶（Token bucket）
- 漏桶算法（Leaking bucket）
- 固定窗口计数（Fixed window counter）
- 滑动窗口日志（Sliding window log）
- 滑动窗口计数（Sliding window counter）

### 令牌桶算法

令牌桶算法广泛用于速率限制。它是简单、易于理解的，被许多互联网公司广泛采用。AWS 和 Stripe 都使用这个算法来限制其 API 请求。

![](./asserts/token-buket-alg.jpg)

​														(图4)

令牌桶算法的工作方式如下：

- 令牌桶是一个预定义容量的容器。令牌以固定的速率定期放入桶中。一旦桶满了，就不再添加令牌。如图4所示，令牌桶容量为 4。填充器（refiller）每秒向桶中放入 2 个令牌。一旦桶满了，额外的令牌就会溢出。

- 每个请求消耗一个令牌。当一个请求到达时，我们检查桶中是否有足够的令牌。图5解释了它是如何工作的。

  - 如果有足够的令牌，我们为每个请求取出一个令牌，然后请求通过。
  - 如果没有足够的令牌，则请求被抛弃。

  ![](./asserts/token-buket-alg-flow.jpg)

  ​															(图5)

  图6说明了令牌消耗、补给和速率限制逻辑是如何工作的。在这个例子中，桶的大小是4，补给率是每1分钟4个。

  ![](./asserts/rate-limiter-example2.jpg)


令牌桶算法需要两个参数： 

- 桶的大小（bucket size）：桶中允许的最大令牌数。

- 补充速率（refill rate）：每秒放入桶中的令牌数量。 

我们需要多少个桶？这取决于限速规则，以下是一些例子： 

  - 通常需要为不同的 API 端点使用不同的令牌桶。例如，如果允许用户每秒发1篇帖子、每天添加150个好友和每秒点赞5个帖子，则每个用户需要3个桶。

- 如果我们需要根据IP地址限制请求速率，则每个IP地址需要一个桶。
  
- 如果系统允许每秒最多10,000个请求，则有一个全局桶供所有请求共享是有意义的。
  

优点：
- 该算法易于实现。

- 内存高效。

- 令牌桶允许短时间内的流量突发。只要有剩余的令牌，请求就可以通过。

缺点：

- 算法中的两个参数是桶的大小和令牌填充率。然而，适当地调整它们可能是一个挑战。
  

### 漏桶算法

  

  

  