# 设计一个限流器

在网络系统中，限流器用于控制客户端或服务发送的流量速率。在HTTP世界中，限流器限制客户端请求在指定时间内允许发送的数量。如果API请求计数超过限流器定义的阈值，则所有多余的调用将被阻止。以下是一些例子：

- 用户每秒钟只能写入不超过2篇帖子。 
- 您可以从同一个IP地址每天创建最多10个帐户。
- 您每周最多可以从同一设备领取5次奖励。

首先来看下限流器的好处：

- 防止由拒绝服务（DoS）攻击引起的资源饥饿。几乎所有大型技术公司发布的API都强制执行某种形式的限流。例如，Twitter 将推文数量限制为每 3 小时 300 条。Google 文档 API 的默认限制如下：每个用户每60秒钟最多为 300 个读请求。限流器通过阻止超量调用来防止 DoS 攻击，无论是故意的还是无意的。
- 减少成本。限制超量请求意味着减少服务器数量，并将更多资源分配给高优先级的 API。限流对于使用付费第三方 API 的公司非常重要。例如，对于以下外部 API：检查信用，进行付款，检索健康记录等，您按每个调用收费。限制调用次数对于降低成本至关重要。
- 防止服务器过载。为了减少服务器负载，使用限流器过滤由机器人或用户行为不当引起的超量请求。

## 限流器应该放在哪里？

直观地说，你可以在客户端或服务器端实现一个限流器。
- 客户端实施。一般来说，客户端是一个不可靠的地方来执行限流，因为客户端的请求很容易被恶意行为者伪造。此外。我们可能无法控制客户端的实现。
- 服务器端的实现。下图显示了一个放在服务器上的限流器端。

![](./asserts/server-rate-limiter.jpg)

除了客户端和服务器端的实现，还有另一种方法。我们不在 API 服务器上设置限流器，而是创建一个限流器的中间件，它可以对你的 API 的请求进行节流，如下图所示。

![](./asserts/middleware-rate-limiter.jpg)

让我们用下图中的一个例子来说明限流在这种设计中是如何工作的。

![](./asserts/middleware-rate-limiter-example1.jpg)

假设我们的 API 允许每秒2个请求，而一个客户在一秒钟内向服务器发送了 3个请求。前两个请求被路由到 API 服务器。然而，限流器中间件会对第三个请求进行节流，并返回HTTP 状态代码 429。HTTP 429 响应状态代码表明用户发送了太多的请求。

云微服务已经广泛流行，限流通常在一个叫做 API 网关的组件中实现。API 网关是一个完全可管理的服务，支持限流、SSL 终止、认证、IP 白名单、服务静态内容等。现在，我们只需要知道，API 网关是一个支持限流的中间件。

在设计限流器时，要问自己的一个重要问题是：限流器应该在哪里实现，在服务器端还是在网关中？这没有绝对的答案。这取决于你公司目前的技术栈、工程资源、优先级、目标等。这里有一些一般的指导方针:

- 评估你目前的技术栈，如编程语言，缓存服务等。确保你目前的编程语言能够有效地在服务器端实现限流。
- 确定适合你的业务需求的限流算法。 当你实施一切都在服务器端实现，你可以完全控制算法。一切都在服务器端实现的话，你可以完全控制算法。然而，如果你使用的是第三方网关，你的选择可能是有限的。
- 如果你已经使用了微服务架构，并在设计中包含了一个 API 网关，以执行认证、IP 白名单等。你可以在 API 网关上添加一个限流器。
- 建立你自己的限流服务需要时间。如果你没有足够的工程资源来实现一个限流器，商业 API 网关是一个更好的选择。

## 限流算法

限流可以使用不同的算法实现，每种算法都有其独特的优缺点。尽管本章不专注于算法，但对其进行高层次的理解有助于选择适合我们使用情况的正确算法或算法组合。以下是一些流行算法的列表：

- 令牌桶（Token bucket）
- 漏桶算法（Leaking bucket）
- 固定窗口计数（Fixed window counter）
- 滑动窗口日志（Sliding window log）
- 滑动窗口计数（Sliding window counter）

### 令牌桶算法

令牌桶算法广泛用于限流。它是简单、易于理解的，被许多互联网公司广泛采用。AWS 和 Stripe 都使用这个算法来限制其 API 请求。

![](./asserts/token-buket-alg.jpg)

​							(图4)

令牌桶算法的工作方式如下：

- 令牌桶是一个预定义容量的容器。令牌以固定的速率定期放入桶中。一旦桶满了，就不再添加令牌。如图4所示，令牌桶容量为 4。填充器（refiller）每秒向桶中放入 2 个令牌。一旦桶满了，额外的令牌就会溢出。

- 每个请求消耗一个令牌。当一个请求到达时，我们检查桶中是否有足够的令牌。图5解释了它是如何工作的。

  - 如果有足够的令牌，我们为每个请求取出一个令牌，然后请求通过。
  - 如果没有足够的令牌，则请求被抛弃。

  ![](./asserts/token-buket-alg-flow.jpg)

  ​								(图5)

  图6说明了令牌消耗、补给和限流逻辑是如何工作的。在这个例子中，桶的大小是4，补给率是每1分钟4个。

  ![](./asserts/rate-limiter-example2.jpg)


  ​							（图7）

令牌桶算法需要两个参数： 

- 桶的大小（bucket size）：桶中允许的最大令牌数。

- 补充速率（refill rate）：每秒放入桶中的令牌数量。 

我们需要多少个桶？这取决于限速规则，以下是一些例子： 

  - 通常需要为不同的 API 端点使用不同的令牌桶。例如，如果允许用户每秒发1篇帖子、每天添加150个好友和每秒点赞5个帖子，则每个用户需要3个桶。

- 如果我们需要根据IP地址限制请求速率，则每个IP地址需要一个桶。

- 如果系统允许每秒最多10,000个请求，则有一个全局桶供所有请求共享是有意义的。


优点：
- 该算法易于实现。

- 内存高效。

- 令牌桶允许短时间内的流量突发。只要有剩余的令牌，请求就可以通过。

缺点：

- 算法中的两个参数是桶的大小和令牌填充率。然而，适当地调整它们可能是一个挑战。


### 漏桶算法

漏桶算法类似于令牌桶算法，但请求是以固定速率进行处理的。它通常使用先进先出（FIFO）队列实现。算法的工作方式如下：

- 当请求到达时，系统会检查队列是否已满。如果队列未满，则将请求添加到队列中。
- 否则，请求将被丢弃。
- 请求将定期从队列中拉出并进行处理。
- 图8 解释了该算法的工作原理。

![](./asserts/leaking-bucket-alg.jpg)

  漏桶算法有两个参数：

- **桶大小（bucket size）**：等于队列大小。队列保留要以固定速率处理的请求。
- **流出速率（outflow rate）**：定义了在固定速率下可以处理多少个请求，通常以秒为单位。

电商公司 Shopify 使用漏桶算法进行限流。

**优点：**

- 鉴于队列大小有限，内存效率高。
- 请求以固定速率处理，因此适用于需要稳定流出速率的用例。

**缺点：**

- 突发的流量会填满队列，导致旧请求未能及时处理，而最近的请求会受到限流。
- 算法有两个参数。可能不容易正确地调整它们。

### 固定窗口计数算法

固定窗口计数器算法的工作原理如下：

- 算法将时间轴分成固定大小的时间窗口，并为每个窗口分配一个计数器。

- 每个请求将计数器加一。

- 一旦计数器达到预定义的阈值，新请求将被丢弃，直到开始一个新的时间窗口。

让我们使用一个具体的例子来看看它是如何工作的。在图9中，时间单位为1秒，系统允许每秒最多3个请求。在每个秒窗口中，如果收到超过3个请求，则额外的请求将被丢弃，如图9所示。

![](./asserts/fixed-windows-counter-alg.jpg)

  这个算法的一个主要问题是，**在时间窗口的边缘出现大量的流量可能会导致超过允许配额的请求数量通过**。考虑以下情况：

![](./asserts/fixed-window-counter-alg-exa1.jpg)

在上图中，系统每分钟允许最多5个请求，并且可用配额在以人类友好的整分钟为单位重置。如图所示，在`2:00:00`和`2:01:00`之间有五个请求，在`2:01:00`和`2:02:00`之间又有五个请求。对于`2:00:30`到`2:01:30`之间的一分钟窗口，有10个请求通过。这是允许请求数量的两倍。

**优点：**

- 内存高效
- 易理解
- 在一个时间窗口结束时重置可用配额适用于某些使用情况

**缺点：**

- 时间窗口的边缘出现流量激增可能会导致超出允许配额的请求被执行。

### 滑动窗口日志算法

正如之前讨论的，固定时间窗口计数器算法存在一个重大问题：**它允许更多的请求在时间窗口的边界通过**。滑动时间窗口日志算法解决了这个问题。它的工作原理如下：

- 该算法跟踪请求的时间戳。时间戳数据通常存储在缓存中，如 Redis 的排序集合。
- 当新的请求到来时，删除所有过时的时间戳。过时的时间戳被定义为早于当前时间窗口开始的时间戳。
- 将新请求的时间戳添加到日志中。
- 如果日志的大小与允许的计数相同或更低，则接受请求。否则，将其拒绝。
- 我们通过下图中的示例来解释算法。

![](./asserts/slider-windows-log-alg.jpg)

在这个例子中，限流器每分钟允许2个请求。通常情况下，日志中存储的是 Linux 时间戳。然而，在这个例子中，我们使用人类可读的时间表示来提高可读性。

- 当一个新的请求在`1:00:01`到达时，日志是空的。因此，该请求被允许。

- 一个新请求在`1:00:30`到达，时间戳`1:00:30`被插入日志中。插入后，日志大小为2，小于允许的请求数量。因此，该请求被允许。

- 一个新请求在`1:00:50`到达，时间戳被插入到日志中。插入后，日志大小为3，大于允许的大小2。因此，即使时间戳仍然存在于日志中，此请求被拒绝。

- 一个新请求在`1:01:40`到达。在`[1:00:40,1:01:40)`范围内的请求仍处于最新时间框架内，但在`1:00:40`之前发送的请求已过期。日志中删除了两个过期的时间戳，`1:00:01`和`1:00:30`。删除操作后，日志大小变为2；因此，该请求被接受。


优点：

- 该算法实现的限流非常准确。在任何滚动时间窗口中，请求都不会超过限流。

缺点：

- 该算法消耗大量内存，因为即使一个请求被拒绝，它的时间戳仍然可能存储在内存中。

### 滑动窗口计数算法

滑动窗口计数算法是一种混合方法，将固定窗口计数器和滑动窗口日志相结合。该算法可以通过两种不同的方法实现。本节将解释一种实现方法，并在本节末尾提供另一种实现方法的参考资料。图4-11说明了该算法的工作原理。

![](./asserts/slider-window-counter-exam1.jpg)

假设限流器每分钟允许最多7个请求，上一分钟有5个请求，当前分钟有3个请求。对于一个到达当前分钟的30％位置的新请求，滚动窗口中的请求数量可以使用以下公式计算：

- 当前窗口中的请求 + 上一个窗口中的请求 * 滚动窗口和上一个窗口的重叠百分比
- 使用这个公式，我们得到 3 + 5 * 0.7% = 6.5个请求。根据用例不同，数字可以向上或向下取整。在我们的例子中，它向下取整为6。

由于限流器每分钟最多允许7个请求，所以当前请求可以通过。但是，再接收一个请求后，限制将被达到。

由于空间限制，我们将不在此处讨论其他实现方法。有兴趣的读者可以参考参考资料。该算法并不完美。它有优点和缺点。

**优点：**

- 它平滑了流量峰值，因为速率基于前一个窗口的平均速率。
- 内存使用效率高。

**缺点：**

- 它仅适用于不太严格的回溯窗口。它是实际速率的近似值，因为它假设前一个窗口中的请求均匀分布。然而，这个问题可能没有看起来那么糟糕。根据 Cloudflare 进行的实验，在4亿个请求中，只有0.003％的请求被错误地允许或限制速率。

## 高维度架构

限流算法的基本思想很简单。**在高层面上，我们需要一个计数器来跟踪来自同一用户、IP地址等的请求发送次数。如果计数器大于限制，则拒绝该请求。**
我们应该在哪里存储计数器？使用数据库不是一个好主意，因为磁盘访问速度慢。选择内存缓存是因为它快速，并支持基于时间的过期策略。例如，Redis 是实现限流的流行选项。它是一个内存存储器，提供两个命令：`INCR` 和 `EXPIRE`。
• INCR：它将存储的计数器增加1。
• EXPIRE：它为计数器设置超时。如果超时到期，则计数器将自动删除。

图12展示了高层面架构的限流，以及是如何工作的：

![](./asserts/high-level-architecture-rate-limite.jpg)

- 客户端发送请求给限流器中间件
- 限流中间件从 Redis 中相应桶（bucket）中获取计数器，并检查是否达到限制。
  - 如果达到限制，请求将被拒绝。
  - 如果未达到限制，则请求将被发送到 API 服务器。同时，系统会增加计数器并将其保存回 Redis。

## 第三步——设计深入讨论

上图12的高级设计中并没有讨论以下这些问题：

- 如何创建限流规则？规则存储在哪里？
- 如何处理受限流的请求？

在本节中，我们将首先回答有关限流规则的问题，然后介绍处理受限流请求的策略。最后，我们将讨论分布式环境中的限流、详细的设计、性能优化和监控。

### 限流规则

[Lyft 开源了他们的限流组件](https://github.com/envoyproxy/ratelimit)。我们将进入组件内部，查看一些限流规则的示例：

```yaml
domain: messaging
descriptors:
 - key: message_type
 Value: marketing
 rate_limit:
 unit: day
 requests_per_unit: 5
```

在上面的示例中，系统配置为每天最多允许 5 条营销短信。以下是另一个示例：

```yaml
domain: auth
descriptors:
 - key: auth_type
 Value: login
 rate_limit:
 unit: minute
 requests_per_unit: 5
```

此规则显示，客户端在1分钟内不得登录超过5次。规则通常编写在配置文件中并保存在磁盘上。

### 超出限流限制

如果请求被限流，API 将向客户端返回 HTTP 响应代码 429（太多请求）。根据使用情况，我们可能会将受限流的**请求排队**以待后续处理。例如，如果由于系统负载过高而导致某些订单受到限流，我们可能会保留这些订单以待后续处理。

### 限流器头部信息

客户端如何知道自己被限制了？客户端如何知道在被限制之前允许的剩余请求数量？答案在于HTTP响应头。限流器向客户端返回以下HTTP头：
`X-Ratelimit-Remaining`：窗口内允许的剩余请求次数。
`X-Ratelimit-Limit`：指示客户端可以每个时间窗口进行多少次调用。
`X-Ratelimit-Retry-After`：等待多少秒后可以再次发出请求而不被限制。
当用户发送了太多请求时，将向客户端返回 429 太多请求错误和 `X-Ratelimit-Retry-After` 头信息。

### 详细设计

图13是系统的详细设计：

![](./asserts/rate-limiter-design-detail)

规则存储在磁盘上。Worker经常从磁盘中拉取规则并将其存储在缓存中。

- 当客户端向服务器发送请求时，请求首先发送到限流中间件。
- 限流中间件从缓存中加载规则。**它从 Redis 缓存中获取计数器和上次请求的时间戳**。基于响应，限流器决定：
  - 如果请求未被限流，则将其转发到API服务器。
  - 如果请求被限制，则限流器向客户端返回429太多请求错误。同时，请求要么被丢弃，要么转发到队列。

### 在分布式的限流器

在单个服务器环境中构建有效的限流器并不困难。但是，将系统扩展以支持多个服务器和并发线程则是另一回事。

存在两个挑战：

- 竞争条件
- 同步问题

#### 竞争条件

如前所述，限流器在高层次上的工作方式如下：

- 从 Redis 中读取计数器值。
- 检查（计数器+1）是否超过阈值。
- 如果没有，将计数器值在 Redis 中增加1。

在高度并发的环境中，可能会发生竞争条件，如图4-14所示。

![](./asserts/rate-limiter-in-distribution.jpg)

假设 Redis 中计数器的值为 3。如果两个请求同时读取计数器的值，然后在它们中的任意一个将值写回 Redis 之前，它们都会将计数器加一并写回，而不会检查另一个线程。这两个请求（线程）都认为它们有正确的计数器值 4。然而，正确的计数器值应该是 5。

锁是解决竞态条件最明显的解决方案。然而，锁会显著减慢系统。常用的两种策略用于解决这个问题：**Lua 脚本**和 **Redis 中的排序集合数据结构**。对于对这些策略感兴趣的读者，可以参考[相应的](https://gist.github.com/ptarjan/e38f45f2dfe601419ca3af937fff574d#request-rate-limiter)[参考材料](https://engineering.classdojo.com/blog/2015/02/06/rolling-rate-limiter/)。

#### 同步问题

在分布式环境中，同步是另一个需要考虑的重要因素。为了支持数百万用户，一个限流服务器可能不足以处理这么多流量。当使用多个限流服务器时，需要进行同步。例如，图4-15左侧，客户端1向限流器1发送请求，客户端2向限流器2发送请求。由于Web层是无状态的，客户端可以向不同的限流器发送请求，如图4-15右侧所示。如果没有进行同步，限流器1不包含有关客户端2的任何数据。因此，限流器无法正常工作。

![](./asserts/rate-limiter-sync1.jpg)

​							（图15）

一个可能的解决方案是使用**粘性会话(sticky sessions)**，允许客户端将流量发送到相同的限流器。这种解决方案不可取，因为它既不可扩展也不灵活。更好的方法是使用像 Redis 这样的集中式数据存储。其设计如图4-16所示。

![](./asserts/rate-limiter-sync2.jpg)

#### 性能优化

性能优化是系统设计面试中常见的话题。我们将介绍两个改进领域。

首先，对于限流器而言，**多数据中心**设置非常重要，因为远离数据中心的用户的延迟很高。大多数云服务提供商在全球各地建立了许多边缘服务器位置。例如，截至2020年5月20日，Cloudflare 拥有194个地理分布的边缘服务器。流量会自动路由到最近的边缘服务器以减少延迟。

第二个是，采用最终一致性模型来同步数据。如果对最终一致性模型不清楚，可以参考[“第6章：设计一个键-值存储”]()中的“一致性”部分。

## 监控

在实施限流器后，重要的是收集分析数据以检查限流器是否有效。主要目的是确保：

- 限流算法是有效的。
- 限流规则是有效的。

例如，如果限流规则太严格，可能会丢弃许多有效请求。在这种情况下，我们需要稍微放宽规则。另一个例子是，我们发现当有突发流量（如闪购）时，限流器变得无效。在这种情况下，我们可以更换算法以支持突发流量，令牌桶是一个不错的选择。

## 第四步——总结

在本章中，我们讨论了不同的限流算法及其优缺点。讨论的算法包括：

- 令牌桶
- 漏桶
- 固定窗口
- 滑动窗口日志
- 滑动窗口计数器

然后，我们讨论了系统架构、分布式环境中的限流器、性能优化和监控。类似于任何系统设计面试问题，如果时间允许，您可以提及其他谈话要点：

- 硬性与软性限流。
- 硬性：请求数量不能超过阈值。
- 软性：请求可以在短时间内超过阈值。
- 在不同的层级进行限流。在本章中，我们只讨论了应用层（HTTP：第7层）的限流。也可以在其他层应用限流。例如，可以使用 `Iptables`（IP：第3层）按IP地址进行限流。

注意：开放式系统互连模型（OSI模型）有7层：第1层：物理层，第2层：数据链路层，第3层：网络层，第4层：传输层，第5层：会话层，第6层：表示层，第7层：应用层。

避免被限流。以最佳实践设计客户端：

- 使用客户端缓存避免频繁调用API。
- 理解限制，并不要在短时间内发送太多请求。
- 添加捕捉异常或错误的代码，以便您的客户端可以从异常中优雅地恢复。
- 添加足够的回退时间来重试逻辑。