# 浮点数（float）

我们知道整数应用一般是用在计数居多。先是绝大多数其实是实数计算。包括日常收银，价格计算等。

而且我们在开发过程中，我们经常会遇到关于浮点数的一些问题，如我们在浏览器console中输入如下计算表达式：

```
0.33+0.5
// 输出0.83?
```

我们第一反应输出的肯定是0.83。实则不是，我们在浏览器执行就会发现实际输出的是`0.8300000000000001`。那这是怎么回事呢？

## 定点表示法

其实表示小数位有两种方式，一种就是定点表示法。这种表示方法简单易懂，跟二进制与十进制的表示法一样。举个例子，有一个小数点`12.34`。那么我们就会以小数点为分界线，左边就是10的正数幂，右边就是负数幂。那么换算出来就是：

$1*10^1+2*10^0+3*10^{-1}+4*10^{-2} = 12\frac{34}{100}$

上面的是十进制的计算方式。假设我们有这样一个二进制小数`110.011`，这样我们用二进制表示就是：

$$1*2^2+1*2^1+0*2^0+0*2^{-1}+1*2^{-2}+1*2^{-3}\\=4+2+0+0+\frac{1}{4}+\frac{1}{8}=6\frac{3}{8}$$

这种方式虽然简单，但是却有很多缺点：

- 我们无法表示除2的次幂的数，如$\frac{1}{3}$,$\frac{5}{7}$等
- 这种表示法只能适用在范围有限的场景下。试想下十位数`12`占据了4位（1100），如果是$n*2^i,i > 100$这种情况是不是要在n的后面增加至少100个0位呢？

所以定点表示法无法解决该数范围过大的场景。这种情况就是通过另一种方式表达的：浮点表示法

## 浮点表示法

IEEE给浮点数表示定义了一个标准：

$V=(-1)^s*M*2^E$

- s表示符号位，独占一位
- M表示尾数
- E表示阶码（exponent）

其中M与E都有各自的计算方式。如k位的阶码字段$E=e_{k-1}*e_{k-2}...*e_2*e_1*e_0$。

M尾数的计算方式，假设有n位小数，其M的值为：$M=f_{n-1}*...*f_2*f_1*f_0$

这里还有偏置量的概念，我们将偏置量用Offset来表示，即$offset=2^{k-1}-1,E=e-offset$

要注意阶码，M的最后求值是依赖于**浮点数的规格分类**的。

在32位系统中，float格式一般符号位占1位，阶码占8位，有效位（尾数）占23位。

在64位系统中，float格式符号位占1位，阶码占11位，尾数占52位。

### 浮点数规格分类

根据阶码的值，可以把浮点数分为三类

1. 规格化的值

   就是说阶码值的所有位既不全是0，也不全是1

2. 非规格化的值

   阶码值全为0表示非规格化

3. 特殊值

   特殊值是当阶码值全为1时。又分为两类

   1. 尾数全为0，则表示无穷
   2. 尾数非0时，则表示NaN（非数字）

浮点数规则的类别对浮点表示法有什么影响呢？

当浮点数是规格化值时，$M = 1 + f,E=e-offset$

当浮点数是非规格化值时，$M = f, E = 1 - offset$

### 实例

给定k=2的阶码位以及n=2的小数位。计算下面表中各个变量的值

| 位数    | e    | E    | $2^E$ | f             | $2^E*M$       | V             | 十进制 |
| ------- | ---- | ---- | ----- | ------------- | ------------- | ------------- | ------ |
| 0 00 00 | 0    | 0    | 1     | $\frac{0}{4}$ | 0             | 0             | 0      |
| 0 00 01 | 0    | 0    | 1     | $\frac{1}{4}$ | $\frac{1}{4}$ | $\frac{1}{4}$ | 0.25   |
| 0 00 10 | 0    | 0    | 1     | $\frac{2}{4}$ | $\frac{2}{4}$ | $\frac{2}{4}$ | 0.5    |
| 0 00 11 | 0    | 0    | 1     | $\frac{3}{4}$ | $\frac{3}{4}$ | $\frac{3}{4}$ | 0.75   |
| 0 01 00 | 1    | 0    | 1     | $\frac{0}{4}$ | $\frac{5}{4}$ | $\frac{5}{4}$ | 1.25   |

上面的各个变量的值其实就是根据前面说到的公式计算而来的。

这里面浮点数其实就两类，前面四个阶码位数全为0，即表示非规格化的值。则带入上面的公式得到相应的结果。后面一个是规格化的值。

## 最后

我们可以直接在这个[网址](https://www.h-schmidt.net/FloatConverter/IEEE754.html)上看出来各个小数对应的位数的值。