# 虚拟内存

在以前都是用的“物理寻址”的方式来传输数据的，CPU 运行加载指令时会生成一个物理地址，通过内存总线传输给主存，主存根据物理地址取出对应的值返回给 CPU，CPU 将值存储到寄存器上。

后来后于运行的数据越来越多，物理内存又是有限的，所以现有的物理内存规格已经完全不满足现有需要了，所以“虚拟内存寻址”的方式出现了。

虚拟内存是通过虚拟地址访问内存，**通过地址翻译硬件根据物理内存中的页面查询映射出真是的物理地址**，然后再将对应的数据返回给 CPU 指寄存器上。

这里还要熟悉几个专有名词：

- VP：VM 系统通过将虚拟内存分割固定尺寸的块称为虚拟页（Virtual Page，VP）
- PP：物理内存被分割固定尺寸的块就被称为物理页（Physical Page，PP），物理页也被称为“页帧”。

虚拟页面总过包括三种状态：

1. 未分配：VM 系统还未分配的页，这不占用任何磁盘空间
2. 缓存的：当前已缓存再物理内存（主存）中的虚拟页
3. 未缓存的：已分配的页但是没有缓存到物理内存上

![](asserts/1605149775.jpg)

例如上图就可以知道，VP 1 是已缓存的，因为在物理内存中的 PP1 中有 VP1。VP0、VP3 等是未分配的，VP2 等是未缓存的。

一般我们通过 DRAM 缓存来描述虚拟内存系统的缓存，SRAM 缓存是 CPU 与主存（L1，L2，L3 ）之间的高速缓存。

## 如何判断物理内存是否已经存在了虚拟内存

那么虚拟内存系统一定是要有某种方法能得知一个虚拟页是否已经缓存到物理内存上的。

就像前面提到的，内存管理单元中的地址翻译硬件根据物理内存中的页面来查询是否缓存在物理内存的。具体如何知道的呢？

首先要了解的是页面是个怎样的数据结构：

![](asserts/1605150253.jpg)

页表就是一个页表条目（Page Tabel Entry，PTE）的数组，每个 PTE 都由一个**有效位**和磁盘地址组成的。其中有效位 0 代表未缓存，1 代表已缓存。

**如果通过页表能查询到对应的物理内存，这就代表页命中。例如 CPU 想读取 VP2 的虚拟内存中的数据，那么这时候地址翻译硬件就会通过页面查询每个页面标目，发现 PTE2 能成功映射对应的物理地址（有效位也为 1）。**

**如果没有查询到对应的物理地址，说明就是缺页（如上图查找的 VP3）。缺页会造成不小的性能损失，会触发一个缺页异常中断信号，内核接受到这个信号找到对应的缺页异常处理程序来处理缺页，该程序会在物理内存中按照一定的算法选择出要替代的页，这被称为“牺牲页”，这个例子选择了 PP3，如果 PP3 中的 VP4 发生了更改，则会将 VP4 回写至磁盘。然后内核会继续将 VP3 从磁盘复制到物理内存的 PP3 中，然后更新对应的页面 PTE3。最后当异常处理程序返回时，重新启动导致缺页的指令，这时该 VP3 已经成功缓存到物理内存，所以会正常处理。**

缺页的这一过程看似是非常损耗性能的，其实由于内存的局部性，它保证了在任意时刻，程序将趋向于在一个较小的活动页面集合上工作，这个集合被称为工作集。初始开销，也就是将工作集页面调度到内存之后，接下来就是对这个工作集的引用的操作，不会产生额外的磁盘 IO。

## 虚拟内存是如何保护进程内存的

前面我们已经知道地址翻译硬件在解析的过程中会读取一个 PTE，那么从这个 PTE 上额外分配位来表示对应的权限，来控制一个虚拟页面内容的访问。其结构如下

![](asserts/1605152453.jpg)

SUP 表示进程是否必须运行在内核模式下才能访问该页面

READ 表示页面读权限

WRITE 表示页面写权限