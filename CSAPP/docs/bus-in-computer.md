# 总线（Bus）

现在我们知道CPU与其它部件交互（如在缓存、外部输入输出设备等）都是通过**总线（Bus）**来完成的。即当CPU需要同某些设备交互的时候，CPU就会向系统总监、内存总线发出信号，说明自己需要什么数据，向谁发送/索要数据与指令；然后由总线将其信息传递给对应的目标设备，最后再经由目标设备将数据信息返回给总线，又由总线将指令/数据返回给CPU。

我们从现在的结果来反推一个问题：为什么多个设备之间的交互要通过一个总线来完成，而不是直接由这些设备自己交互呢？这样在性能比使用总线更高。

我们可以假设采用后者这种设计，在计算机中有很多设备都要彼此之间交互。假设我们现在有N个设备，则就要实现这种功能，就会有$N^2$的实现复杂度。这种复杂度非常高，特别是具体到每个设备的电路设计上。而采用前者通过引入一个公共总线的设计，我们就可以从$N^2$的复杂度陡然下降到$N$。虽然性能上会损失一点，但带来的是设备与设备之间的解藕，提高了可维护性和拓展性。

> 思维发散
>
> 其实这个思路也对应软件设计当中的事件总线（Event Bus）设计模式。事件总线采用的是发布/订阅模式，每个模块可以触发对应的事件，并把事件发布到事件总线上。而各个模块可以也可以自我注册到事件总线上，去监听这个事件。然后根据具体事件对象的内容再来决定是否处理对应的事件处理程序。
>
> 这与计算机中的总线的思想是类似的。

我们用CPU与主存之间交互的过程做个总结：CPU欲向主存取指令/数据，那么CPU就会告诉总线，目标对象是什么（主存）、发送什么数据（指令/数据）。然后由总线向主存索要对应的信息并返回给CPU。

## 总线类别

总线由多个类别：

1. 本地总线（Local Bus）：负责CPU与超速缓存的交互
2. 系统总线（System Bus）：负责CPU与[北桥芯片](https://baike.baidu.com/item/%E5%8C%97%E6%A1%A5/9036718?fromtitle=%E5%8C%97%E6%A1%A5%E8%8A%AF%E7%89%87&fromid=151758)的交互
3. 内存总线（Memory Bus）：负责CPU与主存的交互
4. I/O总线：负责CPU与计算机各个外部的输入输出设备的交互（如鼠标，键盘，显示屏等）

> 知识拓展
>
> 北桥芯片：其实就是一个芯片元件，主要负责与CPU，存储器（高速缓存）的处理。位于CPU附近，所以日常计算量非常大，所以经常发热，所以必须用隔热/散热比较好的部件来覆盖北桥芯片。
>
> [南侨芯片](https://baike.baidu.com/item/%E5%8D%97%E6%A1%A5%E8%8A%AF%E7%89%87/329208?fromtitle=%E5%8D%97%E6%A1%A5&fromid=212130#3)：它的位置就不同于北桥了，它离CPU比较远，主要负责一些低速处理、I/O总线之间的通信。

## 总线的功能组成

前面提到，CPU要与主存之间交互，那么CPU必须要将目标对象、指令、已经具体的数据都要高速总线。所以总线必须要要支撑接受这些信息的元件。

事实上，总线由三类线路：

1. 地址线路：要确定传给谁（即目标地址）
2. 数据线路：要传递的实际具体的数据
3. 控制线路：控制对总线的访问，发送控制信号和时许信号（具体何时执行指令）（比如CPU要与主存交互，就会向控制线路发送一个中断信号，来完成后续的交互）

## 总线仲裁（Bus Arbitration）

总线虽然较少了设备之间的交互复杂度。但同样也带了另一个问题：当有很多设备要同时用到这个公共的总线时，那么这些多个设备都会向总线发送信号；那么总线到底要先处理哪个设备呢？

这就是[总线仲裁](https://en.wikipedia.org/wiki/Arbiter_(electronics))要做的事情了。

> 总线仲裁器是多主总线系统（multi-master bus system）中使用的一种设备，**用于决定每个总线周期允许哪个总线主来控制总线**。最常见的总线仲裁者是系统总线系统中的内存仲裁器（memory arbiter）。
>
> 内存仲裁器是在系统共享内存中使用的一种设备，用于决定在每个内存周期中，哪个CPU将被允许访问该共享内存。
>
> 一些原子操作指令依赖于仲裁，以防止其他cpu在读取原子读-修改-写指令的过程中“半路上”读取内存。
>
> 内存仲裁器通常集成到内存控制器/DMA控制器中。
>
> 在一些系统中（如传统的PCI），有一个单一的集中总线仲裁设备，可以指向它作为“总线仲裁器”。其他系统使用分散总线仲裁，所有设备合作决定谁下一个去。
>
> 当每个CPU都连接到已经同步过内存访问周期的内存仲裁器时，内存仲裁器可以被设计为同步仲裁器。否则，内存仲裁器必须被设计成一个异步仲裁器。

## 现代总线

2008年之后Intel就取消了前端总线（系统总线、内存总线、I/O总线），转而引进了新的技术：[快速通道互联（Quick Path Interconnect，QPI）](https://en.wikipedia.org/wiki/Intel_QuickPath_Interconnect)。

## CPU如何实现控制外部接入设备

以打印机为例，CPU是如何控制这些设备的呢？

首先一般这些输入输出设备都由两个部分构成：1.接口；2.具体的I/O设备；

接口就是一个电路板，制定了一些协议。只要满足了接口的规范，就能通过接口连接总线，再由总线与CPU通信。

这个电路板里面有三个寄存器：1. 状态寄存器；2. 数据寄存器；3. 命令寄存器。

那么CPU控制打印机的过程就是如下：

1. 首先是数据寄存器，CPU向I/O设备写入要要打印的数据（此数据会缓冲到设备内存中）
2. 接着就是命令寄存器，CPU会发送一个打印的命令，告诉打印机要开始打印了。这个时候打印机里面的控制电路就会接受到这个信号去做两件事。1. 设置状态寄存器的值为not-ready。2. 打印具体的内容。
3. 因为第二部会改变状态寄存器中的状态值，所以这个状态寄存器就会告诉CPU当前设备的工作状态，如果处于非ready状态，那么CPU继续发送打印命令都不会有响应（而是转而存进待打印队列中）。直到打印动作完成，将状态设置为ready，才能继续处理下一个。