# 数据传输类指令

`mov s d`：数据传输类指令，是将数据从一个位置复制到另一个位置的指令。都是把**数据从源位置复制到目的位置**

s：源操作数；d：目的操作数

mov 类指令由下面四个指令构成

- `movb	s, d`	传输字节
- `movw    s, d`	传输字
- `movl    s, d`    传输双字
- `movq    s, d`    传输四字
- `movabsq    s, d`    传输绝对四字

> 需要注意的是，源操作数与目标操作数不能同时都是立即数或内存

movz 和 movs 将较小的源值复制到较大的目的时。所有的这些指令都是把**数据从源（寄存器或内存）复制到目的寄存器**

movz 把目的中剩余的字节填充为 0。

movs 通过符号拓展来填充，把源操作从最高位进行复制。这些指令的最后两个字符分别表明源的大小和目标的大小。

```c++
movzbw		将做了零拓展的字节传输到字
movzbl		将做了零拓展的字节传输到双子
movzwl
movzbq
movzwq

movsbw		将做了符号拓展的字节传输到字
movsbl		将做了符号拓展的字节传输到双字
movswl
movsbq
movswq
cltq		把 %eax 符号拓展到 %rax	// cltq 指令只用作与寄存器 %eax 和 %rax
```

## 练习题解析

- `movb		$0xf, (%ebx)`     // ebx 不能用作地址寄存器
  - ebx 对于（x86-64）来说是不能用作地址寄存器的，但是 rbx 是可以的。因为 ebx 是 rbx 的低 32 位，尝试用 32 位寄存器来引用 64 位内存来说毫无意义
- `movl %rax, (%rsp) movb %si, 8(%rbp)` // 指令后缀和寄存器id不匹配
  - 因为使用的指令是 'l'，说明是双字，也就是意味着这是 32 位的。但是 rax 是 64 位寄存器。如果你要写 64 位数据到 rax 上，那么应该使用 `movq`。所以当在 32 位下应该使用指令 `eax`
- `movl %eax, %rdx`     // 目标操作符大小不正确
  - 这个指令意思是尝试将一个 32 位的值传输到 64 位寄存器下。有一些指令可以进行这种转换，但是 movl 这个指令不能做这种转换。