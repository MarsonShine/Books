# 系统级 I/O

健壮性 IO 提供两个特性：

- 无缓冲的输入输出函数。直接在主存和文件之间传输数据，没有应用级缓存。这对**二进制数据读写到网络**和从**网络读写二进制**非常重要。
- 有缓冲的输出输出函数。允许你高效地从文件中读取文本行和二进制数据，这些文件的内容缓存在应用级缓冲区内。减少了系统调用的次数。

对于文件操作来说，系统级 I/O 统一了操作规范：

1. 打开文件，一个应用程序通过内核打开一个文件，用描述符来记录这个文件相关信息。
2. 打开文件有三个标准文件：标准输入、标准输出和标准错误
3. 改变当前文件的位置。每打开一个文件，内核都会记录当前文件位置值 k，当然也可以选择设置位置偏移
4. 读写文件
5. 关闭文件，释放文件占用的资源避免发生内存泄漏

内核利用三个相关的数据结构来共享文件：

- 描述符表(descriptor table) 。每个进程都有一个单独的描述符表，他的表项是由进程打开的文件描述符来索引的。每个打开的描述符表项指向的是文件表的一个表项。
- 文件表(file table)。打开文件的集合是由一张文件表来表示的，所有进程都共享这个表。每个文件表由文件位置、引用计数、以及一个指向 v-node 表的指针。
- v-node 表。同文件表，所有进程都共享这个 v-node 表。每个表项包含 stat 结构中的大多数信息，如文件类型和文件大小等

![](asserts/1605239661.png)

![](asserts/1605239715.jpg)

在读取文件的时候，首先要打开(Open)指定文件 file1获得一个文件描述符 fd1；这个文件描述符是一个数字，记录的是文件表中的表项(也就是文件表的索引)。然后就能根据 fd1 快速找到文件表，里面记录的是 **file1 的位置**、还有**引用该文件的计数器**（假设还有其他进程在访问这个文件，那么这个计数器就会自增）以及一直指向 **v-node 表的表项指针**。

这个 v-node 表记录的就是具体文件的元数据信息，如文件大小、类型、访问模式（只读、写）等。

所以通过这种链接关系，我们就很容易的实现多进程之间的文件共享。例如多个程序访问相同的文件，那么就会有如下关系：

- 两个独立的文件描述符 fd1，fd2。它们分别指向不同的文件表（也有可能指向相通的文件表）
- 文件表里面的 v-node 表项指针指向的是相通的 v-node。

## I/O 流

I/O 标准库将打开的文件抽象为一个流。对于程序而言，**流 = 文件描述符 + 流缓冲区**

流缓冲区的目的与 RIO 的缓冲区目的是一样的，减少 I/O 的系统调用的开销。即一次读一个字节与一次读10个字节到缓冲区，然后后面 9 次读取字节都不需要经过 I/O 的系统调用了。

Linux 内核使用三个相关的数据结构来表示打开的文件。**描述符表中的表项**指向**打开文件表中的表项**，而打开文件表中的表项又指向 **v-node 表中的表项**。

**每个进程都有自己的描述符表，而所有的进程共享同一个文件打开表和 v-node 表**。

## I/O 设备内存访问

I/O 设备访问内存地址主要有三种不同技术。

1. I/O 设备访问内存地址（Programmed I/O）:
   - 在没有 DMA 的情况下，IO 设备通过 CPU 的程序输入/输出（PIO）来进行数据传输。
   - CPU 完全占用整个读取或写入操作的持续时间，无法执行其他工作。
   - 这种方式会导致 CPU 无法跟上数据传输速率，或者需要在相对较慢的 IO 数据传输过程中执行其他工作（整个过程是阻塞的）。
2. I/O 内存映射（Memory-mapped I/O）:
   - I/O 内存映射是一种将设备寄存器映射到 CPU 地址空间的技术，允许 CPU 直接访问设备寄存器，而不需要通过专门的 I/O 指令。
   - 这种技术允许 CPU 像访问内存一样访问设备寄存器，提高了访问效率。
3. DMA（Direct Memory Access）:
   - DMA 允许某些硬件设备直接与主系统内存通信，并在不使用 CPU 处理的情况下传输数据。
   - DMA 机制使得 I/O 设备可以独立地访问主系统内存，而不需要 CPU 的全程干预，从而提高了数据传输速率和 CPU 的可用性。

> PIO（Programmed I/O），是一种用于处理 I/O 设备和内存交互的技术。在 PIO 中，CPU 通过执行程序指令来控制数据的传输，包括从 I/O 设备读取数据或向 I/O 设备写入数据。在 PIO 中，CPU通常需要完全占用整个读取或写入操作的持续时间，因此在此期间无法执行其他工作。这种方式会导致CPU无法跟上数据传输速率，或者需要在相对较慢的 I/O 数据传输过程中执行其他工作。因此，PIO 相对于其他技术而言效率较低，但在一些简单的应用场景中仍然可以发挥作用。

### 直接内存映射（DMA）

DMA（Direct Memory Access）是计算机系统的一种功能，允许某些硬件子系统独立于中央处理单元（CPU）直接访问主系统内存。

具有 DMA 通道的计算机可以比没有 DMA 通道的计算机以更少的 CPU 开销与设备之间传输数据。同样，多核处理器内部的处理电路可以在不占用处理器时间的情况下，将数据传输到和从其本地内存，从而允许计算和数据传输并行进行。DMA 还可以用于内存之间的数据复制或移动。DMA 可以将昂贵的内存操作，如大型复制或分散-聚集操作，从 CPU 转移到专用的 DMA 引擎。DMA 的实现示例是 I/O 加速技术。DMA 在网络芯片和内存计算架构中很有用。

DMA 控制器包含三个寄存器：**地址寄存器**、**字计数寄存器**和**控制寄存器**。为了在内存中找到目标位置，使用地址寄存器。字计数寄存器计算需要传输的输入数据中的字数。最后，控制寄存器指定传输模式。DMA 控制器通过特殊的数据通道在内存和辅助设备之间传输数据。有两种类型的通道：**数据通道**和**控制通道**。数据通道传输实际数据，而控制通道用于调节 DMA 控制器的操作。

DMA 技术加快了数据传输和内存操作的速度，有助于操作系统正确分配负载。然而，连接到网络计算机（NC）的计算机系统无法使用 DMA 控制器进行数据传输。连接到 NC 时，计算机系统必须依赖 CPU 来帮助进行数据传输。此外，在使用 DMA 进行数据传输时，可能会遇到缓存一致性问题。

![](./asserts/14.png)

我们首先来看一下在没有 DMA 下，磁盘如何读取数据。

首先，磁盘控制器从磁盘驱动器串行地、一位一位地读一个块(一个或多个扇区)，直到将整块信息放入控制器的内部缓冲区中。接着，它计算校验和，以保证没有读错误发生。然后控制器产生一个中断。当操作系统开始运行时，它重复地从控制器的缓冲区中一次一个字节或一个字地读取该块的信息，并将其存人内存中。

而 DMA 过程则不是这样：CPU 通过设置 DMA 控制器的寄存器对它进行编程，所以 DMA 控制器知道将什么数据传送到什么地方（即上图的步骤1）。DMA 控制器还要向磁盘控制器发出一个命令，通知它从磁盘读数据到其内部的缓冲区中，并且对校验和进行检验。如果磁盘控制器的缓冲区中的数据是有效的，那么 DMA 就可以开始了。

**DMA 控制器**通过在总线上发出一个读请求到磁盘控制器而发起 DMA 传送（图中步骤2）。该读请求看起来与任何其他读请求是一样的，并且磁盘控制器并不知道或者并不关心它是来自 CPU 还是来自 DMA 控制器。一般情况下，要写的内存地址在总线的地址线上，所以当磁盘控制器从其内部缓冲区中读取下一个字的时候，它知道将该字写到什么地方。写到内存是另一个标准总线周期（步骤3）。当写操作完成时，磁盘控制器在总线上发出一个应答信号到 DMA 控制器（步骤4）。于是，DMA 控制器步增要使用的内存地址，并且步减字节计数。如果字节计数仍然大于0，则重复第 2 步到第 4 步，直到字节计数到达 0。此时，DMA 控制器将中断 CPU 以便计 CPU 知道传送现在已经完成了。当操作系统开始工作时，用不着将磁盘块复制到内存中，因为它已经在内存中了。