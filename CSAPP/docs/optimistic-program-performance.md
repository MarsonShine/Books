# 优化程序性能

程序优化的点一般从两个方面入手：

1. 选择一组适合的算法与数据结构
2. 我们必须要写出能够让编译器更加有效的优化，能转成高效可执行的代码。

我要编写对编译器友好的代码，能够让编译器更好的优化。所以我们得知道编译器优化的限制：

1. 内存别名使用（memory aliasing）：存在两个指令指向的内存地址相同。这对于编译器来说，在执行优化时就必须考虑假设两个指针可能会指向同一个内存地址，所以就不会执行优化。例如：

   ```c
   x = 1000; y = 3000;
   *q = y;
   *p = x;
   t1 = *q;
   ```

   t1 的计算指依赖于指针 p 和 q 是否指向同一个地址，如果相同 t1 等于 1000，不同 t1 等于 3000；这就给编译器造成了一个困扰，因为这会影响值的正确性，所以这就会限制编译器的优化策略。

2. 函数调用，考虑下面这个例子：

   ```c
   long f();
   long func1() {
   	return f() + f() + f() + f();
   }
   long func2() {
   	return 4 * f();
   }
   ```

   这很容易就让人觉得 func1 和 func2 的结果是一样的，并且 func2 性能更高，只调用了一次 func。但是编译器会这么优化么，如果 `f()` 函数是带有状态的函数，那么这种优化就给结果带来意外的错误，比如函数 `f()` 的内容是这样的：

   ```c
   int counter = 0;
   long f() {
   	return counter++;
   }
   ```

   所以编译器也会考虑到这种情况，从而不会选择优化像 func2 那样的函数。

   但是可以用内联函数来优化函数调用，就是将上面的 4 次函数调用，变成一个方法体：

   ```c
   long func1Inline() {
   	long t = counter++;
   	t += counter++;
   	t += counter++;
   	t += counter++;
   	return t;
   }
   ```

   这样的话，编译器就可能会优化成以下内容：

   ```c
   long func1opt() {
   	long t = 4 * counter + 6;
   	counter += 4;
   	return t;
   }
   ```

   ## 性能度量标准——每元素的周期数（CPE）

   每元素周期数（Cycles Per Element）。处理器活动的顺序是由时钟控制的，时钟提供某个频率的信号，通常用*千兆赫兹（GHz）*表示，即十亿周期每秒来表示。

   > 例如一个系统有 ”4GHz“ 处理器，说明这个处理器时钟运行频率为每秒 4 × 10^9 个周期
   >
   > 1纳秒 = 10^-9秒；1皮秒 = 10^-12秒；4GHz 的时钟周期为 0.25 纳秒，或者 250 皮秒。

