# 运行栈

过程是软件中一种很重要的抽象。它是代码的封装，它用一组入参和一个可选的返回治实现了某种功能。不同的语言，过程的形式多样化：函数、方法、子例程（subroutine）、处理函数等等。但是它们都有一些共性：

- 传递控制。再进入过程 Q 的时候，程序计数器必须设置为 Q 的代码的起始位置，然后在返回时，要把程序计数器设置成 Q 的代码结束位置的后面指令的地址。
- 传递数据。P 必须能够向 Q 提供一个或多个参数，Q 必须能够向 P 返回一个值
- 分配和释放内存。Q 可能需要为局部变量分配空间，在返回前，要释放这些空间。

用一句话描述就是，过程的实现就是先描述控制，再描述数据传递，最后是内存管理。

过程的调用机制是用了 “栈” 这种数据结构进行内存管理的，因为调用过程就是 “先进后出” 的过程。再过程 P 调用过程 Q 的例子中，可以看到当 Q 再执行时，P 以及所有向上追溯到 P 的调用链的过程都是暂时被挂起的。当 P 调用 Q 时，控制和数据信息添加到栈尾。当 P 返回时，这些信息都会被释放。

当过程需要的空间超过了寄存器能够存放的大小时，就会被分配到栈空间上。这个部分称为过程的栈帧（stack fram）。

![](asserts/run-stack.jpg)

​												(图引用自《深入理解计算机系统》)

正在运行的过程总是再栈顶。当 P 调用 Q 时，会把返回地址压入栈中，表示当 Q 返回时，要从 P 的哪个位置继续往下执行（即把 P 调用 Q 指令的下一个指令地址入栈，以及 Q 函数的起始地址地址入栈）。

## 传输数据

在函数调用或函数返回都会传输数据，这些数据大部分都是通过寄存器传递的。当过程 P 调用过程 Q 时，P 的代码首先必须要把参数复制到适当的寄存器中。同样，当 Q 过程返回数据给 P 时，P 可以通过访问寄存器如 %rax 中的值。

在 x86-64，通过寄存器传递数据最多只能传递 6 个整形参数，操作数大小的不同，选择的寄存器名称也不相同。

| 操作数的大小 |  1   |  2   |  3   |  4   |  5   |  6   |
| :----------: | :--: | :--: | :--: | :--: | :--: | :--: |
|      64      | %rdi | %rsi | %rdx | %rcx | %r8  | %r9  |
|      32      | %edi | %esi | %edx | %ecx | %r8d | %r9d |
|      16      | %di  | %si  | %dx  | %cx  | %r8w | %r9w |
|      8       | %dil | %sil | %dl  | %cl  | %r8b | %r9b |

那么如果过程调用传递的参数超过 6 个怎么办？

超出的部分要分配在栈内存中分配，这部分内存空间也叫 "栈帧"。要注意的是，通过栈帧传递参数时，**所有的数据大小都向 8 的倍数对齐**。

## 栈上的局部变量

当寄存器内存不足以存放所有本地数据时，这时候的局部数据就要放到内存中了，这种情况包括：

1. 对一个局部变量是数组和结构，因为要引用其数组或结构的引用才能访问，所以要分配地址在内存中。
2. 对一个局部变量使用地址运算符 '&'，因此就必须要分配一个地址空间给它

通过一个例子来详细描述栈帧存储数据的过程，从分配地址，到访问数据，最后到释放地址的过程

```c
long swap_add(long* xp,long* yp) {
	long x = *xp;
	long y = *yp;
	*xp = y;
	*yp = x;
	return x + y;
}
long caller() {
	long arg1 = 534;
	long arg2 = 1057;
	long sum = swap_add(&arg1, &arg2);
	long diff = arg1 - arg2;
	return sum * diff;
}
```

生成的汇编代码如下：

```
long caller()
caller:
	subq	$16, %rsp
	movq	$534, (%rsp)
	movq	$1057, 8(%rsp)
	leaq	8(%rsp), %rsi
	movq	%rsp, %rdi
	call	swap_add
	movq	(%rsp), %rdx
	subq	8(%rsp), %rdx
	imulq	%rdx, %rax
	addq	$16, %rsp
	ret
```

一般来说，**过程调用通过减小栈指针在栈上分配空间，增加栈指针就是释放栈内存**。

`subq $16, %rsp` 开始就把栈指针减 16，意思就是预先分配了 16 个字节。

`movq $534, (%rsp);movq $1057, (%rsp)` 接下来两个 movq 指令是给参数变量复制到栈内存中（从内存偏移量也验证了之前说的，数据大小是 8 的倍数对齐）。

`leaq 8(%rsp), %rsi` 计算第二个参数地址

`movq %rsp, %rdi` 计算第一个参数

`call swap_add` 调用 `swap_add(%rdi, %rsi)`

`movq (%rsp), %rdx` 读取内存地址赋值给寄存器（获取 swap_add 返回的数据）

`subq 8(%rsp), %rdx` 寄存器 `%rdx` 的值 - 第二个参数的值（diff = arg1 - arg2）

`imulq %rdx, %rax` `%rax` * `%rdx`（两数相乘）

`addq %16, %rsp` 增加栈指针 16 个字节，释放栈空间

`ret` 返回

在给寄存器存储参数时，会遵循一定的规则的。因为 OS 要保证确保一个过程调用另一个过程时，被调用者不会覆盖调用者用到的寄存器值。所以，x86-64 采用了一组统一的寄存器使用惯例，所有的过程（包括程序库）都必须严格按照这个遵循。

根据惯例，寄存器 %rbx、%rbp 和 %r12~%r15 被划分为**被调用者保存寄存器**。如过程 P 调用过程 Q 时，Q 必须要保存这些寄存器的值。而所有其它的寄存器，除了栈指针 %rsp 之外，都归类于 **调用者保存寄存器**。举个具体例子：

```c
long P(long x, long y) {
	long u = Q(y);
	long v = Q(x);
	return u + v;
}
```

生成的汇编如下：

```
long P(long x, long y)
x in %rdi, y in %rsi
P:
  pushq    %rbp    保存寄存器
  pushq    %rbx    保存寄存器
  subq     $8, %rsp    分配 8 个字节的占内存     
  movq     %rdi, %rbp    y 保存到寄存器 rbp
  movq     %rsi, %rdi    x 保存到寄存器 rdi
  call     Q    调用Q
  movq     %rax, %rbx    保存 Q 的结果到 rbx
  movq     %rbp, %rdi    传递参数 x
  call     Q	调用Q
  addq     %rbx, %rax	保存 Q 的结果到 rax + rbx 寄存器的值
  addq     $8, %rsp    释放栈内存
  popq     %rbx    弹出栈，恢复这两个被调用者保存寄存器的值
  popq     %brp
  ret
```

## 二维数组的内存大小计算

对于多维数组声明如下：T D\[R][C]；

它的数组元素 D\[i][j] 的内存地址为：
$$
\&D[i][j] = x_0 + L(C*i+j)
$$
其中 L 是数据类型 T 以字节为单位的大小。

编译器对于定长的多维数组会根据优化等级设置来优化代码。



