# C++ 基本知识

typedef 定义一个类型：

```c++
typedef int *int_pointer;	// 申明一个 int 类型的 int_pointer 类型
int_pointer ip;	// 定义 int_pointer 类型的变量 ip

// 上述等价于
int *ip;
```

 

printf 格式化输出

```c++
printf("%d",value);	// 十进制整数
printf("%f",value); // 浮点数
printf("%c",value); // 字符
printf("%.2x",value); // 整数必须用至少两个数字的十六进制

// example
int val = 0x87654321;
byte_pointer valp = (byte_pointer) &val;
show_bytes(valp, 1);	// 小端法：21  大端：87
show_bytes(valp, 2);	// 小端：2143	大端：8765
show_bytes(valp, 3);	// 小端：214365	大端：876543

void show_bytes(byte_pointer start,size_t len) {
    size_t i;
    for (size_t i = 0; i < len; i++)
    {
        printf("%.2x",start[i]);
    }
    printf("\n"); 
}
```

十进制数 12345 转成 16 进制数和浮点型十六进制数

```c++
123456	// 十进制
0x00003039	// 十六进制
0x4640E400	// 浮点数

// 将上述转换成二进制数
0000 0000 0000 0000 0011 0000 0011 1001	// 1：十六进制转二进制
0100 0110 0100 0000 1110 0100 0000 0000 // 2：浮点型转二进制

// 将 1 左移 13 位
0000000000000000001 1000000111001	// 1：十六进制转二进制
          010001100 1000000111001 0000000000 // 2：浮点型转二进制
```

& 取地址运算符

```
int ival = val;
int *pval = &ival;	// 取 ival 值得地址，并赋值给 *pval 指针
```

# 练习

1. 3510593 十六进制数表示为 0x00359141；浮点数 3510593.0 十六进制数为 0x4A564504。写出对应的二进制数：

   ```
   0x00359141: 0000 0000 0011 0101 1001 0001 0100 0001
   0x4A564504: 0100 1010 0101 0110 0100 0101 0000 0100 
   上面两个移动多少位匹配的位数最多
   00000000001 101011001000101000001
     010010100 101011001000101000001 00
   移动 2 位最多有 21 位相同
   ```



# 类型转换

-12345 转无符号数：53191

-12345 的原码：| -12345 |，对应的二进制原码：0011 0000 0011 1001

-12345 （负数）的补码 = 二进制原码按位取反，末位加1：1100 1111 1100 0111

转成无符号则最高位不是符号位直接换算得知：53191

## 公式

补码转无符号数
$$
T2U_w(x)=\begin{cases} x+2^w,&x < 0\\ x,&x \geq 0 \end{cases}
$$

推导过程：

已知公式 ，无符号定义
$$
B2U_w(\vec{x}) = \sum_{i=0}^{w-1} x_i2^i;
\vec{x}=[x_{w-1},x_w{w-2},\cdots,x_0]
$$
已知公式，补码定义
$$
B2T_w(\vec{x}) = -X_{x-1}2^{w-1} + \sum_{i=0}^{w-2} + \sum_{i=0}^{w-2}x_i2^i;
\vec{x} = [x_{w-1},x_{w-2},\cdots,x_0]
$$
