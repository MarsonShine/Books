# 数据对齐

计算机系统对基本数据类型的合法地址做了一些限制，要求某些数据类型的地址必须是某个 K 值的倍数（通常是2，4，8）。这种对齐限制简化了处理器和内存系统之间的硬件设计。因为如果一个处理器总是从内存中取 8 个字节，那么地址必须就为 8 的倍数。那么如果我们在设计数据结构时，能保证降所有的数据地址对齐为 8 的倍数，那么处理器就能用一个内存操作读或写了。反过来，如果没有保证数据对齐，那么就有可能需要执行两次内存访问，因为对象的内存大横跨了多个内存段（数据被分在两个 8 字节的内存块中）。虽然数据不对齐对程序的运行影响不大，但是还是建议尽量让其数据对齐，这样会提升性能。

以下是各个数据类型对应的 K 值设置

|  K   |       类型        |
| :--: | :---------------: |
|  1   |       char        |
|  2   |       short       |
|  4   |     int,float     |
|  8   | long,double,char* |

如果一个结构中的字段内存大小不满足 K 值得要求，那么编译器就可能会在字段分配中插入间隙，来保证数据元素结构是对齐的。如

```c
struct S1 {
	int i;
	int c;
	int j;
}
```

结构对象里面的内存大小是 9 字节，它是不满足以 4 字节为对齐要求的。那么编译器就会在字段之间插入一个 3 字节的间隙，这样总的大小就变成了 4+4+1+3 = 12 字节。这样就满足了对齐要求了。这样也可以看出来虽然数据对齐这种限制要求能带来性能提升，但是实则是牺牲了一定的内存空间换来的（这个例子就浪费了 3 字节的内存）。

有些处理器会强制要求数据对齐，比如 Intel 和 AMD 处理器，它们要求在编译期和运行时系统都必须保证分配用来保存可能会被 SSE 寄存器读或写的数据结构的内存，都必须满足 16 字节对齐，这包括：

- 任何内存分配函数（alloca、malloc、calloc、realloc）生成的块的起始地址都必须是 16 的倍数。
- 大多数函数的栈帧的边界都是 16 字节的的倍数。