# 垃圾回收-计划阶段

标记阶段完成后，所有对象都已被标识为可达或不可达。可达对象通过专门的标志位进行标记，其中部分对象可能还会被额外标记为“已固定”（pinned）。此时垃圾回收器已掌握继续执行所需的所有信息。但随之而来的问题是——应该执行清扫（Sweep）还是压缩（Compact）回收？

与基于历史回收记录进行猜测不同，垃圾回收器可以根据当前状态预判执行结果。通过评估内存碎片化程度等关键因素，它能智能判断是否值得执行压缩操作，还是仅需清扫即可。这种预测机制显然更具前景。但您很快会发现，由于对象固定（pinning）等因素的存在，要精确预测碎片化程度并非易事。这甚至形成了一个悖论——要准确预判压缩效果，就必须实际执行压缩操作。

这正是计划阶段（Plan phase）的核心价值所在。该阶段通过模拟压缩过程（不实际移动对象）来获取精确的压缩效果数据，并据此做出决策。

更重要的是，这种方式准备的信息可直接用于后续的压缩或清扫阶段。如果模拟结果显示压缩效果理想（本章后续将详细探讨该决策机制），垃圾回收器会直接利用已收集的信息执行真实压缩；若仅需执行清扫，这些信息同样会被直接利用。由于最频繁的回收操作（第0代和第1代）通常采用压缩策略，这些模拟结果很少被废弃。

从某种意义上说，计划阶段是整个垃圾回收过程的“引擎舱”。它完成了所有繁重而必要的计算工作，而清扫或压缩阶段只是以相对简单的方式消费这些计算结果。

计划阶段如何能在不操作托管堆对象的情况下，同时模拟压缩和清扫过程？本章将深入揭示这一核心机制——您即将触及垃圾回收器最精妙的设计。理解计划阶段的工作机制，才能真正洞悉垃圾回收器的运作本质。

需要注意的是，本章描述的处理流程在SOH（小对象堆，含0/1/2代）和UOH（大对象堆LOH与固定对象堆POH）中存在细微差异。

## 小对象堆（SOH）

让我们先从SOH（小对象堆）的规划描述开始，即使它比UOH（大对象堆）的情况稍复杂些。理解了SOH后，UOH版本就很容易掌握了。

### 内存块与间隙

想象托管堆（小对象堆内部）的一个片段在GC（垃圾回收）过程刚开始时的状态（见图9-1）。一些对象彼此相邻存放，每个对象由对象头、方法表指针和至少一个指针大小的字段组成（如第4章所述，即使该字段未被使用）。有些对象较大，有些较小。

![](asserts/9-1.png)

图9-1. GC过程开始时托管堆（小对象堆内部）的片段（H代表对象头，MT代表方法表指针，浅灰色填充表示对象）

假设经过前文描述的标记阶段后，所有可达对象已被标记（见图9-2）。此时规划阶段启动。

![](asserts/9-2.png)

图9-2. 标记阶段结束后托管堆的片段（中等灰色对象表示已标记对象

在规划阶段，GC会逐对象扫描待回收的代和更年轻的代。通过对象方法表中的信息计算对象大小：对于数组，其大小为基址大小加上元素大小乘以元素数量。扫描时，专用指针会根据当前对象大小前进来跳转到下一个对象。你可以将堆视为一个巨型链表——每个对象的大小用于计算下一个对象的地址。但这种方法仅在对象间无空闲空间时有效。堆内存几乎总存在碎片化，那么遇到空闲空间时如何定位下一个对象？答案在第6章“空闲列表分配”一节中已给出：每当堆上存在空闲空间时，GC会用一个虚拟的"Free"对象填充它。这种对象类似数组，有专用的方法表条目，其元素为1字节大小，元素数量会调整以覆盖整个空闲区域。这样当遍历堆时，GC（或使用相同技术的调试器）就能像跳过普通对象一样跳过空闲空间。

规划阶段的核心原理是：在逐对象扫描过程中，将所有已标记和未标记对象分组（见图9-3）。可能创建两种分组：

- 内存块(Plug)：连续的可达（已标记）对象组
- 间隙(Gap)：连续的不可达（未标记）对象组

![](asserts/9-3.png)

图9-3. 托管堆中的内存块与间隙

通过将整个托管堆划分为一系列内存块和间隙，我们可以更高效地计算所需信息（见图9-4）：

- 每个间隙的大小与位置：若选择清除（Sweep）式回收，多数间隙将转变为由空闲列表管理的可用空间。
- 每个内存块的重定位偏移量与位置：若选择压缩（Compact）式回收，将根据各内存块的重定位偏移量进行移动。

![](asserts/9-4.png)

图9-4. 内存块与间隙关联的大小及偏移量信息

如何计算重定位偏移量？最简单场景下，可将其计算为所有前置间隙大小的累加值（如图9-4所示）。但实际实现要复杂得多——运行时采用专属内部分配器为待迁移的每个内存块寻找合适的目标地址，该地址会被记录而非立即执行迁移操作。

> 若您想深入探究细节并研究.NET源码，所有这些逻辑都实现在 `gc_heap::plan_phase` 方法中。该方法通过扫描连续对象来识别内存块与间隙，并通过调用 `allocate_in_condemned_generations` 或 `allocate_in_older_generations` 计算每个内存块的新位置——这里就是您展开研究的切入点。

对于可移动内存块（即未被固定的对象）的简单场景，[碰撞指针分配器（bump pointer allocator）](06-Memory-Allocation.md#指针碰撞分配)会将各内存块紧密排列。图9-5展示的“虚拟空间”正是内部分配器视角下的托管堆形态（即压缩完成后的理想状态），这仅为便于理解所做的示意图——实际运行时分配器仅操作指针并更新其值。该堆内存片段的计划阶段包含以下步骤：

- 首先，分配指针被重置至代际起始位置（见图9-5a）。
- 当遇到首个内存块（含单个对象）时，分配器在指针当前位置预留空间（见图9-5b），随后前移分配指针。内存块新旧位置的差值被记录为重定位偏移量。
- 当处理下一个内存块（含三个对象）时，分配器紧邻前一个“已分配”块后预留空间，同样记录新旧位置差值作为重定位偏移量。
- 最后一个内存块也遵循相同逻辑处理。

![](asserts/9-5.png)

图9-5展示了插槽重定位偏移量的计算过程，其原理是基于内部分配器为每个插槽计算新地址——（a）图9-4中的对象布局及其在托管堆上的分配器视图，（b）内部分配器为第一个插槽找到位置，（c）内部分配器为第二个插槽找到位置，（d）内部分配器为最后一个插槽找到位置。

最终所有重定位偏移量计算完成后，垃圾回收器（GC）就能精确获知压缩发生后分配指针的最终值。这些信息可用于计算压缩效率，该指标将影响GC后续是否执行压缩的决策。

> 以图9-5为例，压缩后所有对象占用的空间将减少136字节，这正是分配指针初始值与最终值的差值。当前简化案例尚未体现复杂内部分配器的必要性，这将在后续讨论固定对象时展开。

通过将对象组织为插槽和间隙，GC能高效获取完整信息集：

- 压缩效率如何？
- 清扫回收时应在何处创建空闲列表项（间隙）？
- 压缩回收时应将可达对象移动至何处（插槽）？

接下来的问题是插槽与间隙相关数据的存储位置。GC本可使用专用内存区域，但当存在大量交错的小型间隙和插槽时，该方案将消耗过多内存。此外，交替访问托管堆与独立内存区域也会影响CPU缓存效率。鉴于GC已密集使用托管堆内存区域，微软.NET选择复用该区域存储插槽与间隙信息。

当间隙和插槽构建恰当时，每个插槽前都会存在对应的间隙。因此GC将对象组织成交替的插槽与间隙结构，从而能在每个插槽前的间隙末端（即存储无效对象的安全区域）保存关键信息（见图9-6）。这些插槽信息在64位运行时占用24字节，32位运行时占用12字节，包含对应间隙大小、插槽重定位偏移量及后续将解释的附加数据（重定位偏移量中的2个比特位及左右偏移量）。

![](asserts/9-6.png)

图9-6. 托管堆中插槽信息的存储位置

在托管堆中为插槽信息预留空间（位于每个插槽起始位置之前）是空对象也必须占用24字节（64位运行时环境下）的主要原因。由于插槽前的间隙至少包含一个对象，该间隙长度至少为24字节。这种设计巧妙而优雅地确保了始终有足够空间存储插槽信息！

图9-7展示了每对间隙和插槽的信息如何存储在托管堆中（参见图9-7）。这些信息将在后续的清扫（Sweep）或压缩（Compact）阶段使用。

![](asserts/9-7.png)

图9-7. 与插槽及间隙关联的尺寸和偏移量信息直接存储在托管堆中（基于图9-4的场景)

若GC决定执行压缩操作，这些插槽信息将被频繁调用。其中最关键的作用是确定垃圾回收完成后对象的新地址——只需检查对象地址X是否属于某个插槽范围，若是则从X中减去对应的插槽重定位偏移量即可。由于该查询可能被极高频次调用，必须竭尽全力优化计算效率。为此，插槽被组织为二叉搜索树（BST）结构。

如图9-6所示，每个插槽信息包含左右偏移量字段，分别指向左子树或右子树插槽信息的存储位置（若无对应子节点则标记为0）。这构成了包含所有插槽地址的二叉插槽树基础结构（见图9-8)。该树采用平衡构建方式，确保任意节点的左子树地址均小于该节点，右子树地址均大于该节点。

![](asserts/9-8.png)

图9-8. 以BST形式组织的插槽

> 插槽树中的地址均指向插槽内首个对象的MT字段（遵循CLR常规设计）。GC通过固定偏移量可快速定位对应的插槽信息存储位置。

### 场景9-1 – 含有无效结构的内存转储

问题描述：在问题调查过程中，捕获了.NET应用程序的完整内存转储。但该转储似乎无法使用，因为数据结构无效。例如，在执行大多数SOS命令时会出现以下提示信息：

```
> !dumpheap -stat
The garbage collector data structures are not in a valid state for traversal.
It is either in the "plan phase," where objects are being moved around, or we are at the initialization or shutdown of the gc heap. Commands related to displaying, finding or traversing objects as well as gc heap segments may not work properly. !dumpheap and !verifyheap may incorrectly complain of heap consistency errors.
```

分析：该内存转储确实可能是在GC规划阶段捕获的，此时无法保证对象处于“正常状态”——因为堆内存无法通过常规方式遍历（即无法从区域起始位置开始，按照对象大小逐步推进，正如本章前文所述）。实际上，如果你查看.NET代码，会发现Plan阶段被以下防护代码包围：

```
GCScan::GcRuntimeStructuresValid(FALSE);
plan_phase(n);
GCScan::GcRuntimeStructuresValid(TRUE);
```

这是唯一设置此类保护机制的地方。因此，通过检查是否存在正在执行GC相关代码的线程，可以轻松确认内存转储是否是在这种不利时刻捕获的。根据运行环境不同，需要检查以下四种可能的库和命名空间组合：

- `coreclr!wks`：使用工作站GC的.NET。
- `coreclr!srv`：使用服务器GC的.NET。
- `clr!wks`：使用工作站GC的.NET Framework。
- `clr!srv`：使用服务器GC的.NET Framework。

例如，对于启用工作站GC的.NET 8应用程序的转储文件，可以通过以下方式验证：

```
> !findstack coreclr!wks
Thread 000, 6 frame(s) match
* 00 000000a963b7cd30 00007ff903bb0b48 CoreCLR!WKS::gc_heap::plan_phase+0xa9
* 01 000000a963b7ce40 00007ff903bb095a CoreCLR!WKS::gc_heap::gc1+0x178
* 02 000000a963b7ceb0 00007ff903b90d21 CoreCLR!WKS::gc_heap::garbage_collect+0x5ca
* 03 000000a963b7cf20 00007ff903b90e98 CoreCLR!WKS::GCHeap::GarbageCollect
Generation+0x191
* 04 000000a963b7cf60 00007ff903b90b15 CoreCLR!WKS::GCHeap::GarbageCollectTry+0xe8
* 05 000000a963b7cff0 00007ff903670613 CoreCLR!WKS::GCHeap::GarbageCollect+0x2a5
```

 显然，此时正处于GC的Plan阶段，因为存在线程正在执行 `gc_heap::plan_phase` 函数。

不过根据我们的实践经验，此类提示也可能在以下情况出现：当SOS调试扩展未正确加载时（例如错误使用.NET 2.0运行时版本的SOS分析.NET 4.0的转储文件，或反之），导致获取GC数据时发生常规性错误。

### 块表（Bricks Table）

插件树的根节点需要存储在某个地方。为整个托管堆创建一个庞大的单一插件树显然不切实际。在调查连续间隙与插件时，向树中插入新条目可能触发树的重平衡操作。若一棵树需要覆盖所有插件，其维护成本将极其高昂。此外，在如此庞大的树中进行查找遍历也会因需要跨越多个树层级而代价昂贵。

更实用的方案是为连续地址范围构建独立的插件树。这种地址范围在CLR中称为“块”(brick)。32位运行时的块大小为2,048字节，64位运行时则为4,096字节。换言之，托管堆中每2KB或4KB内存区域都对应一个块，其中存储着该区域的插件树信息。所有块通过覆盖整个托管堆的块表进行管理（参见图9-9）。

块表中的每个条目是一个16位整数，可表示三种逻辑状态：

- **0**：表示该块未关联任何插件信息（指定地址范围内不存在插件）。
- **>0**：表示插件树根节点的偏移量（实际存储值为原始偏移量+1，以便用0表示无插件状态）。
- **<0**：表示当前块是前续块的延续（存在跨越多块的大型插件），此时应向前回溯指定数量的块以定位起始位置。

![](asserts/9-9.png)

图9-9. 块与块表

通过将块表条目与每个插头信息中的左右偏移量相结合，可以高效地表示插头树结构（见图9-10）。示例块表条目包含值 `0x6f1`——它表示对应内存区域内插头树根的偏移量。由于这是第二个块表条目，其代表 `0x1000`（4 KB）到 `0x2000`（8 KB）之间的地址区域。这意味着根节点位于 `0x6f0`（根据前文规则，正值需减1）加上 `0x1000` 后的地址 `0x16f0` 处。从该地址出发，可利用插头信息中的偏移量遍历该块对应的整个插头树。

![](asserts/9-10.png)

图9-10. 块与块表示例——(a) 作为插头树根的块条目及插头信息条目，(b) 逻辑插头树表示

> 块表条目和左右偏移量均为短整型（16位），因其存储值范围在–32767至32767之间，足以表示4 KB地址范围内的偏移量。

当回答“地址X处对象的新地址是什么？”时，需执行以下简单步骤：

- 根据地址X计算块表条目索引——直接将其除以块大小。
- 若块表条目值<0，则跳转至指定块表条目重复流程。
- 若块表条目值>0，则开始遍历插头树寻找对应插头，从X中减去插头的重定位偏移量。

至此我们可完成计划阶段运作原理的描述。所有必要信息已收集完毕，垃圾回收器可继续后续操作。通过末位插头的重定位偏移量即可推算出压缩效率。然而仍有一个关键机制尚未说明——正是它使得整套技术复杂度显著提升。

