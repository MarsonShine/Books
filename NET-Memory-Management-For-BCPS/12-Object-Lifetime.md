# 对象生成周期

前几章已全面阐述了.NET的自动内存管理机制。第6章介绍了对象创建方式，第7至11章则详细讲解了无用对象的回收过程。但若不了解某些辅助机制，你的知识体系仍不完整。本章将聚焦其中三项机制。这些机制虽可独立运作，但在概念上都与同一主题紧密关联——即对象的生命周期。

所述三项机制包括：终结（finalization）、可释放对象（及其广为采用的 `Disposable` 模式）以及弱引用（`weak references`）。通过本章学习，你将透彻理解它们的实现原理、应用场景及使用方法。文中还提供若干实际案例，演示如何诊断相关问题。需特别说明的是，这些机制主要从内存管理视角进行阐释。其他著作中有更全面的探讨，涵盖所有优劣考量及常见陷阱——本书并非C#入门教材，故不涉及通用C#话题讨论。

终结机制与 `Disposable` 模式均与非托管代码交互（及 `P/Invoke` 机制）密切相关，因此本章大量篇幅聚焦于此。但请注意，这两项机制连同弱引用，同样适用于与非托管资源无关的常规托管代码场景——例如日志记录或缓存应用。即便你不涉及非托管代码与 `P/Invoke`，本章内容仍值得一读。

## 对象与资源生命周期

在托管世界中，一切似乎都很简单。你创建对象、使用它们，当不再需要时垃圾回收器（GC）会在某个时刻将其删除。只要对象不再被使用，具体何时被回收并不重要。这种非确定性的对象释放方式是追踪式垃圾回收器（如.NET中的实现）的典型特征。

这一切都很美好，直到你希望对象不再被需要时触发某些操作——这种技术称为终结（finalization）。突然间，GC的非确定性特性成了问题——开发者根本没有合适的地方编写相关代码。因为从代码角度来看，对象创建的时刻（构造函数）是明确的，但对象回收的时刻却没有明确定义。

像.NET这样的托管运行时提供了专门的终结机制——包括一个明确定义的位置，开发者可以在此编写对象成为垃圾时需要执行的代码。事实上，本章大部分内容都在讨论这种终结过程。由于它本质上与垃圾回收的非确定性相关，因此常被称为非确定性终结（non-deterministic finalization）——它必然会发生，但具体时间未知。

此外，有时可能需要确定性终结（deterministic finalization）——在明确知道对象不再使用时显式执行操作。.NET通过 `IDisposable` 接口提供了这种终结的契约，后文将详细探讨。

> 非确定性终结与确定性终结有时也被分别称为隐式清理（implicit cleanup）和显式清理（explicit cleanup）。

请注意，从概念上讲，终结机制与垃圾回收机制并无直接关联。它绝对不涉及垃圾回收本身（尽管有些开发者会误解）。终结只是产生副作用——你可能希望在对象不可达或不再需要时执行某些操作。但无论是C#中的终结器（finalizers）还是 `IDisposable` 接口，都不负责释放不再需要的对象内存！我们在多次招聘面试中听到候选人说 `Dispose` 方法会释放内存，希望读完前几章后你能彻底明白这是错误的。

那么为什么需要终结机制？在完全托管的环境中，它的必要性其实很低。这种情况下，所有托管对象相互引用，整个对象图都由GC妥善管理。如果删除一个对象（比如将其最后一个引用赋值为null），追踪式GC会自动删除其他所有无法从别处访问的关联对象。这种删除关联对象的行为，正是C++中析构函数的典型职责。

在托管世界中，终结机制主要用于对象持有GC和运行时无法管理的资源（非托管资源）。这类资源通常是各种句柄、描述符以及与系统资源相关的数据，它们必须显式释放。特定环境越依赖这类非托管协作，终结机制就越重要。.NET环境从设计之初就高度兼容非托管代码——正如前文所述，其设计目标之一是将常规C++代码稍作修改即可编译为.NET程序（类似如今的C++/CLI语言）。许多常用API底层都依赖非托管资源（如文件、套接字、位图等），因此.NET开发者从早期就开始使用两种终结形式：确定性的 `IDisposable` 契约和非确定性终结。

> JVM作为极流行的托管环境，对非确定性终结的关注度低得多。它们被认为不可靠、易出问题且会给GC带来不必要的开销。事实上，Java 9起甚至将 `java.lang.Object.finalize` 方法标记为废弃。多年来更推荐采用确定性终结方法——通过提供显式清理方法并要求开发者在对象不再需要时调用（通常用 `try-finally` 块包裹），这正是.NET世界知名的 `Disposable` 模式。

作为废弃方法的替代方案，Java建议使用 `java.lang.ref.Cleaner` 类来管理对象引用，通过 `java.lang.ref.PhantomReference` 及其关联的清理动作实现非确定性终结。虚引用（`PhantomReference`）会在回收器确定其引用对象可被回收后入队。

由于托管与非托管世界的共存，你需要分别考虑两个问题：对象生命周期的管理和对象持有的（非托管）资源管理。对象生命周期管理完全由GC负责，而运行时对非托管资源的理解有限，因此资源管理需要你借助本章所述特性自行处理。

需注意的是，本章将展示.NET中特定的终结实现会影响对象生命周期——因为终结本质上是对象删除的副作用。

## 终结（Finalization）

在.NET中通常所说的“终结”一般被理解为非确定性终结。正如ECMA-335标准所述：“创建对象类型的类定义可以提供一个实例方法（称为终结器），当该类的实例不再可达时调用。”这正是本章节要探讨的内容——如何声明和使用终结器方法，以及CLR如何实现它。

### 引言

在C#类型中声明终结器时，引入了特殊的 `~` 语法来模仿C++的析构函数（见代码清单12-1）。这表示当对象不再可达且其内存即将被回收时调用的代码。不要被C++析构函数语法所迷惑，这段代码执行的确切时间是非确定性的，稍后你会明白这一点。

在我们的示例中，终结器用于关闭已打开文件的句柄（否则迟早会达到系统最大句柄数限制）。在Windows系统中，系统资源通常由“句柄”表示，这些句柄通常映射到 `IntPtr` 结构体。

代码清单12-1 C#中使用终结器的简单示例

```csharp
class FileWrapper
{
    private IntPtr _handle;
    public FileWrapper(string filename)
    {
        Unmanaged.OFSTRUCT s;
        _handle = Unmanaged.OpenFile(filename, out s, 0x00000000);
    }
    // 终结器
    ~FileWrapper()
    {
        if (_handle != IntPtr.Zero)
            Unmanaged.CloseHandle(handle);
    }
}
```

C#中的终结器只是一个包装器，编译器会将其转换为重写 `System.Object.Finalize` 的 `Finalize` 方法（见代码清单12-2）。

代码清单12-2 终结器的IL方法定义

```il
.method family hidebysig virtual
instance void Finalize() cil managed
{
    .override method instance void [System.Runtime]System.Object::Finalize()
    // ...
}
```

重写 `Finalize` 方法是类型与GC之间的一种契约——这些对象被称为可终结对象，会得到GC的特殊处理。

> 在F#或VB.NET中声明可终结类型时，必须显式重写 `Finalize` 方法。但在C#中这是不允许的。尝试这样做会导致错误：“不要重写 `Object.Finalize`。相反，应提供一个析构函数。”因此，唯一的方法是使用 `~Typename` 语法。这个“析构函数”的名称相当不幸，因为如我们所知，它与托管对象本身的解构无关，更多与资源管理相关。有趣的是，由于C++已经使用 `~Typename()` 语法作为C++析构函数，在C++/CLI中终结器被定义为 `!Typename()`。

还需注意，正如微软文档所述：“派生类型中的每个 `Finalize` 实现都必须调用其基类型的 `Finalize` 实现。这是应用程序代码允许调用 `Finalize` 的唯一情况。”在C#中，析构函数包装器会自动完成这一点，但在其他语言中需要记住这一点。

例如，你可以使用终结器来管理由消耗资源引入的额外内存压力（借助 `GC.AddMemoryPressure`和 `GC.RemoveMemoryPressure` 方法），即使它是托管资源但你知道它底层使用了一些本地资源。典型的例子是使用 `System.Drawing.Bitmap` 类，它实际上表示为单个系统资源句柄，但在使用位图数据时显然需要一些额外内存（见代码清单12-3）。

代码清单12-3 使用终结器维护额外内存压力的示例

```csharp
class MemoryAwareBitmap
{
    private System.Drawing.Bitmap _bitmap;
    private long memoryPressure;
    public MemoryAwareBitmap(string file, long size)
    {
        _bitmap = new System.Drawing.Bitmap(file);
        if (_bitmap != null)
        {
            memoryPressure = size;
            GC.AddMemoryPressure(memoryPressure);
        }
    }
    ~MemoryAwareBitmap()
    {
        if (_bitmap != null)
        {
            // 不需要调用_bitmap.Dispose()因为它可能已经被终结
            // 稍后会详细讨论
            GC.RemoveMemoryPressure(memoryPressure);
        }
    }
}
```

然而，使用终结器有一些限制：

- 如前所述，它们的执行时间是非确定性的——终结器很可能会被调用（稍后你会看到），但确切时间不可预测。从资源管理角度看这很糟糕。如果拥有的资源有限，应该尽快释放。等待非确定性清理是低效的。在GC之后，`GC.WaitForPendingFinalizers` 方法可以确保在继续处理之前执行已收集可终结对象的终结器。我们稍后会多次提到这一点。
- 终结器的执行顺序是未定义的。即使一个可终结对象引用了另一个可终结对象，也不能保证它们的终结器会以任何逻辑顺序运行（比如“被拥有者”在“拥有者”之前或相反）。因此，你不应该在终结器中引用任何其他可终结对象，即使你“拥有”它们。无序执行是一个经过深思熟虑的设计决策——有时根本不可能找到一个自然顺序（例如，可终结对象之间的循环引用怎么办？）。不过，在关键终结器形式中存在一些可能的排序，稍后会描述。但是，终结器代码可以引用常规托管对象字段（即没有终结器的）。可以保证整个对象图只有在运行终结器后才会被收集。
- 在当前.NET实现中，执行终结器的线程是明确定义的。然而，ECMA-335没有强加任何要求。因此，应该避免依赖任何线程上下文（包括可能导致死锁的线程同步，如锁定）。
- 不能保证终结代码一定会执行或完整执行——例如，如果终结器中的某些同步问题导致它无限期阻塞，或者进程快速终止而没有给GC执行它们的机会。由于后面描述的复活技术，终结器也可能被执行多次。
- 从终结器抛出异常非常危险——默认情况下，它会直接杀死整个进程。因为终结器代码被认为非常重要（如释放系统范围的同步原语），无法执行它会被视为最高严重级别。因此，你必须非常小心，不要让任何异常逃逸出终结器。
- 可终结对象会给GC带来额外开销，可能影响整个应用程序性能——正如你将在描述终结实现的章节中看到的。

所有这些都得出相同的结论——实现终结器很棘手，使用它们可能不可靠，因此通常应该避免使用它们。将它们视为隐式的“安全网”，用于开发人员没有通过首选的显式清理方法释放资源的情况。在讨论 `Disposable` 模式时，你会看到这种典型用法。

> ECMA-335指出“为值类型定义终结器是有效的。然而，该终结器只会为该值类型的装箱实例运行。”在.NET运行时中，这不再有效。运行时在装箱时简单地忽略值类型中定义的终结器。

从程序员的角度来看，应该只关心终结器在对象变得不可达后的“某个时间”被调用。尽管如此，虽然这是一个实现细节，但了解终结器何时可能被实际调用是很好的。一般来说，有两种情况会发生：

- 在GC结束后：无论是什么触发了GC，在这次特定GC中发现不可达的可终结对象都会被排队，它们的终结器很快就会被执行。请记住，这意味着只有来自被判定（和更年轻）代的对象终结器会被调用。
- 作为CLR内部簿记：当运行时卸载AppDomain时，以及当它关闭时。

如前所述，终结器不一定仅限于非托管资源。你可以想象其他用途，比如代码清单12-4中的生命周期日志示例。如果出于某种原因，你希望在对象创建和删除时记录一些内容，它的构造函数和终结器似乎是理想的位置。例如，你可能想这样做，因为该对象代表了关键或资源密集型功能。

代码清单12-4 在C#中使用终结器的简单示例

```csharp
class LoggedObject
{
    private ILogger _logger;
    public LoggedObject(ILogger logger)
    {
        _logger = logger;
        // _logger.Log("Object created.");
    }
    // 终结器
    ~LoggedObject()
    {
        _logger.Log("Object finalized.");
    }
}
```

请注意，即使在这样一个“非-非托管”的世界中，实现终结器也不简单。在代码清单12-4中，终结器可能通过接口使用依赖注入的记录器。这意味着你不能保证注入的具体记录器实例不是可终结的，因此你会面临无序终结执行的问题——当从你的终结器调用时，记录器可能已经被释放。这是一个简单但富有表现力的终结陷阱示例。

如何减轻这种危险？一些解决方案可能基于代码审查或自动化静态分析——确保 `ILogger` 实现不是可终结的，或者它们是关键可终结的（很快你就会明白为什么这可能有所帮助）。但首选的解决方案总是一样的——避免使用终结。如果这样一个对象的生命周期如此重要，你可能会从实现 `Disposable` 模式中获益更多，其中清理时刻是手动定义的，对日志设施来说更安全。