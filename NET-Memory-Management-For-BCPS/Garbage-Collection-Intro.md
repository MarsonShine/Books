# 垃圾回收——简介  

欢迎来到本书最重要的部分。前几章已经从理论和硬件层面广泛介绍了内存管理的主题。您还深入了解了.NET环境中内存的组织方式——如何划分为段和代，以及整个基础设施如何与操作系统协同工作。这些知识本身具有重要价值，例如可以帮助您诊断过度的内存分配问题，或使用不同方法来避免这些问题。  

然而，不可否认的是，在内存管理方面，.NET世界本质上与其自动内存回收机制密不可分。您已经了解了分配器（Allocator），知道对象是如何创建的。现在是时候学习对象如何以及何时被删除，并在不再需要时回收其占用的内存了。  

本章及接下来的三章将详细讲述.NET中垃圾回收（GC）的工作原理。为了避免一次性灌输过多知识，这部分内容被分为四章。但这四章内容紧密关联，要全面掌握相关知识，建议全部阅读。  

此外，这些章节的内容建立在之前章节的基础上。如果您没有按顺序阅读本书，强烈建议在阅读本章前至少浏览前几章（尤其是第5章和第6章）。  

在本章中，您将了解在哪些情况下会触发垃圾回收，详细剖析执行的各个阶段，并深入探讨初始步骤的细节。所有这些内容都会附带注释和示例，让您不仅能获得知识的满足感，还能将其应用于实践。  

# 高层次概览  

在深入之前，最好先对Microsoft .NET运行时中实现的垃圾回收器有一个宏观认识。如前几章所述，GC主要有两种工作模式：  

- **工作站模式（Workstation）**：旨在最小化托管线程视角下GC引入的延迟。其核心策略是通过更频繁地回收内存，减少每次回收的工作量，从而降低暂停的感知时长。这种模式特别适合桌面应用程序，因为用户体验对延迟敏感——您不会希望因为长时间运行的GC导致整个应用程序卡顿。  

- **服务器模式（Server）**：旨在最大化应用程序吞吐量。其策略是减少GC触发频率，但每次回收时会带来更长的暂停时间。这也意味着内存消耗会更高——由于回收频率低，GC会允许内存增长到更大的值。更长的暂停时间和更高的内存占用通过更高的吞吐量来补偿。虽然单次暂停时间更长，但由于单位时间内处理的数据量更大，累计暂停时间反而更短。  

工作站模式和服务器模式在设计上有重要区别。最显著的一点是托管堆（Managed Heap）的数量。如第5章所述，工作站模式下只有一个托管堆，而服务器模式下默认会为进程可用的每个逻辑核心创建一个托管堆。  

此外，上述两种模式还可以在以下子模式下运行：  

- **非并发模式（Non-concurrent）**：GC执行时会暂停所有托管线程。  
- **并发模式（Concurrent）**：GC的部分工作可以与托管线程并行执行。  

这两种工作模式组合起来，为应用程序提供了四种GC配置选项。第11章将详细讨论这些组合，并分析它们各自的适用场景。为简化说明，第7章至第10章仅讨论最简单的情况——非并发的工作站模式。这样可以在不涉及复杂细节的前提下，帮助您理解GC的核心机制。  还有一点值得回顾：托管堆的三个区域行为有所不同：  

- 小对象堆（SOH）可能使用清扫（Sweep）或压缩（Compact）回收——这主要由GC自主决定。手动触发GC时可以指定偏好。  
- 大对象堆（LOH）默认仅使用清扫回收——但可以显式请求单次压缩回收。在某些情况下（如进程设置了内存限制），GC可能会决定压缩LOH。  
- 固定对象堆（POH）仅使用清扫回收，因为其中所有对象都被固定（pinned），无法移动内存地址。  

> 后续内容会展示.NET Core源码内部实现，供有兴趣深入研究的读者参考。在.NET中启动垃圾回收时，会设置多个标志位来存储选项。其中最重要的之一是`collection_mode`枚举，可能包含以下标志：  
>
> - `collection_non_blocking`：非阻塞（并发）GC  
> - `collection_blocking`：阻塞式（"Stop the World"）GC  
> - `collection_optimized`：仅在需要时触发GC（当指定代的分配预算耗尽时）  
> - `collection_compacting`：带小对象堆压缩的回收  
> - `collection_aggressive`：尽可能释放内存的压缩回收  
> - `collection_gcstress`：CLR内部压力测试模式  

这些手动调优选项将在后续章节详述，现在让我们聚焦于最简单的非并发工作站模式GC。  

# 通过示例理解GC工作——内存段  

此刻，我们认为有必要澄清一些关于GC的常见误解，这有助于您建立对GC活动的高层次认知。  

首先，垃圾回收总是在特定代的上下文中进行——这个代被称为"condemned generation"（待回收代）。分代式GC技术的优势在于可以只回收堆的一部分。如第5章所述，回收时会连带处理所有比当前待回收代更年轻的分代。此外，LOH和POH中的对象在逻辑上属于第2代。因此可能出现以下场景：  

- 第0代待回收：仅回收第0代。  
- 第1代待回收：回收第0代和第1代。  
- 第2代待回收：回收所有三代（0、1、2）以及LOH和POH。这种情况通常称为完全垃圾回收（Full GC）。  

GC工作时，只会对待回收代及其更年轻代中的对象进行可达性分析（标记）。然后GC需要决定是执行清扫回收还是压缩回收。  

让我们用类似第5章图5-5的示意图来可视化这些场景。请花时间彻底理解这些示例场景，因为它们构成了.NET中GC工作机制的核心。  

首先，假设在某个时间点，您程序中的.NET内存布局如图7-1所示。根据第5章的知识，可以识别出这种典型结构——包含SOH（短暂段）和LOH段的连续内存块。SOH段进一步划分为第0、1、2代。各代都包含一些对象，代边界已标出。为简化说明，我们暂时忽略POH。

![](asserts/7-1.png)

图7-1. 后续三幅图例的初始内存状态。对象用斜线填充标识。第0代末端存在空闲空间，SOH段也未被各代完全占用  

现在考虑第0代待回收的示例（见图7-2）。此时标记阶段仅分析第0代对象的可达性。假设第0代只有一个对象被标记为可达（图7-2a，深灰色填充为可达对象）。随后GC需选择回收技术：  

- **清扫回收**（图7-2b）：第0代所有不可达对象转为空闲空间。第1代边界扩展以容纳被提升的可达对象（单个标记对象晋升至第1代）。典型清扫回收会导致第1代碎片化显著增加——可见大块空洞空间。

- **压缩回收**（图7-2c）：第0代可达对象被压缩后并入扩展的第1代。虽无碎片化，但操作更复杂（需内存拷贝及更新对象引用）。

  ![](asserts/7-2.png)

  图7-2. 第0代待回收的垃圾回收：(a)第0代可达对象标记，(b)清扫回收后，(c)压缩回收后  

总结第0代回收后的特点：

- 仅检查第0代对象可达性
- 第0代会被清空——这是默认行为。来自最年轻代的所有对象要么被回收，要么被提升至更老的一代。本章后续将会介绍一些例外情况，但当前我们暂时维持这个简化场景。
- 第0代可达对象晋升至第1代
- 第1代会出现扩展——无论是清扫回收（因碎片化导致扩展幅度更大）还是压缩回收（扩展幅度较小）都是如此。
- 第2代与LOH未变动（但通过卡表扫描了它们指向第0代的引用）

再看第1代待回收案例（图7-3）。此时需分析第0、1代对象可达性。假设第0代1个对象及第1代2个对象被标记（图7-3a）。GC的两种选择：

- **清扫回收**（图7-3b）：第0、1代不可达对象转为空闲空间，调整第1、2代边界容纳晋升对象，导致显著碎片化。

- **压缩回收**（图7-3c）：压缩两代可达对象后调整代际边界。  

  ![](asserts/7-3.png)

  图7-3. 第1代待回收的垃圾回收：(a)两代可达对象标记，(b)清扫回收后，(c)压缩回收后  

第1代回收特点总结：

- 仅检查第0、1代对象可达性
- 第0代清空，其可达对象晋升至第1代
- 第1代可达对象晋升至第2代
- 第1代可能扩展或收缩——具体取决于采用的回收技术。有趣的是，当回收第1代时...第1代反而可能扩展。这显然是碎片化导致的，因此在我们的示例场景中GC不太可能选择清扫回收。不过从理论和技术层面来看，这种情况确实可能发生。
- 第2代扩展
- LOH未变但已扫描其指向年轻代的引用
- 回收第1代与回收第0代在性能表现上存在细微差异——前者通常需要分析更多对象，并可能涉及更多对象的移动/访问。不过这两种情况都在同一个短暂段内操作（部分数据可能已缓存在CPU中），因此实际性能差异通常并不显著。


> 当回收第0代或第1代时，GC还可能采用另一种对象提升技术。在执行压缩回收时，GC不会直接扩展老年代边界来容纳待提升对象，而是尝试利用老年代的空闲空间（通过空闲列表管理）来“分配”这些对象。这种技术既能有效利用内存碎片（同时减少碎片化），又能避免盲目扩展代际范围。
>
> 如图7-3所示场景，第1代中的某个对象可以被安置在第2代的可用空闲空间中：
>
> ![](asserts/7-3a.png)
>
> 这种技术仅适用于压缩式垃圾回收（Compacting GC）。在清扫回收（Sweep Collection）中，由于对象不会被移动，自然无法将其安置到空闲空间。

现在让我们分析第2代被标记为待回收代的情况（参见图7-4）。这种完全回收（Full Collection）需要处理的对象数量远超前两种场景，这正是开发者需要谨慎避免触发过多不必要完全回收的原因（后续章节将详细讨论）。在完全回收过程中，标记阶段会扫描整个托管堆（Managed Heap）——包括第0、1、2代以及大对象堆（LOH）和固定对象堆（POH）。如图7-4a所示，示例中部分对象已被标记为可达。此时GC需要在两种回收技术中做出选择：

- 清扫回收（图7-4b）：所有代中不可达对象（含LOH和POH）都将转为空闲空间。各代边界相应调整。需特别注意：第2代、第1代及LOH会出现严重的内存碎片化

- 压缩回收（图7-4c）：小对象堆（SOH）内所有对象将被压缩（请注意：LOH不会自动压缩，POH则永远不会被压缩）。这是内存使用率最优的方案，但移动大量对象需要付出较大性能代价

  ![](asserts/7-4.png)

  图7-4. 第2代被判定回收的垃圾收集（即完全回收）—— (a) 标记为可达的对象，(b) 清扫收集后，(c) 压缩收集后  

总结而言，当第2代被判定回收的垃圾收集（即完全GC）完成后：  

- 所有代（包括LOH和POH）中的对象可达性均已被检查。第0代变为空。  
- 来自第0代和第1代的可达对象分别被提升至第1代和第2代。  
- 第2代中的可达对象仍保留在第2代。  
- LOH和POH也经历了非压缩式回收——虽然会引入一些内存碎片，但这些空闲空间将被LOH/POH的自由列表分配器重新利用。  

细心的读者可能注意到，每次涉及第1代或第2代回收的GC后，第2代在内存段中的占比可能会增长（如果存在大量长期存活且无法回收的对象）。最终可能出现第2代过大导致第0代或第1代剩余空间不足的情况（参见图7-5a）。此时仅靠清扫或压缩收集可能无法解决问题，GC可能会采用以下步骤的压缩方案（参见图7-5b）：  

- 当前短暂段被转换为专属于第2代的段——所有来自第1代和第2代的可达对象将被压缩存放于此。  
- 新建一个短暂段——所有来自第0代的可达对象作为第1代对象被压缩存放其中。  
- LOH仍按常规方式进行清扫收集。  

![](asserts/7-5.png)

图7-5. 第2代过大时的完全回收—— (a) 标记为可达的对象，(b) 创建新短暂段后的压缩收集  

这意味着第2代可能会“无限”增长。若新短暂段再次出现相同情况，该段将被转为专用第2代段，此时可能出现以下三种情形之一：  

- 通过提交并保留内存创建全新短暂段——如图7-5所示案例
- 从段待命列表（若存在）中获取新短暂段——该机制在第五章图5-26讨论段重用时引入，但需启用VM保留功能（并非默认配置）  
- 将现有第2代占比较小的专用段转为短暂段（参见图7-6）——即使未启用VM保留，也无需强制创建新段  

![](asserts/7-6.png)

图7-6. 完全回收时重用专用第2代段作为新短暂段的压缩收集  

> 需特别注意：将当前短暂段转为专用第2代段（通过重用现有段或创建全新段）可能是由过度固定(pinning)引发——短暂段中大量固定对象会导致内存碎片化，阻碍分配上下文创建，从而促使整个段晋升为第2代。从固定需求角度看这是完全合理的，因为固定对象的地址不会因此改变。  
>

必须反复强调：完全GC需要标记所有代别及LOH中的对象，这些对象可能分布在多个内存段。当大量内存存活时，该过程代价极高。此外，此过程中可能涉及重用第2代段或创建新段，因此完全GC的性能开销可能比仅影响单个（CPU缓存友好的）短暂段的第0/1代GC高出数个数量级，应尽可能避免完全GC！  

# 示例解析GC工作机制——区域模式  

采用区域(region)替代内存段(segment)使垃圾回收机制更通用：不再需要处理同时包含第0代、第1代和潜在第2代的短暂段(ephemeral segment)，也无需区分完整第2代段和LOH段。每个区域仅包含单一代别的对象。虽然仍可采用清扫(Sweep)或压缩(Compact)收集策略，但存在若干差异。

当执行**清扫收集（Sweep collection）**时，无需将标记对象从较年轻代复制到较老代，而是直接晋升整个年轻代区域（参见图7-7b）。这种方式避免了内存中的对象复制操作。  

![](asserts/7-7.png)

图7-7. 第0代清扫式垃圾回收——  (a) 第0代存在大量存活对象，(b) 第0代区域整体晋升，(c) 新建第0代区域  

当所有第0代区域都晋升为第1代后，GC会创建新的第0代区域用于后续内存分配（参见图7-7c）。

对于**压缩收集（Compacting collection）**（参见图7-8a），较年轻代中的标记对象会被“分配”到较老代区域中——要么放入该区域的自由列表(free-list)，要么追加在区域末尾（类似于第0代分配新对象的方式）。这意味着年轻代区域会被清空，但仍保持原代别归属（参见图7-8b）。  

![](asserts/7-8.png)

图7-8. 第0代压缩式垃圾回收——(a) 第0代少量存活对象，(b) 对象被复制到第1代区域，第0代区域加入自由列表

> 若需在.NET Core源码中查看这些晋升/降级机制，可搜索以下关键函数：`gc_heap::decide_on_demotion_pin_surv` 和 `gc_heap::decide_on_promotion_surv`。建议在以下函数设置断点观察区域代际变化：`gc_heap::set_region_plan_gen_num`（计划阶段设置区域代别）和 `gc_heap::set_region_gen_num`（GC结束时最终确定区域代别）。

# 分步解析垃圾回收机制  

在概述垃圾回收器的运行结果后，让我们深入剖析其工作流程。从宏观角度看，垃圾回收过程包含以下步骤：  

1. **触发回收**：特定条件触发GC需求
2. **挂起托管线程**：请求执行引擎暂停所有托管代码线程（非并发GC模式下全程暂停）
3. **执行GC线程**：触发GC的用户线程开始执行垃圾回收代码（仅限非并发工作站模式）
4. **选定回收代别**：根据多种条件判定需要回收的代别
5. **标记阶段**：标记待回收代及其更年轻代中所有可达对象  
6. **规划阶段**：计算压缩情况下对象的新地址，据此决定采用清扫或压缩策略  
7. **执行回收**：根据规划阶段数据执行清扫或压缩（若选择压缩需先执行重定位阶段更新对象引用）  
8. **恢复线程**：请求执行引擎恢复所有托管线程  

本章剩余内容及第8-10章将详细解析每个步骤，这些内容可作为完整GC过程的导航图。  

过程中会通过性能计数器和ETW/EventPipe事件输出诊断数据，部分数据实时输出，部分在GC结束时汇总。通过SOS命令（需使用WinDbg或dotnet-dump工具）还可获取更多分析数据，本章将结合这些工具进行多场景演示。  

## 场景7-1：GC使用情况分析  

**场景描述**：
需要观察电商平台nopCommerce（基于ASP.NET Core的开源系统）在负载测试中的GC行为，该场景延续第5章场景5-1的测试环境。测试采用JMeter工具模拟每秒约7次请求（访问首页、商品页和标签页），对自托管的Nop.Web.exe进程进行两分钟快速诊断。  

**分析步骤**： 让我们跳过负载测试准备的技术细节部分，假设相关流程和工具已就绪。本次负载测试使用JMeter工具设计并执行，采用简单场景（访问首页、单个商品页和单个标签页），每秒约执行7个请求。该测试脚本与场景5-1中使用的JMeter测试完全一致。但本次仅进行两分钟的快速分析，以便快速识别GC（垃圾回收）使用情况。监控对象为自托管的.NET Framework网络应用程序（进程名为Nop.Web.exe）。

首先，你可能需要检查应用程序的整体 .NET 内存消耗和垃圾回收（GC）使用情况。这包括观察以下性能计数器：  

- `\.NET CLR Memory(Nop.Web)\Gen 0 堆大小`（实际上是第 0 代的分配预算，如前面章节所述）
- `\.NET CLR Memory(Nop.Web)\Gen 1 堆大小`
- `\.NET CLR Memory(Nop.Web)\Gen 2 堆大小`
- `\.NET CLR Memory(Nop.Web)\大对象堆（LOH）大小`
- `\.NET CLR Memory(Nop.Web)\% GC 时间`

应用程序运行前两分钟的结果如图 7-7 和 7-8 所示。可以看到各代堆大小相当稳定——短暂代（Gen 0/1）变化较快，但并未随时间增长，而最老一代（Gen 2）稳定在 89,520,308 字节。然而，GC 时间占比（% Time in GC）却令人担忧——平均值约为 24%（图 7-10 清晰可见），意味着进程有四分之一时间耗费在垃圾回收上，这是相当严重的开销！  

若要进一步分析此情况，可使用 PerfView 工具检查 ETW（事件跟踪）事件。在负载测试期间，通过在 Collect（收集）对话框 中选择 GC Collect Only（仅收集 GC 事件），即可记录来自 Microsoft-Windows-DotNETRuntime 提供程序的 GC 关键字事件。收集停止并完成数据处理后，你可以在 Memory Group（内存组）文件夹 中查看 GCStats 报告，从而深入研究 GC 使用情况。  

![](asserts/7-9.png)

图7-9. NopCommerce应用程序在近两分钟负载测试期间各代堆大小的性能监视器视图

![](asserts/7-10.png)

图7-10. NopCommerce 应用程序在近两分钟负载测试期间 GC 利用率的性能监视器视图

`GCStats` 报告完整汇总了会话记录期间所有.NET运行时进程的GC相关事件。打开报告时，所有进程都会列出，因此我们选择Nop.Web进程。报告开头部分展示了多项诊断数据（见图7-11）。例如，"CLR Startup Flags"显示为"None"，表明运行时使用的是简单的非并发工作站GC（Workstation GC）。
