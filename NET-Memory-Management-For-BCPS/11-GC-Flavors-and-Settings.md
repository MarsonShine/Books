# GC模式与设置

前四章详细描述了.NET垃圾回收器（GC）的最基础形态。在本章中，我们将探讨所有GC的变体。除了了解它们的设计原理和原因，我们还将分析其优缺点，涵盖GC的操作模式和延迟设置。

关于.NET中不同的GC模式，最常见的疑问是：如何选择？因此，在了解它们的差异后，我们将尝试回答这一关键问题。本章中的场景还将展示所选模式对应用程序性能和行为的实际影响。

## 模式概览

在第七章开头“高层次视角”一节中，已简要总结了.NET GC可能运行的各种模式。为了建立上下文，当时有必要概述这些模式。现在，我们将深入探讨这些模式的区别及其背后的设计逻辑。

### 工作站模式 vs. 服务器模式

最核心的划分是**工作站模式（Workstation）**和**服务器模式（Server）**。这两种模式自.NET运行时诞生之初便存在，其名称源于它们的目标应用场景。不过，尽管代表典型用途，实际使用中完全可以在桌面应用中选择服务器模式，或在Web应用中选择工作站模式——具体取决于需求。更恰当的方式是将这两种模式视为两组显著不同的GC配置集合。

#### 工作站模式

工作站模式主要针对交互式、基于UI的应用程序对响应速度的需求。良好的交互性要求应用程序的停顿尽可能短暂——用户不希望因长时间GC导致界面卡顿。较长的停顿会影响操作的流畅性和整体响应性。因此：

- **GC触发更频繁，单次工作量更少**：由于对象创建频率较低，产生的垃圾量较少。
- **内存使用更低**：频繁的GC会更积极地回收内存，减少“残留垃圾”。
- **单一托管堆（Managed Heap）**：桌面应用通常单任务处理，无需并行处理多堆。同时，该模式假设计算机上运行着多个应用，每个应用占用部分CPU核心和内存，因此无需（也不适合）通过多线程同时处理多个堆。自设计之初，工作站模式便采用单线程处理单一托管堆。
- **内存段较小**：适用于操作小内存区域（但此特性不适用于“区域（Regions）”内存模型）。

虽然多数桌面应用受益于这些设计，但并非所有场景均适用。例如，某些桌面应用可能在后台触发并行处理（如编译或语法验证），此时需要权衡模式选择。

#### 服务器模式

服务器模式专为需要**并行处理大量请求**的应用程序设计。此类应用通常追求**高吞吐量**——即在单位时间内处理尽可能多的数据。因此：

- **默认内存段更大**（尤其在64位系统上）：在触发GC前可容纳更多内存分配（但此特性不适用于“区域（Regions）”内存模型，因其大小与模式无关）。
- **GC触发频率更低**：由于GC间隔期间创建了更多对象，单次暂停时间通常更长。但由于**多CPU核心并行处理**，实际暂停时间可能短于工作站模式。此外，多次小规模GC的效率低于单次大规模GC——过早回收可能导致本可自然消亡的对象被误保留（存活率随等待时间延长而降低）。最终，累计暂停时间反而更短。
- **内存占用更高**：低频GC会导致更多“残留垃圾”，工作集（Working Set）内存大于工作站模式。但服务器通常配备大容量内存，故这不构成严重问题。
- **多托管堆（Managed Heaps）架构**：根据CPU核心数动态扩展，并行处理多个堆比操作单一巨堆更高效。需注意，在容器化场景中若CPU受限，此优势可能受限。

综上，服务器模式**以更高内存消耗为代价换取更低的总暂停时间**。

> 有人可能会好奇，这两种截然不同的模式在.NET源代码中是如何组织的，以及它们共享多少代码。以.NET Core为例（虽然如第4章所述所有.NET发行版共享相同的GC），其核心实现都集中在同一个 `.\src\coreclr\gc\gc.cpp` 文件中，该文件包含大量由 `#if` 预处理器指令控制的代码块。随后，这个文件会在两个不同的命名空间和预定义宏配置下被编译两次——其中 `.\src\coreclr\gc\gcsvr.cpp` 定义了 `SERVER_GC` 常量和 `SVR` 命名空间：
>
> ```cpp
> #define SERVER_GC 1  
> namespace SVR { 
>     #include "gcimpl.h"  
>     #include "gc.cpp"  
> }
> ```
>
> ```cpp
> namespace WKS {  
>     #include "gcimpl.h"  
>     #include "gc.cpp"  
> }
> ```

因此，当看到各种与GC相关的类型或方法时，它们要么来自 `WKS::` 命名空间，要么来自 `SVR::` 命名空间。定义 `SERVER_GC` 宏会隐式启用其他几个重要宏（尤其是 `MULTIPLE_HEAPS`），而 gc.cpp 中大量代码段都依赖于此宏。

### 非并发模式 vs. 并发模式

除了运行模式之外，GC与用户线程的协作方式还有两种：**并发模式**（GC工作与其他线程并行执行）和**非并发模式**（GC工作时所有用户线程暂停）。

#### 非并发模式

非并发GC自.NET诞生之初就存在，同时支持工作站模式和服务器模式。其实现概念非常简单——所有托管用户线程在GC期间被挂起，GC完成工作后恢复线程执行。

#### 并发模式

并发GC（如名称所示）会在用户线程正常运行时执行。这使得其概念和实现都复杂得多：用户线程与垃圾回收器（Collector）在工作期间必须保持额外同步，以确保双方对内存状态有一致的认知，避免引发严重问题（例如修改已被回收的对象，或误回收仍存活的对象）。这种同步机制的实现显然并非易事，尤其是在需要保持低开销的情况下。后文将具体解析.NET如何实现这种技术。

并发GC在不同.NET版本中的命名有所变化：

- 工作站GC的并发版本自.NET 1.0起提供，最初称为“并发工作站GC”（Concurrent Workstation GC）。.NET 4.0引入重要改进后，更名为“后台工作站GC”（Background Workstation GC）。
- 服务器GC的并发版本直到.NET 4.5才推出，称为“后台服务器GC”（Background Server GC）。

> 在源代码组织层面，这两种模式依然实现在同一个 `.\src\coreclr\gc\gc.cpp` 文件中。并发版本的代码被 `#if BACKGROUND_GC` 预处理器指令包裹。需要注意的是，`BACKGROUND_GC`宏在 SVR 和 WKS 版本中始终被定义，它们同时包含并发与非并发模式的代码，实际运行模式在运行时启动阶段动态启用。

## 模式配置

从前文可知，垃圾回收器存在两个相互独立的配置项，每个配置项有两种可选值，由此组合出四种可能的运行模式。这基本上就是您能对GC进行的全部设置了——习惯了JVM世界高度精细化配置的用户可能会感到惊讶。这显然是经过深思熟虑的设计决策：JVM采用以GC为核心的配置思路，您可以调整几乎所有的GC操作细节，但必须深入理解其原理并明确修改目的；而微软选择了以应用为中心的路径——开发者只需根据应用类型选择对应模式，具体如何响应负载和适应应用特性则由GC自行负责。

后续章节将简要介绍如何在.NET Framework和更新的.NET Core中调整GC工作模式。

请注意，本文不会描述这些设置在项目文件层面（例如 Visual Studio 中）的具体表现形式。整个.NET生态中存在多种工具和项目格式，请参考您所用工具的最新文档。这里呈现的是运行时直接识别的底层配置，这些设置在未来不太可能发生变动。

需特别注意，在仅配备单逻辑CPU核心的机器上，无论 `gcServer` 如何设置，系统始终采用工作站GC模式。

### .NET Framework

对于.NET Framework应用程序，调整GC模式的主要方式是通过标准配置文件（见代码清单11-1）：

- ASP.NET Web应用：托管在IIS中的Web应用需使用 `web.config` 文件。请注意，在此场景下ASP.NET宿主默认启用服务器GC模式（在.NET 4.5+运行时中还会额外启用后台模式）。

- 控制台应用或 Windows 服务：默认使用 `[应用名称].exe.config` 文件。若未指定这些设置，系统默认启用并发工作站模式。这对以请求处理方式处理大量数据的 Windows 服务尤为重要！此类服务的行为更接近服务器应用而非交互式应用，切换至某种服务器GC变体可显著提升性能。

代码清单11-1 .NET Framework应用程序的GC相关配置（`[应用名称].exe.config/Web.config`文件）

```xml
<?xml version="1.0" encoding="utf-8"?>
<configuration>
  <startup>
    <supportedRuntime version="v4.0" sku=".NETFramework,Version=v4.7"/>
  </startup>
  <runtime>
    <gcServer enabled="true"/>
    <gcConcurrent enabled="true"/>
  </runtime>
</configuration>
```

这些配置也可通过环境变量或注册表项设置（路径：`HKCU\Software\Microsoft.NETFramework`）：

- `COMPlus_gcServer=0/1` 环境变量或 `gcServer` 注册表键（值0/1）
- `COMPlus_gcConcurrent=0/1` 环境变量或 `gcConcurrent` 注册表键（值0/1）

### .NET Core

.NET Core在配置方面更为灵活，除文件配置外还提供两种新方式：

文件配置与.NET Framework类似，仅将XML格式改为JSON（见代码清单11-2）。

代码清单11-2 .NET Core应用程序的GC相关配置

```json
SomeApplication.runtimeconfig.json
{
  "runtimeOptions": {
    "tfm": "net8.0",
    "framework": {
      "name": "Microsoft.NETCore.App",
      "version": "8.0.0"
    },
    "configProperties": {
      "System.GC.Server": true,
      "System.GC.Concurrent": true
    }
  }
}
```

.NET Core支持更多称为“配置旋钮（configuration knobs）”的设置，可通过多种方式传值，其中最值得注意的是环境变量方式——这在Docker镜像等严格隔离的环境中尤为实用。完整配置旋钮列表参见：https://learn.microsoft.com/en-us/dotnet/core/runtime-config/garbagecollector：

- `DOTNET_gcServer`/`COMPlus_gcServer=0/1`环境变量或 `gcServer` 注册表键（值0/1）
- `DOTNET_gcConcurrent`/`COMPlus_gcConcurrent=0/1` 环境变量或 `gcConcurrent` 注册表键（值0/1）

> 注意：若同时设置JSON配置和环境变量/注册表，`COMPlus_`/`DOTNET_`前缀的配置具有更高优先级。
>  所有数值均需使用十六进制格式（即使不带0x前缀）。

## GC暂停与开销

自动内存管理这一话题本质上与其引入的开销息息相关。毕竟，GC（垃圾回收器）是作为应用程序的一部分运行的代码。它会消耗CPU周期，并可能在运行期间导致应用程序其余部分暂停工作。此前我们并未特别关注GC活动的开销问题，现在正是探讨这一话题的时机。不同GC运行模式具有不同的性能特征，因此这是分析该问题的理想切入点。

但如何衡量这种开销？我们讨论的究竟是哪方面的开销？从.NET应用程序整体性能的角度来看，可以从两个层面进行分析：

- GC层面：如前所述，GC工作会带来两个最不受欢迎的副作用。

  - **GC暂停**：目前并不存在完全无暂停的GC。应用程序线程被GC暂停显然是不可取的，尤其是在交互式应用中。开发者可能需要测量GC暂停时间（总时长、平均值、百分位数等）。可接受的暂停阈值取决于具体应用特性。一般而言，若频繁出现单次GC暂停超过数十毫秒的情况，就应引起高度警惕。

  - **GC的CPU开销**：执行GC代码与其他代码一样会消耗CPU资源。GC运行时间越长或使用的CPU核心越多，被占用的常规代码执行资源就越多。这对并发和非并发GC同样重要。同样，可接受的GC使用阈值取决于具体应用场景。在常规Web应用中，我们观察到持续超过10%的GC使用率就值得警惕。

- **应用层面**：测量应用程序性能本身可以单独成书，但最核心的指标包括：

  - **吞吐量**：应用程序执行速度，例如单位时间内可处理的HTTP请求数量

  - **延迟**：通常关注尾部延迟，例如耗时最长的X%操作的执行时长

  - **内存消耗**：内存占用量，特别是峰值内存使用情况

图11-1展示了.NET中最常用的两种GC开销测量方式。图中呈现了两个用户线程（T1和T2）和一个GC线程（GC1）的状态随时间变化情况。当线程未占用处理器时间（处于等待状态）时，用虚线表示；当线程执行与GC相关的代码时，用箭头标记；执行程序代码的线程则用浅灰色矩形表示。此外，线程被挂起或恢复的时刻用深灰色区域标注。本章后续将沿用这套图示规范来阐释各GC模式的工作原理。

通过这种呈现方式，可以直观说明两种主流.NET指标：

- GC暂停时间：测量GC非并发阶段的持续时间。包含执行引擎挂起应用程序线程的时间、GC执行时间以及线程恢复时间的总和。该数据可通过PerfView中GCStats报告的“GC Events by Time”表格查看（对应Suspend MSec列记录挂起/恢复耗时，Pause MSec列记录GC处理耗时）。
- CPU相对GC时间占比：描述从上次GC至今的时间段内，GC总耗时（含并发GC阶段）所占的比例。该指标体现在PerfView的GCStats报告中“GC Events by Time”表格的“% GC”列。

> 注：虽然“% Time in GC”性能计数器或“time-in-gc”.NET计数器也可测量GC的CPU开销，但其精确度较低。自引入后台GC后，.NET团队更推荐采用基于CLR事件的测量方式（通过ETW或EventPipe实现）。需特别注意：当未发生GC时，该性能计数器不会更新，将保持显示前次测量值。因此，若在性能监视器中看到持续显示99%的GC时间，可能只是上次GC的未更新数据——此时应通过检查“# Gen 0 Collections”性能计数器或“gen-0-gccount”.NET计数器等指标来确认是否发生了新的GC。

![](asserts/11-1.png)

图11-1 暂停时间与GC耗时占比——典型的.NET GC度量指标

众多免费或商业工具均可提供类似指标，但其测量方式可能存在差异，具体细节请参阅各工具文档。

我们将在分析不同GC模式时再次讨论这些度量指标。现在，让我们开始详细解读.NET垃圾回收的四种工作模式。

## 模式描述

接下来的小节将介绍四种垃圾回收（GC）模式的工作原理。这些模式已通过类似图11-1的示意图进行说明。为简洁起见，大多数示意图中省略了暂停/恢复块，但需注意这些操作会在GC的每个非并发阶段前后发生。此外，所有示意图均假设分配器（Allocator）在某一时刻判定需要触发GC。图表中的时间长度仅为示意用途，实际GC/用户线程的耗时应通过专业工具测量。

每种模式的描述均附有典型应用场景列表。

### 工作站非并发模式

最简单的GC模式实际上已在第7至10章详细阐述，它是.NET中GC工作机制的基础。后文将直接称其为“非并发GC”（省略“工作站”或“服务器”标注）。该模式具有以下特征（见图11-2）：

- 所有托管线程在GC全程都会被挂起，无论进行的是0代、1代还是2代（完全GC）垃圾回收。单次短暂GC耗时极短，因此采用非并发方式并无问题。但图中特别指出，完全阻塞式GC（非并发模式下的完全GC称为完全阻塞式GC）可能比短暂GC消耗更多时间，这类GC会显著影响系统响应。
- GC代码由触发回收的用户线程执行（在分配器内部触发），且不改变该线程的常规优先级（通常为普通优先级），因此需与其他应用程序线程竞争CPU资源。
- GC始终在“全局停顿（STW）”阶段执行，且可根据策略决定是否启用压缩。

![](asserts/11-2.png)

图11-2 工作站非并发GC模式示意图

若要通过CLR事件跟踪此类GC行为，其事件发射流程如图11-3所示。本书采用PerfView工具中的命名规范，但若查阅GC源码可见四个事件的命名与PerfView显示存在差异：

```
– GCSuspendEEStart is GCSuspendEEBegin (id = 9).
– GCSuspendEEStop is GCSuspendEEEnd (id = 8).
– GCRestartEEStart is GCRestartEEBegin (id = 7).
– GCRestartEEStop is GCRestartEEEnd (id = 3).
```

![](asserts/11-3.png)

图11-3 工作站非并发GC模式下触发的CLR事件

典型应用场景：

- 高负载竞争环境：当多个应用程序激烈争夺有限CPU资源时，由于该模式仅使用单线程执行回收，可显著降低GC对CPU核心资源的占用影响
- 轻量级Web应用环境（如容器化微服务）：若应用内存占用较小且性能需求不高，非并发GC既能满足需求，又可通过限制线程数量节省系统资源

### 工作站并发模式（4.0版本前）

如前所述，该模式原称“并发GC”，在4.0及后续版本中被“后台GC”取代。因此我们不会过多关注此模式（例如省略整个并发GC实现章节）。下一节介绍的继任模式本质上也会涵盖本模式特性。工作站非并发GC模式具有以下特征（见图11-4）：

- 存在一个专用于GC的附加线程——该线程大部分时间处于挂起状态等待工作任务。
-  短期代际回收始终采用非并发模式——其执行速度足够快，无需并发处理。这也使得它们在必要时可进行压缩。
-  完全GC可运行于两种模式：
  -  非并发GC：由于“停止所有线程”的特性，此类完全GC可执行压缩操作。
  -  并发GC：大部分工作在不挂起托管线程的情况下执行。鉴于实现复杂度，此GC变体不支持压缩。
- 并发式完全GC还具有以下附加特征：
  - 用户托管线程在其执行期间仍可分配对象——但此类分配受限于短期代段大小（因为在并发GC期间无法触发其他GC来腾出空间）。若空间耗尽，用户线程将被挂起直至完全GC结束。
  - 包含两次短暂的“停止所有线程”阶段——分别位于GC开始阶段和中间阶段。
  - 自GC开始至第二次“停止所有线程”阶段前分配的对象将被提升代际。
  - 第二次“停止所有线程”阶段后分配的所有对象都将被提升代际。

![](asserts/11-4.png)

图 11-4. 工作站并发GC模式示意图（适用于.NET Framework 4.0之前版本）

典型使用场景：

对于.NET 4.0之前的大多数UI应用程序而言，并发GC在缩短暂停时间方面实现了重大改进——这对交互式应用程序至关重要。在大多数情况下，该系统能有效避免由GC引起的明显卡顿。但需要注意的是，并发GC不执行内存压缩，因此仍需定期触发非并发的完全GC来缓解内存碎片问题。该模式存在一个严重限制：当短期代段空间耗尽时，必须阻塞正在分配内存的线程。工作站模式下的内存段容量较小（32位模式下仅16MB），即便采用并发GC，也可能因短期代段空间频繁耗尽而导致线程暂停次数超出预期。后续推出的后台工作站GC模式正是为突破这些限制而设计的重大改进。

### 后台工作站模式

自.NET Framework 4.0起，后台工作站GC取代了工作站并发GC，并延续至.NET Core。其核心改进在于：即使在并发GC期间，也能按需触发短期代际回收。该模式解除了普通线程的内存分配限制，显著降低了后台GC操作对系统的影响。

后台工作站GC模式具有以下特征（多数与工作站并发GC相似，见图11-5）：

- 配备一个专用于GC的附加线程——该线程大部分时间处于挂起待命状态

- 短期代际回收采用非并发模式——其执行速度足够快，无需并发处理。这也使得必要时可进行内存压缩

- 完全GC支持两种执行模式：

  - 非并发GC：基于“停止所有线程”特性，此类完全GC可执行压缩。

  - 后台GC：大部分工作在不挂起托管线程的情况下完成。与并发GC相同，此模式不支持压缩。

- 后台完全GC还具有以下特性：

  - 托管线程在其执行期间可继续分配对象——此类分配可能触发常规短期代际回收（称为前台GC，与后台GC相对应）。

  - 在后台GC过程中可能多次发生前台GC。如.NET官方文档所述：“专用后台垃圾回收线程会在安全点频繁检查是否存在前台GC请求”。前台GC属于常规非并发回收，此时后台GC会暂时挂起。由于系统处于完全暂停状态，前台GC可执行压缩操作，甚至能通过创建新内存段/区域来扩展堆空间。

  - 包含两次短暂的“停止所有线程”阶段——分别位于开始阶段和中间阶段（后续将详细说明）。

![](asserts/11-5.png)

图11-5 后台工作站GC模式示意图（自.NET Framework 4.0起可用）

