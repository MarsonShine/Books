# GC模式与设置

前四章详细描述了.NET垃圾回收器（GC）的最基础形态。在本章中，我们将探讨所有GC的变体。除了了解它们的设计原理和原因，我们还将分析其优缺点，涵盖GC的操作模式和延迟设置。

关于.NET中不同的GC模式，最常见的疑问是：如何选择？因此，在了解它们的差异后，我们将尝试回答这一关键问题。本章中的场景还将展示所选模式对应用程序性能和行为的实际影响。

## 模式概览

在第七章开头“高层次视角”一节中，已简要总结了.NET GC可能运行的各种模式。为了建立上下文，当时有必要概述这些模式。现在，我们将深入探讨这些模式的区别及其背后的设计逻辑。

### 工作站模式 vs. 服务器模式

最核心的划分是**工作站模式（Workstation）**和**服务器模式（Server）**。这两种模式自.NET运行时诞生之初便存在，其名称源于它们的目标应用场景。不过，尽管代表典型用途，实际使用中完全可以在桌面应用中选择服务器模式，或在Web应用中选择工作站模式——具体取决于需求。更恰当的方式是将这两种模式视为两组显著不同的GC配置集合。

#### 工作站模式

工作站模式主要针对交互式、基于UI的应用程序对响应速度的需求。良好的交互性要求应用程序的停顿尽可能短暂——用户不希望因长时间GC导致界面卡顿。较长的停顿会影响操作的流畅性和整体响应性。因此：

- **GC触发更频繁，单次工作量更少**：由于对象创建频率较低，产生的垃圾量较少。
- **内存使用更低**：频繁的GC会更积极地回收内存，减少“残留垃圾”。
- **单一托管堆（Managed Heap）**：桌面应用通常单任务处理，无需并行处理多堆。同时，该模式假设计算机上运行着多个应用，每个应用占用部分CPU核心和内存，因此无需（也不适合）通过多线程同时处理多个堆。自设计之初，工作站模式便采用单线程处理单一托管堆。
- **内存段较小**：适用于操作小内存区域（但此特性不适用于“区域（Regions）”内存模型）。

虽然多数桌面应用受益于这些设计，但并非所有场景均适用。例如，某些桌面应用可能在后台触发并行处理（如编译或语法验证），此时需要权衡模式选择。

#### 服务器模式

服务器模式专为需要**并行处理大量请求**的应用程序设计。此类应用通常追求**高吞吐量**——即在单位时间内处理尽可能多的数据。因此：

- **默认内存段更大**（尤其在64位系统上）：在触发GC前可容纳更多内存分配（但此特性不适用于“区域（Regions）”内存模型，因其大小与模式无关）。
- **GC触发频率更低**：由于GC间隔期间创建了更多对象，单次暂停时间通常更长。但由于**多CPU核心并行处理**，实际暂停时间可能短于工作站模式。此外，多次小规模GC的效率低于单次大规模GC——过早回收可能导致本可自然消亡的对象被误保留（存活率随等待时间延长而降低）。最终，累计暂停时间反而更短。
- **内存占用更高**：低频GC会导致更多“残留垃圾”，工作集（Working Set）内存大于工作站模式。但服务器通常配备大容量内存，故这不构成严重问题。
- **多托管堆（Managed Heaps）架构**：根据CPU核心数动态扩展，并行处理多个堆比操作单一巨堆更高效。需注意，在容器化场景中若CPU受限，此优势可能受限。

综上，服务器模式**以更高内存消耗为代价换取更低的总暂停时间**。

> 有人可能会好奇，这两种截然不同的模式在.NET源代码中是如何组织的，以及它们共享多少代码。以.NET Core为例（虽然如第4章所述所有.NET发行版共享相同的GC），其核心实现都集中在同一个 `.\src\coreclr\gc\gc.cpp` 文件中，该文件包含大量由 `#if` 预处理器指令控制的代码块。随后，这个文件会在两个不同的命名空间和预定义宏配置下被编译两次——其中 `.\src\coreclr\gc\gcsvr.cpp` 定义了 `SERVER_GC` 常量和 `SVR` 命名空间：
>
> ```cpp
> #define SERVER_GC 1  
> namespace SVR { 
>     #include "gcimpl.h"  
>     #include "gc.cpp"  
> }
> ```
>
> ```cpp
> namespace WKS {  
>     #include "gcimpl.h"  
>     #include "gc.cpp"  
> }
> ```

因此，当看到各种与GC相关的类型或方法时，它们要么来自 `WKS::` 命名空间，要么来自 `SVR::` 命名空间。定义 `SERVER_GC` 宏会隐式启用其他几个重要宏（尤其是 `MULTIPLE_HEAPS`），而 gc.cpp 中大量代码段都依赖于此宏。

### 非并发模式 vs. 并发模式

除了运行模式之外，GC与用户线程的协作方式还有两种：**并发模式**（GC工作与其他线程并行执行）和**非并发模式**（GC工作时所有用户线程暂停）。

#### 非并发模式

非并发GC自.NET诞生之初就存在，同时支持工作站模式和服务器模式。其实现概念非常简单——所有托管用户线程在GC期间被挂起，GC完成工作后恢复线程执行。

#### 并发模式

并发GC（如名称所示）会在用户线程正常运行时执行。这使得其概念和实现都复杂得多：用户线程与垃圾回收器（Collector）在工作期间必须保持额外同步，以确保双方对内存状态有一致的认知，避免引发严重问题（例如修改已被回收的对象，或误回收仍存活的对象）。这种同步机制的实现显然并非易事，尤其是在需要保持低开销的情况下。后文将具体解析.NET如何实现这种技术。

并发GC在不同.NET版本中的命名有所变化：

- 工作站GC的并发版本自.NET 1.0起提供，最初称为“并发工作站GC”（Concurrent Workstation GC）。.NET 4.0引入重要改进后，更名为“后台工作站GC”（Background Workstation GC）。
- 服务器GC的并发版本直到.NET 4.5才推出，称为“后台服务器GC”（Background Server GC）。

> 在源代码组织层面，这两种模式依然实现在同一个 `.\src\coreclr\gc\gc.cpp` 文件中。并发版本的代码被 `#if BACKGROUND_GC` 预处理器指令包裹。需要注意的是，`BACKGROUND_GC`宏在 SVR 和 WKS 版本中始终被定义，它们同时包含并发与非并发模式的代码，实际运行模式在运行时启动阶段动态启用。

## 模式配置

从前文可知，垃圾回收器存在两个相互独立的配置项，每个配置项有两种可选值，由此组合出四种可能的运行模式。这基本上就是您能对GC进行的全部设置了——习惯了JVM世界高度精细化配置的用户可能会感到惊讶。这显然是经过深思熟虑的设计决策：JVM采用以GC为核心的配置思路，您可以调整几乎所有的GC操作细节，但必须深入理解其原理并明确修改目的；而微软选择了以应用为中心的路径——开发者只需根据应用类型选择对应模式，具体如何响应负载和适应应用特性则由GC自行负责。

后续章节将简要介绍如何在.NET Framework和更新的.NET Core中调整GC工作模式。

请注意，本文不会描述这些设置在项目文件层面（例如 Visual Studio 中）的具体表现形式。整个.NET生态中存在多种工具和项目格式，请参考您所用工具的最新文档。这里呈现的是运行时直接识别的底层配置，这些设置在未来不太可能发生变动。

需特别注意，在仅配备单逻辑CPU核心的机器上，无论 `gcServer` 如何设置，系统始终采用工作站GC模式。

### .NET Framework

对于.NET Framework应用程序，调整GC模式的主要方式是通过标准配置文件（见代码清单11-1）：

- ASP.NET Web应用：托管在IIS中的Web应用需使用 `web.config` 文件。请注意，在此场景下ASP.NET宿主默认启用服务器GC模式（在.NET 4.5+运行时中还会额外启用后台模式）。

- 控制台应用或 Windows 服务：默认使用 `[应用名称].exe.config` 文件。若未指定这些设置，系统默认启用并发工作站模式。这对以请求处理方式处理大量数据的 Windows 服务尤为重要！此类服务的行为更接近服务器应用而非交互式应用，切换至某种服务器GC变体可显著提升性能。

代码清单11-1 .NET Framework应用程序的GC相关配置（`[应用名称].exe.config/Web.config`文件）

```xml
<?xml version="1.0" encoding="utf-8"?>
<configuration>
  <startup>
    <supportedRuntime version="v4.0" sku=".NETFramework,Version=v4.7"/>
  </startup>
  <runtime>
    <gcServer enabled="true"/>
    <gcConcurrent enabled="true"/>
  </runtime>
</configuration>
```

这些配置也可通过环境变量或注册表项设置（路径：`HKCU\Software\Microsoft.NETFramework`）：

- `COMPlus_gcServer=0/1` 环境变量或 `gcServer` 注册表键（值0/1）
- `COMPlus_gcConcurrent=0/1` 环境变量或 `gcConcurrent` 注册表键（值0/1）

### .NET Core

.NET Core在配置方面更为灵活，除文件配置外还提供两种新方式：

文件配置与.NET Framework类似，仅将XML格式改为JSON（见代码清单11-2）。

代码清单11-2 .NET Core应用程序的GC相关配置

```json
SomeApplication.runtimeconfig.json
{
  "runtimeOptions": {
    "tfm": "net8.0",
    "framework": {
      "name": "Microsoft.NETCore.App",
      "version": "8.0.0"
    },
    "configProperties": {
      "System.GC.Server": true,
      "System.GC.Concurrent": true
    }
  }
}
```

.NET Core支持更多称为“配置旋钮（configuration knobs）”的设置，可通过多种方式传值，其中最值得注意的是环境变量方式——这在Docker镜像等严格隔离的环境中尤为实用。完整配置旋钮列表参见：https://learn.microsoft.com/en-us/dotnet/core/runtime-config/garbagecollector：

- `DOTNET_gcServer`/`COMPlus_gcServer=0/1`环境变量或 `gcServer` 注册表键（值0/1）
- `DOTNET_gcConcurrent`/`COMPlus_gcConcurrent=0/1` 环境变量或 `gcConcurrent` 注册表键（值0/1）

> 注意：若同时设置JSON配置和环境变量/注册表，`COMPlus_`/`DOTNET_`前缀的配置具有更高优先级。
>  所有数值均需使用十六进制格式（即使不带0x前缀）。

## GC暂停与开销

自动内存管理这一话题本质上与其引入的开销息息相关。毕竟，GC（垃圾回收器）是作为应用程序的一部分运行的代码。它会消耗CPU周期，并可能在运行期间导致应用程序其余部分暂停工作。此前我们并未特别关注GC活动的开销问题，现在正是探讨这一话题的时机。不同GC运行模式具有不同的性能特征，因此这是分析该问题的理想切入点。

但如何衡量这种开销？我们讨论的究竟是哪方面的开销？从.NET应用程序整体性能的角度来看，可以从两个层面进行分析：

- GC层面：如前所述，GC工作会带来两个最不受欢迎的副作用。

  - **GC暂停**：目前并不存在完全无暂停的GC。应用程序线程被GC暂停显然是不可取的，尤其是在交互式应用中。开发者可能需要测量GC暂停时间（总时长、平均值、百分位数等）。可接受的暂停阈值取决于具体应用特性。一般而言，若频繁出现单次GC暂停超过数十毫秒的情况，就应引起高度警惕。

  - **GC的CPU开销**：执行GC代码与其他代码一样会消耗CPU资源。GC运行时间越长或使用的CPU核心越多，被占用的常规代码执行资源就越多。这对并发和非并发GC同样重要。同样，可接受的GC使用阈值取决于具体应用场景。在常规Web应用中，我们观察到持续超过10%的GC使用率就值得警惕。

- **应用层面**：测量应用程序性能本身可以单独成书，但最核心的指标包括：

  - **吞吐量**：应用程序执行速度，例如单位时间内可处理的HTTP请求数量

  - **延迟**：通常关注尾部延迟，例如耗时最长的X%操作的执行时长

  - **内存消耗**：内存占用量，特别是峰值内存使用情况

图11-1展示了.NET中最常用的两种GC开销测量方式。图中呈现了两个用户线程（T1和T2）和一个GC线程（GC1）的状态随时间变化情况。当线程未占用处理器时间（处于等待状态）时，用虚线表示；当线程执行与GC相关的代码时，用箭头标记；执行程序代码的线程则用浅灰色矩形表示。此外，线程被挂起或恢复的时刻用深灰色区域标注。本章后续将沿用这套图示规范来阐释各GC模式的工作原理。

通过这种呈现方式，可以直观说明两种主流.NET指标：

- GC暂停时间：测量GC非并发阶段的持续时间。包含执行引擎挂起应用程序线程的时间、GC执行时间以及线程恢复时间的总和。该数据可通过PerfView中GCStats报告的“GC Events by Time”表格查看（对应Suspend MSec列记录挂起/恢复耗时，Pause MSec列记录GC处理耗时）。
- CPU相对GC时间占比：描述从上次GC至今的时间段内，GC总耗时（含并发GC阶段）所占的比例。该指标体现在PerfView的GCStats报告中“GC Events by Time”表格的“% GC”列。

> 注：虽然“% Time in GC”性能计数器或“time-in-gc”.NET计数器也可测量GC的CPU开销，但其精确度较低。自引入后台GC后，.NET团队更推荐采用基于CLR事件的测量方式（通过ETW或EventPipe实现）。需特别注意：当未发生GC时，该性能计数器不会更新，将保持显示前次测量值。因此，若在性能监视器中看到持续显示99%的GC时间，可能只是上次GC的未更新数据——此时应通过检查“# Gen 0 Collections”性能计数器或“gen-0-gccount”.NET计数器等指标来确认是否发生了新的GC。

![](asserts/11-1.png)

图11-1 暂停时间与GC耗时占比——典型的.NET GC度量指标

众多免费或商业工具均可提供类似指标，但其测量方式可能存在差异，具体细节请参阅各工具文档。

我们将在分析不同GC模式时再次讨论这些度量指标。现在，让我们开始详细解读.NET垃圾回收的四种工作模式。

## 模式描述

接下来的小节将介绍四种垃圾回收（GC）模式的工作原理。这些模式已通过类似图11-1的示意图进行说明。为简洁起见，大多数示意图中省略了暂停/恢复块，但需注意这些操作会在GC的每个非并发阶段前后发生。此外，所有示意图均假设分配器（Allocator）在某一时刻判定需要触发GC。图表中的时间长度仅为示意用途，实际GC/用户线程的耗时应通过专业工具测量。

每种模式的描述均附有典型应用场景列表。

### 工作站非并发模式

最简单的GC模式实际上已在第7至10章详细阐述，它是.NET中GC工作机制的基础。后文将直接称其为“非并发GC”（省略“工作站”或“服务器”标注）。该模式具有以下特征（见图11-2）：

- 所有托管线程在GC全程都会被挂起，无论进行的是0代、1代还是2代（完全GC）垃圾回收。单次短暂GC耗时极短，因此采用非并发方式并无问题。但图中特别指出，完全阻塞式GC（非并发模式下的完全GC称为完全阻塞式GC）可能比短暂GC消耗更多时间，这类GC会显著影响系统响应。
- GC代码由触发回收的用户线程执行（在分配器内部触发），且不改变该线程的常规优先级（通常为普通优先级），因此需与其他应用程序线程竞争CPU资源。
- GC始终在“全局停顿（STW）”阶段执行，且可根据策略决定是否启用压缩。

![](asserts/11-2.png)

图11-2 工作站非并发GC模式示意图

若要通过CLR事件跟踪此类GC行为，其事件发射流程如图11-3所示。本书采用PerfView工具中的命名规范，但若查阅GC源码可见四个事件的命名与PerfView显示存在差异：

```
– GCSuspendEEStart is GCSuspendEEBegin (id = 9).
– GCSuspendEEStop is GCSuspendEEEnd (id = 8).
– GCRestartEEStart is GCRestartEEBegin (id = 7).
– GCRestartEEStop is GCRestartEEEnd (id = 3).
```

![](asserts/11-3.png)

图11-3 工作站非并发GC模式下触发的CLR事件

典型应用场景：

- 高负载竞争环境：当多个应用程序激烈争夺有限CPU资源时，由于该模式仅使用单线程执行回收，可显著降低GC对CPU核心资源的占用影响
- 轻量级Web应用环境（如容器化微服务）：若应用内存占用较小且性能需求不高，非并发GC既能满足需求，又可通过限制线程数量节省系统资源

### 工作站并发模式（4.0版本前）

如前所述，该模式原称“并发GC”，在4.0及后续版本中被“后台GC”取代。因此我们不会过多关注此模式（例如省略整个并发GC实现章节）。下一节介绍的继任模式本质上也会涵盖本模式特性。工作站非并发GC模式具有以下特征（见图11-4）：

- 存在一个专用于GC的附加线程——该线程大部分时间处于挂起状态等待工作任务。
-  短期代际回收始终采用非并发模式——其执行速度足够快，无需并发处理。这也使得它们在必要时可进行压缩。
-  完全GC可运行于两种模式：
  -  非并发GC：由于“停止所有线程”的特性，此类完全GC可执行压缩操作。
  -  并发GC：大部分工作在不挂起托管线程的情况下执行。鉴于实现复杂度，此GC变体不支持压缩。
- 并发式完全GC还具有以下附加特征：
  - 用户托管线程在其执行期间仍可分配对象——但此类分配受限于短期代段大小（因为在并发GC期间无法触发其他GC来腾出空间）。若空间耗尽，用户线程将被挂起直至完全GC结束。
  - 包含两次短暂的“停止所有线程”阶段——分别位于GC开始阶段和中间阶段。
  - 自GC开始至第二次“停止所有线程”阶段前分配的对象将被提升代际。
  - 第二次“停止所有线程”阶段后分配的所有对象都将被提升代际。

![](asserts/11-4.png)

图 11-4. 工作站并发GC模式示意图（适用于.NET Framework 4.0之前版本）

典型使用场景：

对于.NET 4.0之前的大多数UI应用程序而言，并发GC在缩短暂停时间方面实现了重大改进——这对交互式应用程序至关重要。在大多数情况下，该系统能有效避免由GC引起的明显卡顿。但需要注意的是，并发GC不执行内存压缩，因此仍需定期触发非并发的完全GC来缓解内存碎片问题。该模式存在一个严重限制：当短期代段空间耗尽时，必须阻塞正在分配内存的线程。工作站模式下的内存段容量较小（32位模式下仅16MB），即便采用并发GC，也可能因短期代段空间频繁耗尽而导致线程暂停次数超出预期。后续推出的后台工作站GC模式正是为突破这些限制而设计的重大改进。

### 后台工作站模式

自.NET Framework 4.0起，后台工作站GC取代了工作站并发GC，并延续至.NET Core。其核心改进在于：即使在并发GC期间，也能按需触发短期代际回收。该模式解除了普通线程的内存分配限制，显著降低了后台GC操作对系统的影响。

后台工作站GC模式具有以下特征（多数与工作站并发GC相似，见图11-5）：

- 配备一个专用于GC的附加线程——该线程大部分时间处于挂起待命状态

- 短期代际回收采用非并发模式——其执行速度足够快，无需并发处理。这也使得必要时可进行内存压缩

- 完全GC支持两种执行模式：

  - 非并发GC：基于“停止所有线程”特性，此类完全GC可执行压缩。

  - 后台GC：大部分工作在不挂起托管线程的情况下完成。与并发GC相同，此模式不支持压缩。

- 后台完全GC还具有以下特性：

  - 托管线程在其执行期间可继续分配对象——此类分配可能触发常规短期代际回收（称为前台GC，与后台GC相对应）。

  - 在后台GC过程中可能多次发生前台GC。如.NET官方文档所述：“专用后台垃圾回收线程会在安全点频繁检查是否存在前台GC请求”。前台GC属于常规非并发回收，此时后台GC会暂时挂起。由于系统处于完全暂停状态，前台GC可执行压缩操作，甚至能通过创建新内存段/区域来扩展堆空间。

  - 包含两次短暂的“停止所有线程”阶段——分别位于开始阶段和中间阶段（后续将详细说明）。

![](asserts/11-5.png)

图11-5 后台工作站GC模式示意图（自.NET Framework 4.0起可用）

现在我们来深入剖析“后台工作站模式”的“解剖结构”。其针对0代、1代或2代的非并发垃圾回收（GC）过程较为简单。但后台GC究竟如何运作？前台GC又会在哪些具体时机触发？当分析后台GC时，可将其划分为以下几个阶段（参见图11-6）：

- 初始“全局暂停”阶段（A）：当分配器触发常规GC代码时，系统决定启动后台GC。此阶段通常还需执行常规的短暂代GC（例如某些分配预算已耗尽）。在此阶段会完成对象的初始标记，这些标记数据将供后续后台GC使用。

- 并发标记阶段（B）：在恢复用户线程运行的同时，后台GC通过并发方式追踪对象可达性。本章后续将详述如何在用户线程并行操作的情况下实现这一机制。此阶段可能因内存分配触发零次或多次前台GC。
- 最终标记的“全局暂停”阶段（C）：暂停所有用户线程时，后台GC将最终确定要在下一阶段回收的对象可达性。
- 并发清理阶段（D）：在用户线程正常运行期间，GC可以安全清理阶段C已确认的废弃对象。此阶段仍可能发生额外的前台GC。

![](asserts/11-6.jpg)

图11-6. 后台工作站GC模式的深度剖析

若要通过ETW/EventPipe事件追踪此类后台与前台GC，其事件生成逻辑如图11-7所示。相较于简单的非并发GC（如图11-3所示），这里会产生更多事件类型。如图所示，除典型GC事件外，还存在一系列以BGC为前缀的事件，用于详细描述后台GC过程。其中 `BGCRevisit` 和 `BGCDrainMark` 事件将在后续说明，其他事件名称已具备自解释性。需注意图11-7展示的是后台GC期间仅触发单次前台GC的情况。所有BGC前缀事件均由  `Microsoft-Windows-DotNETRuntimePrivate` 提供程序生成。该提供程序默认未被 `dotnet-trace` 启用，需在命令行中显式指定，例如：`dotnet trace collect --providers "Microsoft-Windows-DotNETRuntimePrivate:1:5,Microsoft-Windows-DotNETRuntime:1:5" -p <进程ID>`。提供程序列表的语法格式为：提供程序名称后接关键字（此处 `1` 代表GC关键字）和详细级别（此处 `5` 表示详细模式）。用户可使用Visual Studio便捷地可视化事件列表并按需筛选。再次提醒，若查阅.NET源代码，会发现事件命名存在差异——部分事件以“Begin”替代“Start”，以“End”替代“Stop”。

![](asserts/11-7.png)

图11-7. 单次后台工作站GC过程中触发的ETW/EventPipe事件

> 后台GC的大部分代码在工作站(Workstation)和服务器(Server)版本间共享（主要区别在于执行线程数），这些代码会在SVR和WKS命名空间下分别编译。若要在.NET代码中研究该机制，建议从 `gc_heap::garbage_collect` 方法入手，重点关注 `do_concurrent_p` 标志位的使用。当后台GC启动时，系统会调用 `gc_heap::do_background_gc` 方法来唤醒后台GC线程。值得注意的是，前台GC和后台GC均由相同的 `gc_heap::gc1` 方法实现，其差异在于全局设置 `concurrent` 标志位的状态：
>
> - 执行前台GC时，`gc_heap::gc1` 方法在 `concurrent` 标志禁用状态下运行（即第7-10章描述的常规模式）
> - 执行后台GC时，`gc_heap::gc1` 方法在独立线程中以 `concurrent` 标志启用状态运行，进而触发 `gc_heap::background_mark_phase` 和 `gc_heap::background_sweep` 方法的执行（下节将简要说明这两个方法）

典型应用场景：大多数UI应用程序会极力优化后台工作站GC的暂停时间，这使得该模式特别适合各类交互式应用（尤其是基于UI的程序）。但需注意，由于后台GC仍不执行压缩操作，内存碎片化可能逐渐累积，最终可能触发阻塞式完全GC来缓解此问题——这将对UI响应性产生负面影响。

#### 并发标记

人们可能会疑惑，如何在用户线程运行时确定对象可达性。这些线程持续修改对象、创建和删除对象间的引用关系。在如此动态的条件下，如何发现可达性呢？

如您所知，.NET中的追踪式垃圾回收器通过从各类根节点出发遍历整个对象图来实现对象可达性发现（参见第1章“标记阶段”章节及图1-15）。被访问的对象会被标记，最终只有带标记的对象被视为存活对象，其余则作为垃圾回收。这种机制在与用户线程并发工作时会引发两个核心问题：

- 如何在不干扰用户线程工作的前提下标记对象？
- 如何确保用户线程与回收器对对象关系的认知保持一致性？

首先考虑对象标记问题。第8章提到，标记对象意味着设置其方法表指针中的一个特定位。这在“停止所有线程”模式下完全可行，但在线程可能使用该指针时修改如此关键的指针——无论出于安全性还是性能考量（包括缓存失效问题）——都是不可接受的。

> 用户线程可能正在读取或依赖方法表指针（MT）中的信息（例如，进行虚方法调用、类型检查）。在它使用时修改这个指针（哪怕只是一个位）是极其危险的，可能导致崩溃或不可预测的行为。并且MT是指向类型元数据的重要指针，CPU缓存会高度优化对其的访问。频繁修改MT中的位会导致缓存行失效（cache line invalidation）和伪共享（false sharing）问题，严重拖慢用户线程和GC自身的性能。

因此，并发标记将标记信息存储在专用的独立标记数组中。其组织结构类似于第5章描述的卡表：标记数组中每个比特位对应托管堆上16字节区域（32位运行时为8字节），如图11-8所示。标记数组按4字节长的标记字进行组织。当GC访问对象并需要标记时，会设置标记数组中相应的比特位。由于GC是标记数组的唯一所有者，访问时不存在同步问题。更重要的是，在并发标记过程中这些比特位只能被置位而不会被清除——这使得多线程并行执行并发标记时（如后文将介绍的后台服务器GC模式）的同步机制大为简化。

> GC修改的是自己专属的标记数组，用户线程完全不感知这个数组，也不会直接访问它。对象本身的MT指针保持不变。由于只有GC线程会写入这个标记数组（在并发标记期间），并且规则是“只能置位，不能清除”，这大大简化了同步。
>
> **“只能置位，不能清除”**：这意味着如果多个GC线程（在并行并发标记，如后台服务器GC中）同时发现一个对象可达，它们都去设置同一个比特位，结果是一样的（位被置1），不会有冲突。如果允许清除，就需要复杂的锁机制来协调。
>
> Mark Array 是一个位数组，其中的每个位（bit）对应托管堆中的一小块内存区域。在 64 位系统中，每个位对应 **16 字节** 的托管堆区域；在 32 位系统中，每个位对应 8 字节的区域[2](https://goodies.dotnetos.org/files/03. NET GC Internals - Concurrent Mark phase.pdf)。因此，一个比特位对应 16 字节的说法是正确的（针对 64 位环境）。而且它的设计是为了存储对象标记信息而不直接修改对象本身的元数据（如 MethodTable），以避免多线程并发时的冲突和缓存失效问题。
>
> 只需要标示“这个区域**有没有**一个被标记为重要的房子（对象）的**起点**或**一部分**”。
>
> 此外，Mark Array 的大小是相对于托管堆的大小按比例分配的，比如在 64 位系统中，每 1GB 的托管堆大约需要 8MB 的 Mark Array 内存[2](https://goodies.dotnetos.org/files/03. NET GC Internals - Concurrent Mark phase.pdf)。
>
> 标记数组的粒度：1个比特位对应16字节的托管堆区域。
>
> - 想象托管堆被划分成连续的、每块16字节的小格子。
> - 标记数组中的每一个比特位就负责这样一个16字节的小格子。
> - 如果GC标记了一个对象，它会找到这个对象**起始位置**所在的那个（或那些，如果对象跨越多个格子）16字节格子，然后在标记数组中将对应这个格子的比特位置为1。



![](asserts/11-8.png)

图11-8 标记数组组织结构（64位运行时环境）

需要注意的是，16字节的粒度已足够精确，因为每个这样的内存区域最多只可能包含一个对象（请记住最小对象大小为24字节）。后续通过扫描标记数组中置位的比特位，即可获取对应对象的可达性信息。这是解决第一个并发标记问题的简易方案。

第二个问题则需要更深入的思考。当回收器遍历对象图时，若对象间的引用关系被修改会导致什么问题？可能会产生以下情形：

- 尚未被访问的对象修改了（新增、删除或同时操作）对其他对象的引用：这属于正常情况，由于该对象尚未被访问，垃圾回收器在后续访问时自然会包含这些变更。
- 已被访问的对象清除了对某个原本不可达对象的引用（见图11-9a）——这仍然安全。短时间内会产生所谓的“浮动垃圾”，随后垃圾回收器会发现该对象不可达并予以回收。
- 已被访问的对象新增了对某个原本不可达对象的引用（见图11-9b），例如创建新对象或从其他对象重新赋值引用：这种情况非常危险。可能导致垃圾回收器无法访问（标记）被引用的对象，使其被误判为垃圾回收——尽管该对象可能仍在被使用！这就是著名的“对象丢失”问题。正确的并发标记实现必须防止此类情况发生。
- 已被访问的对象修改了对某个原本可达对象的引用——需通过检查垃圾回收器是否能通过其他引用访问该对象，才能判定是否属于“对象丢失”问题。
- 正在被访问的对象修改了自身引用——这需要确认该引用是否已被访问。若未被访问则回归第一种情况；若已访问，则可能适用前三种情形之一。

![](asserts/11-9.png)

图11-9 并发标记期间可能出现的问题：(a) 产生浮动垃圾，(b) 对象丢失问题

针对上述问题的解决方案看似显而易见——应当重新访问那些存在问题的对象！现有多种并发标记技术，它们在“浮动垃圾”数量、需要重新访问的对象数量，以及用户线程与垃圾回收器之间的同步开销等方面做出了不同取舍。

.NET选择采用了一种简单而高效的**写屏障**技术。每当已被访问（或正在被访问）的对象发生修改时，该对象就会被标记为“待重新访问”。在Windows平台上（.NET 5之前），修改记录列表由操作系统通过已知的 `WriteWatch` 机制管理（该机制在第5章讲解卡表时也有提及）。此机制以内存页为粒度，因此即使只修改单个对象，也会导致整个4KB页面失效。对于非 Windows 运行时，以及自 .NET 5 起的Windows平台，CLR 通过 JIT 注入的特殊写入屏障实现了自主的 `Write Watch` 机制，这些屏障会修改专用数组中的对应字节。在垃圾回收过程中的特定时刻，系统会扫描修改记录列表（可称为写入监视列表），并将已标记对象作为新增根节点重新访问。这便优雅地解决了第二个并发标记问题。

> - 传统Windows ( .NET 5之前)：利用操作系统的 WriteWatchAPI。这个API能监测哪些内存页（Page，通常4KB）发生了写入。当GC需要时，它可以查询哪些页“脏了”。**缺点**就是粒度粗（4KB）。即使只改了一个对象的1个字节，整个4KB页面都会被标记为脏，导致GC可能需要重新检查该页面内所有已标记对象。
> - 非Windows平台及.NET 5+的Windows：CLR实现了自己的、更细粒度的“写监视”机制。JIT注入的写屏障会直接修改一个由CLR管理的专用字节数组中的对应字节（标记该小块内存区域“脏了”）。这种方式通常比页面粒度更精确，开销也可能更低。

因此，回顾后台GC的各个阶段（如图11-6和11-7所示），其工作流程如下：

- 初始“停止世界”阶段(A)：当线程暂停时，系统会准备初始列表。此阶段仅扫描栈和终结队列，为后续并发标记构建“工作列表”。该工作列表仅包含已发现的对象，此时暂不追踪它们的对外引用。

- 并发标记阶段（B）：当用户线程运行时，执行并发标记的主要工作。该阶段会遍历以下根对象（在标记数组中标示对象）：

  - **句柄**。
  - **前一步骤准备好的工作列表**：此处会处理来自堆栈的大规模对象图。此阶段会触发 `BGCDrainMark ETW/EventPipe` 事件，记录工作列表中的对象数量。

  - **写监视列表**：在并发标记结束时，会检查此阶段发生的所有对象修改。此阶段触发 `BGCRevisit ETW/EventPipe` 事件，描述初始“脏”页数量及最终因此被标记的对象数。

- 最终标记，“Stop the World”阶段（C）：这是“最终确认”时刻。所有线程暂停，GC有机会完成收尾工作。此时标记数组应已较好反映对象可达性状态，但为确保万无一失，仍需重新检查（注意这是增量式工作）。由于对象图遍历会参考标记数组中的标记位，许多对象无需重复访问。重新扫描根对象仅用于确保没有新增的可达对象——这会产生一些浮动垃圾（已标记对象不会被取消标记），但如前所述，这不会影响结果的正确性。最终标记阶段会处理以下根对象：

  - 堆栈、终结队列和句柄。

  - 写监视列表——涵盖GC在之前检查中未能跟上的所有修改

  - 同时完成所有典型标记相关工作（如扫描依存句柄和弱引用）

> 在.NET Core中，并发标记的核心逻辑位于 `gc_heap::background_mark_phase` 方法。最重要的两个数据结构是 `mark_array`（图11-8中的数组）和 `c_mark_list`（初始阶段填充的“工作列表”）。`c_mark_list` 由 `gc_heap::background_promote_callback` 方法在扫描堆栈和终结队列时填充，随后由 `gc_heap::background_drain_mark_list` 方法消费。
>
> 写监视列表通过 `gc_heap::revisit_written_pages` 方法读取，该方法调用 `gc_heap::get_write_watch_for_gc_heap` 获取已更新的内存位置列表并逐对象扫描。当启用软件写监视时，可在写屏障（如 `JIT_WriteBarrier_WriteWatch_PreGrow64`）中看到其使用。
>
> 所有并发标记工作通过 `gc_heap::background_promote` 方法实现，该方法经由 `gc_heap::background_mark_simple` 和 `gc_heap::background_mark_simple1` 遍历对象图（最终由 `gc_heap::background_mark1` 方法设置 `mark_array` 中的对应标记位）。

总结：

- 并发标记会产生浮动垃圾，导致垃圾回收策略相对保守——相比阻塞式标记，更多死亡对象会占用内存更长时间。
- 后台GC期间频繁的对象引用关系修改可能使大量页失效，从而迫使GC重新访问大量对象。

#### 并发清扫

在并发清扫阶段开始时，标记数组已包含所有存活对象的信息。与第9、10章描述的非并发式计划与清扫阶段类似，这些信息将用于清理死亡对象。该阶段会逐一遍历堆中的对象，对照标记数组进行检查，并为不可达对象创建空闲列表项（具体实现方式与第10章完全一致，包括更新代际分配器）。由于SOH（小对象堆）分配可能在并发清扫期间发生，观察二者的交互机制尤为重要。

该过程包含以下步骤：

- **初始化准备**：运行时恢复用户线程执行前，所有代际的空闲列表项会被清空——这使得分配器在短时间内无法感知可用空间（它们只能在当前已消耗的段/区域末端进行分配）。
- **短暂代并发清扫**：首先在0/1代执行快速清扫，操作独立空闲列表以避免用户线程分配与并发GC同时访问列表的冲突。清扫完成后立即发布该列表，使短暂代分配器可立即使用回收空间。此阶段禁止前台GC（因其可能触发压缩操作，与逐对象扫描产生冲突）。
- **持久代并发清扫**：随后处理2代、大对象堆(LOH)和固定对象堆(POH)，生成的空闲列表项会立即发布给对应分配器。
  - 此时用户线程在0代分配时可使用已发布的空闲空间，同时允许前台GC运行。
  - 若对象从1代提升至2代，将直接消费2代已创建的空闲列表项（由于前台GC会临时挂起后台GC，不存在并发访问风险）。
- 历史版本中整个过程中禁止LOH分配，但自.NET Core 3.1起允许在2代清扫时进行大对象分配。不过LOH清扫期间仍禁止分配（避免GC修改列表时分配器并发访问），试图分配大对象的线程会被阻塞直至清扫完成。与普通模式相同，并发清扫期间可能释放空内存段。

> 在.NET代码中，并发清扫由 `gc_heap::background_sweep` 方法实现。该方法先调用 `c_heap::background_ephemeral_sweep` 扫描0/1代对象，随后处理2代、LOH和POH（每扫描256个对象后，通过 `gc_heap::allow_fgc` 方法在安全点允许前台GC介入）。对象扫描过程中，沿用已知的 `gc_heap::thread_gap` 和 `gc_heap::make_unused_array` 方法分别创建空闲列表项和不可用碎片空间。

> .NET垃圾回收（GC）流程中，为防止并发竞用，以下步骤必须同步执行（通常通过暂停托管线程，即STW，Stop-The-World机制）：
>
> 1. **初始标记（Initial Mark）**
>    - 需要暂停所有托管线程，扫描根对象（如静态变量、线程栈等）并标记直接可达对象。
>    - 目的是确保根对象状态一致，避免并发修改导致漏标。
> 2. **最终标记（Final Mark）**
>    - 在并发标记完成后，再次暂停所有托管线程，处理并发期间发生的引用变更（如写屏障记录的修改）。
>    - 重新标记因并发修改而可能遗漏的对象，确保标记完整。
> 3. **对象移动与压缩（Compaction）**
>    - 移动对象内存地址时必须暂停所有托管线程，防止对象引用失效。
>    - 压缩完成后更新引用指针，再恢复线程。
> 4. **清理阶段（Cleanup）**
>    - 回收未被引用的内存区域时，部分操作需暂停线程以保证内存状态一致。
>    - 如重置跨代引用卡表（Card Table）等。
> 5. **终结器队列处理（Finalization）**
>    - 虽然终结器在独立线程执行，但GC调度终结器运行时，需同步等待终结器线程完成，避免资源提前释放或状态不一致。
> 6. **晋升与跨代引用更新**
>    - 对象晋升（如从Gen0到Gen1）时，需同步更新跨代引用的标记，防止并发写入导致引用丢失。
>
> 总结来说，**所有涉及根扫描、标记开始和结束、对象移动（压缩）以及跨代引用更新的关键步骤都必须同步执行，通常通过暂停应用线程实现**。并发标记阶段本身允许后台线程与应用线程并行运行，但会通过写屏障和最终标记阶段来保证数据一致性。
>
> 这些同步点保证了GC的正确性，避免了并发竞用导致的内存泄漏或程序错误[3](https://stackoverflow.com/questions/17130382/understanding-garbage-collection-in-net)[5](https://www.red-gate.com/simple-talk/development/dotnet-development/understanding-garbage-collection-in-net/)[8](https://citeseerx.ist.psu.edu/document?repid=rep1&type=pdf&doi=c21ad4f7ba6a96df2b255c437f09b5fadf1b1f1f)。

### 服务器非并发模式

自.NET诞生之初直至.NET Framework 4.5版本，该模式一直是专为服务器（主要是Web）应用程序设计的默认独占模式。实际上，它是对前文所述“工作站非并发模式”的简单扩展——所有垃圾回收（GC）操作都是阻塞式的，无论回收哪个代际。但需特别注意的是，从内存管理视角来看存在一个重要差异：默认情况下，托管堆（Managed Heap）的数量与逻辑CPU核心数相同。

服务器非并发GC模式具有以下特征（参见图11-10）：

- 存在专用于GC的额外线程（称为服务器GC线程）——默认数量与托管堆数量严格对应。这些线程大部分时间处于挂起状态等待工作，每个线程固定绑定到单个托管堆。
- 所有回收操作均为非并发GC——由于回收工作由多个GC线程并行处理，相比相同堆大小的工作站模式，其引发的暂停时间更短。作为“全局暂停”式回收，必要时任何回收都可执行压缩操作。
- 此外，采用标记窃取（mark stealing）技术实现多GC线程间的标记工作负载均衡：当因存活对象引用分布不均导致堆间不平衡时，GC线程会动态“窃取”其他线程待遍历的对象批次进行处理。

![](asserts/11-10.png)

图11-10 服务器非并发GC模式示意图

在服务器GC模式中，托管堆数量（即GC线程数）不必与机器逻辑CPU核心数严格对应。自.NET Framework 4.6+和.NET Core起，新增了 `GCHeapCount` 配置项——该参数专门指定GC使用的线程与托管堆数量。此配置仅适用于服务器GC模式，可通过 `COMPlus_GCHeapCount` 环境变量（.NET Core也支持 `DOTNET_GCHeapCount`）或XML/JSON配置文件设置（见代码清单11-3）。设定值必须小于进程可用的逻辑CPU数量（因操作系统存在多种限制核心数的机制），否则将自动截取为最大可用值。

代码清单11-3 配置GC相关线程及托管堆数量

```xml
<configuration>
  <runtime>
    <gcServer enabled="true"/>
    <GCHeapCount enabled="6"/>
  </runtime>
</configuration>
```

早期版本中，实现此类限制的唯一方式是直接约束进程可用的逻辑核心数。但这种方式存在严重缺陷——它会全局影响运行时环境，而不仅作用于GC子系统。这意味着即使开发者仅希望对GC进行限制，整个.NET程序的并发能力也会遭受不必要的削弱。因此自 `GCHeapCount` 配置引入后，该方式已成为控制GC相关参数的首选方案。

> 另有 `GCNoAffinitize` 与 `GCHeapAffinitizeMask` 这一对参数用于控制线程/堆的CPU亲和性。当系统存在大量未被充分利用的CPU核心（例如通过 `GCHeapCount` 限制了线程数时），可通过这些设置将特定CPU核心专用于指定应用，实现精确的CPU资源分配。

典型应用场景：

- 在高负载Web服务器中，当多个应用的并发线程导致CPU核心资源激烈争用时，此模式比后文所述更耗资源的“后台服务器GC”更合适。通过 `GCHeapCount` 可进一步限制线程数量。
- 由于所有GC（包括完全回收）都可能执行压缩操作，该模式相比并发版本能更有效对抗内存碎片，从而减小工作集内存占用。
- 所有GC操作均为阻塞式，因此在并发标记阶段不会产生浮动垃圾（floating garbage），这进一步降低了工作集大小。
