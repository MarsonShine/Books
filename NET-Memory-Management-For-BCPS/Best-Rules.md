推荐的原则：

## 1. 尽量避免随机访问，而推崇顺序访问

## 2. 提高空间和时间数据的局部性

## 3.测量自己的程序

## 4.不要假设这里有/没有内存泄露

## 5.考虑使用结构体

## 6.考虑使用字符串驻留

## 7.避免装箱

## 8.在热路径上避免在堆上分配

以下是GC相关规则的核心要点总结：

## 规则17 - 监控运行时暂停

- **优化GC暂停**：GC暂停需控制在亚毫秒级
- 诊断工具
  - 使用PerfView分析`GC Events`表
  - 若暂停>1ms，排查高优先级线程或同步I/O阻塞问题
- **场景关联**：结合场景7-4分析线程挂起问题

## 规则18 - 避免对象“中年危机”

- **分代假设**：短命对象应快速回收，避免晋升到Gen2后死亡
- 优化措施
  - 分析Gen2对象死亡原因（`Gen 2 Object Deaths`视图）
  - 减少临时对象持有时间，使用对象池（见第6章）
  - 警惕终结器导致对象晋升
- 诊断工具
  - `dotnet-gcdump`/PerfView分析老年代内容
  - 监控高频分配类型（场景6-2）

## 规则19 - 控制老年代与LOH碎片化

- 碎片化风险

  - SOH Gen2碎片导致压缩成本高

  - LOH碎片需手动压缩（默认不自动处理）

- 优化策略
  - 优先监控`% Time in GC`和内存增长
  - 使用数组池（`ArrayPool`）减少碎片源
  - 必要时显式调用`GCSettings.LargeObjectHeapCompactionMode`压缩LOH
- **诊断重点**：通过ETW/EventPipe追踪碎片率（场景10-1）

## 规则20 - 避免显式触发GC

- **原则**：信任GC自动调度机制
- 例外场景（极少数）
  - 内存关键操作前（如实时系统）
  - 测试性能基线时
- **风险**：破坏GC自适应策略，可能加剧性能问题
- **关联场景**：参考场景7-3中的非托管内存压力案例

## 规则21 - 防范内存泄漏

- **泄漏主因**：意外强引用（静态变量、未注销事件、IoC容器等）
- 诊断流程
  1. 区分托管/非托管泄漏（场景1-1至1-5）
  2. 使用`dotnet-gcdump`分析对象根引用链
  3. 检查高频存活对象类型（场景8-1/8-2）
- **应对策略**：弱引用、及时解绑事件、定期内存快照比对

## 规则22 - 谨慎使用对象固定(Pinning)

- **风险**：导致内存碎片，影响GC效率
- 优化实践
  - **短期固定**：`fixed`关键字限定极小作用域
  - **长期固定**：分配至Pinned Object Heap（POH），复用缓冲区
  - 避免“中期固定”（晋升到Gen1后存活）
- **监控指标**：观察`Pinned Objects`数量和碎片率变化（场景9-2）