推荐的原则：

## 1. 尽量避免随机访问，而推崇顺序访问

## 2. 提高空间和时间数据的局部性

## 3.测量自己的程序

## 4.不要假设这里有/没有内存泄露

## 5.考虑使用结构体

## 6.考虑使用字符串驻留

## 7.避免装箱

## 8.在热路径上避免在堆上分配

以下是GC相关规则的核心要点总结：

## 规则17 - 监控运行时暂停

- **优化GC暂停**：GC暂停需控制在亚毫秒级
- 诊断工具
  - 使用PerfView分析`GC Events`表
  - 若暂停>1ms，排查高优先级线程或同步I/O阻塞问题
- **场景关联**：结合场景7-4分析线程挂起问题

## 规则18 - 避免对象“中年危机”

- **分代假设**：短命对象应快速回收，避免晋升到Gen2后死亡
- 优化措施
  - 分析Gen2对象死亡原因（`Gen 2 Object Deaths`视图）
  - 减少临时对象持有时间，使用对象池（见第6章）
  - 警惕终结器导致对象晋升
- 诊断工具
  - `dotnet-gcdump`/PerfView分析老年代内容
  - 监控高频分配类型（场景6-2）

## 规则19 - 控制老年代与LOH碎片化

- 碎片化风险

  - SOH Gen2碎片导致压缩成本高

  - LOH碎片需手动压缩（默认不自动处理）

- 优化策略
  - 优先监控`% Time in GC`和内存增长
  - 使用数组池（`ArrayPool`）减少碎片源
  - 必要时显式调用`GCSettings.LargeObjectHeapCompactionMode`压缩LOH
- **诊断重点**：通过ETW/EventPipe追踪碎片率（场景10-1）

## 规则20 - 避免显式触发GC

- **原则**：信任GC自动调度机制
- 例外场景（极少数）
  - 内存关键操作前（如实时系统）
  - 测试性能基线时
- **风险**：破坏GC自适应策略，可能加剧性能问题
- **关联场景**：参考场景7-3中的非托管内存压力案例

## 规则21 - 防范内存泄漏

- **泄漏主因**：意外强引用（静态变量、未注销事件、IoC容器等）
- 诊断流程
  1. 区分托管/非托管泄漏（场景1-1至1-5）
  2. 使用`dotnet-gcdump`分析对象根引用链
  3. 检查高频存活对象类型（场景8-1/8-2）
- **应对策略**：弱引用、及时解绑事件、定期内存快照比对

## 规则22 - 谨慎使用对象固定(Pinning)

- **风险**：导致内存碎片，影响GC效率
- 优化实践
  - **短期固定**：`fixed`关键字限定极小作用域
  - **长期固定**：分配至Pinned Object Heap（POH），复用缓冲区
  - 避免“中期固定”（晋升到Gen1后存活）
- **监控指标**：观察`Pinned Objects`数量和碎片率变化（场景9-2）

## Rule 23 – **有意识地选择 GC 模式**

- .NET 提供多种 GC 模式（如Server/Workstation、并发/非并发），并允许配置堆数量、GC线程数等关键参数。大多数情况下，默认设置就够用，但了解并合理选择其它模式能优化性能。
- 根据应用特点（如服务器还是桌面程序、对暂停时长是否敏感）选定合适的GC模式。不同模式对CPU和内存影响各异，应通过实测来决定最佳配置。重视测试方法，比如用百分位数评估关键性能指标，尤其在预发布或生产环境下。
- 选择前先了解特性，优化需依赖测量，不能仅凭感觉。

## Rule 24 – **重视延迟模式（Latency Modes）**

- 除了主GC模式，还能用延迟模式调整GC的“侵入性”，即控制阻塞性GC的频率，达到响应速度和内存占用的平衡。低延迟模式适用于UI等对响应敏感场景，也适合部分对中断极为敏感的服务器应用（如金融交易）。
- 延迟模式需在应用代码中动态设置（如进入关键交互/交易时段时切换）。`SustainedLowLatency` 可长期用，`No GC Region` 则短暂禁止GC，适用于极端场景。只有在对性能极限有要求时，才需要精细调优。
- 延迟模式让你在应用关键时刻减小GC对响应的影响，但一般应用无需频繁调整。